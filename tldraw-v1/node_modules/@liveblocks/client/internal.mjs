import {
  L as LiveObject,
  q as LiveList,
  s as LiveMap,
  u as LiveRegister,
  b as isPlainObject,
  v as findNonSerializableValue,
  f as isLiveList,
  w as isLiveObject,
} from "./shared.mjs";
export {
  C as ClientMsgCode,
  I as CrdtType,
  e as OpCode,
  S as ServerMsgCode,
  W as WebsocketCloseCodes,
  x as assertNever,
  M as b64decode,
  G as comparePosition,
  D as deprecate,
  E as deprecateIf,
  o as errorIf,
  y as isAppOnlyAuthToken,
  z as isAuthToken,
  K as isChildCrdt,
  h as isJsonArray,
  l as isJsonObject,
  J as isJsonScalar,
  b as isPlainObject,
  A as isRoomAuthToken,
  k as isRootCrdt,
  B as isScope,
  H as makePosition,
  n as nn,
  F as throwUsageError,
  t as tryParseJson,
} from "./shared.mjs";
function lsonObjectToJson(obj) {
  const result = {};
  for (const key in obj) {
    const val = obj[key];
    void 0 !== val && (result[key] = lsonToJson(val));
  }
  return result;
}
function lsonListToJson(value) {
  return value.map(lsonToJson);
}
function lsonToJson(value) {
  return value instanceof LiveObject
    ? lsonObjectToJson(value.toObject())
    : value instanceof LiveList
    ? (function (value) {
        return lsonListToJson(value.toArray());
      })(value)
    : value instanceof LiveMap
    ? (function (map) {
        const result = {};
        for (const [key, value] of map.entries())
          result[key] = lsonToJson(value);
        return result;
      })(value)
    : value instanceof LiveRegister
    ? value.data
    : Array.isArray(value)
    ? lsonListToJson(value)
    : isPlainObject(value)
    ? lsonObjectToJson(value)
    : value;
}
function deepLiveify(value) {
  if (Array.isArray(value)) return new LiveList(value.map(deepLiveify));
  if (isPlainObject(value)) {
    const init = {};
    for (const key in value) {
      const val = value[key];
      void 0 !== val && (init[key] = deepLiveify(val));
    }
    return new LiveObject(init);
  }
  return value;
}
function patchLiveObjectKey(liveObject, key, prev, next) {
  if ("production" !== process.env.NODE_ENV) {
    const nonSerializableValue = findNonSerializableValue(next);
    if (nonSerializableValue)
      return void console.error(
        `New state path: '${nonSerializableValue.path}' value: '${nonSerializableValue.value}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`
      );
  }
  const value = liveObject.get(key);
  if (void 0 === next) liveObject.delete(key);
  else if (void 0 === value) liveObject.set(key, deepLiveify(next));
  else {
    if (prev === next) return;
    isLiveList(value) && Array.isArray(prev) && Array.isArray(next)
      ? (function (liveList, prev, next) {
          let i = 0,
            prevEnd = prev.length - 1,
            nextEnd = next.length - 1,
            prevNode = prev[0],
            nextNode = next[0];
          outer: {
            for (; prevNode === nextNode; ) {
              if ((++i, i > prevEnd || i > nextEnd)) break outer;
              (prevNode = prev[i]), (nextNode = next[i]);
            }
            for (
              prevNode = prev[prevEnd], nextNode = next[nextEnd];
              prevNode === nextNode;

            ) {
              if ((prevEnd--, nextEnd--, i > prevEnd || i > nextEnd))
                break outer;
              (prevNode = prev[prevEnd]), (nextNode = next[nextEnd]);
            }
          }
          if (i > prevEnd) {
            if (i <= nextEnd)
              for (; i <= nextEnd; )
                liveList.insert(deepLiveify(next[i]), i), i++;
          } else if (i > nextEnd) {
            let localI = i;
            for (; localI <= prevEnd; ) liveList.delete(i), localI++;
          } else {
            for (; i <= prevEnd && i <= nextEnd; ) {
              (prevNode = prev[i]), (nextNode = next[i]);
              const liveListNode = liveList.get(i);
              isLiveObject(liveListNode) &&
              isPlainObject(prevNode) &&
              isPlainObject(nextNode)
                ? patchLiveObject(liveListNode, prevNode, nextNode)
                : liveList.set(i, deepLiveify(nextNode)),
                i++;
            }
            for (; i <= nextEnd; )
              liveList.insert(deepLiveify(next[i]), i), i++;
            let localI = i;
            for (; localI <= prevEnd; ) liveList.delete(i), localI++;
          }
        })(value, prev, next)
      : isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)
      ? patchLiveObject(value, prev, next)
      : liveObject.set(key, deepLiveify(next));
  }
}
function patchLiveObject(root, prev, next) {
  const updates = {};
  for (const key in next) patchLiveObjectKey(root, key, prev[key], next[key]);
  for (const key in prev) void 0 === next[key] && root.delete(key);
  Object.keys(updates).length > 0 && root.update(updates);
}
function patchImmutableObject(state, updates) {
  return updates.reduce(
    (state, update) =>
      (function (state, update) {
        const path = (function (node) {
          const path = [];
          for (; "HasParent" === node.parent.type; )
            isLiveList(node.parent.node)
              ? path.push(node.parent.node._indexOfPosition(node.parent.key))
              : path.push(node.parent.key),
              (node = node.parent.node);
          return path;
        })(update.node);
        return patchImmutableNode(state, path, update);
      })(state, update),
    state
  );
}
function patchImmutableNode(state, path, update) {
  var _a, _b, _c, _d;
  const pathItem = path.pop();
  if (void 0 === pathItem)
    switch (update.type) {
      case "LiveObject": {
        if (null === state || "object" != typeof state || Array.isArray(state))
          throw new Error(
            "Internal: received update on LiveObject but state was not an object"
          );
        const newState = Object.assign({}, state);
        for (const key in update.updates)
          if (
            "update" ===
            (null === (_a = update.updates[key]) || void 0 === _a
              ? void 0
              : _a.type)
          ) {
            const val = update.node.get(key);
            void 0 !== val && (newState[key] = lsonToJson(val));
          } else
            "delete" ===
              (null === (_b = update.updates[key]) || void 0 === _b
                ? void 0
                : _b.type) && delete newState[key];
        return newState;
      }
      case "LiveList": {
        if (!Array.isArray(state))
          throw new Error(
            "Internal: received update on LiveList but state was not an array"
          );
        let newState = state.map((x) => x);
        for (const listUpdate of update.updates)
          "set" === listUpdate.type
            ? (newState = newState.map((item, index) =>
                index === listUpdate.index ? lsonToJson(listUpdate.item) : item
              ))
            : "insert" === listUpdate.type
            ? listUpdate.index === newState.length
              ? newState.push(lsonToJson(listUpdate.item))
              : (newState = [
                  ...newState.slice(0, listUpdate.index),
                  lsonToJson(listUpdate.item),
                  ...newState.slice(listUpdate.index),
                ])
            : "delete" === listUpdate.type
            ? newState.splice(listUpdate.index, 1)
            : "move" === listUpdate.type &&
              (newState =
                listUpdate.previousIndex > listUpdate.index
                  ? [
                      ...newState.slice(0, listUpdate.index),
                      lsonToJson(listUpdate.item),
                      ...newState.slice(
                        listUpdate.index,
                        listUpdate.previousIndex
                      ),
                      ...newState.slice(listUpdate.previousIndex + 1),
                    ]
                  : [
                      ...newState.slice(0, listUpdate.previousIndex),
                      ...newState.slice(
                        listUpdate.previousIndex + 1,
                        listUpdate.index + 1
                      ),
                      lsonToJson(listUpdate.item),
                      ...newState.slice(listUpdate.index + 1),
                    ]);
        return newState;
      }
      case "LiveMap": {
        if (null === state || "object" != typeof state || Array.isArray(state))
          throw new Error(
            "Internal: received update on LiveMap but state was not an object"
          );
        const newState = Object.assign({}, state);
        for (const key in update.updates)
          if (
            "update" ===
            (null === (_c = update.updates[key]) || void 0 === _c
              ? void 0
              : _c.type)
          ) {
            const value = update.node.get(key);
            void 0 !== value && (newState[key] = lsonToJson(value));
          } else
            "delete" ===
              (null === (_d = update.updates[key]) || void 0 === _d
                ? void 0
                : _d.type) && delete newState[key];
        return newState;
      }
    }
  if (Array.isArray(state)) {
    const newArray = [...state];
    return (
      (newArray[pathItem] = patchImmutableNode(state[pathItem], path, update)),
      newArray
    );
  }
  if (null !== state && "object" == typeof state) {
    const node = state[pathItem];
    return void 0 === node
      ? state
      : Object.assign(Object.assign({}, state), {
          [pathItem]: patchImmutableNode(node, path, update),
        });
  }
  return state;
}
export { lsonToJson, patchImmutableObject, patchLiveObjectKey };
