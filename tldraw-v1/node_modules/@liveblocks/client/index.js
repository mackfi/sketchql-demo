"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var Json = require("./shared.js"),
  _excluded = ["_hasReceivedInitialPresence"],
  BACKOFF_RETRY_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4],
  BACKOFF_RETRY_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];
function makeOthers(userMap) {
  var _ref,
    users = Object.values(userMap).map(function (user) {
      return (
        user._hasReceivedInitialPresence,
        Json._objectWithoutPropertiesLoose(user, _excluded)
      );
    });
  return (
    ((_ref = {
      get count() {
        return users.length;
      },
    })[Symbol.iterator] = function () {
      return users[Symbol.iterator]();
    }),
    (_ref.map = function (callback) {
      return users.map(callback);
    }),
    (_ref.toArray = function () {
      return users;
    }),
    _ref
  );
}
function makeStateMachine(state, context, mockedEffects) {
  var effects = mockedEffects || {
    authenticate: function (auth, createWebSocket) {
      var rawToken = state.token,
        parsedToken = null !== rawToken && Json.parseRoomAuthToken(rawToken);
      if (!parsedToken || Json.isTokenExpired(parsedToken))
        return auth(context.roomId)
          .then(function (_ref2) {
            var token = _ref2.token;
            "authenticating" === state.connection.state &&
              (authenticationSuccess(
                Json.parseRoomAuthToken(token),
                createWebSocket(token)
              ),
              (state.token = token));
          })
          .catch(function (er) {
            return (function (error) {
              "production" !== process.env.NODE_ENV &&
                console.error("Call to authentication endpoint failed", error);
              (state.token = null),
                updateConnection({ state: "unavailable" }),
                state.numberOfRetry++,
                (state.timeoutHandles.reconnect = effects.scheduleReconnect(
                  getRetryDelay()
                ));
            })(er instanceof Error ? er : new Error(String(er)));
          });
      authenticationSuccess(parsedToken, createWebSocket(rawToken));
    },
    send: function (messageOrMessages) {
      if (null == state.socket)
        throw new Error("Can't send message if socket is null");
      state.socket.send(JSON.stringify(messageOrMessages));
    },
    delayFlush: function (delay) {
      return setTimeout(tryFlushing, delay);
    },
    startHeartbeatInterval: function () {
      return setInterval(heartbeat, 3e4);
    },
    schedulePongTimeout: function () {
      return setTimeout(pongTimeout, 2e3);
    },
    scheduleReconnect: function (delay) {
      return setTimeout(connect, delay);
    },
  };
  function genericSubscribe(callback) {
    return (
      state.listeners.storage.push(callback),
      function () {
        return Json.remove(state.listeners.storage, callback);
      }
    );
  }
  function createOrUpdateRootFromMessage(message) {
    if (0 === message.items.length)
      throw new Error("Internal error: cannot load storage without items");
    var items, _buildRootAndParentTo, root, parentToChildren;
    for (var _key in (state.root
      ? (function (items) {
          if (!state.root) return;
          var currentItems = new Map();
          state.items.forEach(function (liveCrdt, id) {
            currentItems.set(id, liveCrdt._toSerializedCrdt());
          }),
            notify(
              apply(
                Json.getTreesDiffOperations(currentItems, new Map(items)),
                !1
              ).updates
            );
        })(message.items)
      : (state.root =
          ((items = message.items),
          (_buildRootAndParentTo = (function (items) {
            for (
              var _step2,
                parentToChildren = new Map(),
                root = null,
                _iterator2 = Json._createForOfIteratorHelperLoose(items);
              !(_step2 = _iterator2()).done;

            ) {
              var _step2$value = _step2.value,
                id = _step2$value[0],
                crdt = _step2$value[1];
              if (Json.isRootCrdt(crdt)) root = [id, crdt];
              else {
                var tuple = [id, crdt],
                  children = parentToChildren.get(crdt.parentId);
                null != children
                  ? children.push(tuple)
                  : parentToChildren.set(crdt.parentId, [tuple]);
              }
            }
            if (null == root) throw new Error("Root can't be null");
            return [root, parentToChildren];
          })(items)),
          (root = _buildRootAndParentTo[0]),
          (parentToChildren = _buildRootAndParentTo[1]),
          Json.LiveObject._deserialize(root, parentToChildren, {
            getItem: getItem,
            addItem: addItem,
            deleteItem: deleteItem,
            generateId: generateId,
            generateOpId: generateOpId,
            dispatch: storageDispatch,
            roomId: context.roomId,
          }))),
    state.defaultStorageRoot))
      null == state.root.get(_key) &&
        state.root.set(_key, state.defaultStorageRoot[_key]);
  }
  function addItem(id, liveItem) {
    state.items.set(id, liveItem);
  }
  function deleteItem(id) {
    state.items.delete(id);
  }
  function getItem(id) {
    return state.items.get(id);
  }
  function addToUndoStack(historyItem) {
    var _state$pausedHistory;
    (state.undoStack.length >= 50 && state.undoStack.shift(),
    state.isHistoryPaused)
      ? (_state$pausedHistory = state.pausedHistory).unshift.apply(
          _state$pausedHistory,
          historyItem
        )
      : state.undoStack.push(historyItem);
  }
  function storageDispatch(ops, reverse, storageUpdates) {
    var _state$batch$ops, _state$batch$reverseO;
    state.isBatching
      ? ((_state$batch$ops = state.batch.ops).push.apply(_state$batch$ops, ops),
        storageUpdates.forEach(function (value, key) {
          state.batch.updates.storageUpdates.set(
            key,
            Json.mergeStorageUpdates(
              state.batch.updates.storageUpdates.get(key),
              value
            )
          );
        }),
        (_state$batch$reverseO = state.batch.reverseOps).push.apply(
          _state$batch$reverseO,
          reverse
        ))
      : (addToUndoStack(reverse),
        (state.redoStack = []),
        dispatch(ops),
        notify({ storageUpdates: storageUpdates }));
  }
  function notify(_ref3) {
    var _ref3$storageUpdates = _ref3.storageUpdates,
      storageUpdates =
        void 0 === _ref3$storageUpdates ? new Map() : _ref3$storageUpdates,
      _ref3$presence = _ref3.presence,
      presence = void 0 !== _ref3$presence && _ref3$presence,
      _ref3$others = _ref3.others,
      otherEvents = void 0 === _ref3$others ? [] : _ref3$others;
    if (otherEvents.length > 0) {
      state.others = makeOthers(state.users);
      for (
        var _step3,
          _iterator3 = Json._createForOfIteratorHelperLoose(otherEvents);
        !(_step3 = _iterator3()).done;

      )
        for (
          var _step4,
            _event = _step3.value,
            _iterator4 = Json._createForOfIteratorHelperLoose(
              state.listeners.others
            );
          !(_step4 = _iterator4()).done;

        ) {
          (0, _step4.value)(state.others, _event);
        }
    }
    if (presence)
      for (
        var _step5,
          _iterator5 = Json._createForOfIteratorHelperLoose(
            state.listeners["my-presence"]
          );
        !(_step5 = _iterator5()).done;

      ) {
        (0, _step5.value)(state.me);
      }
    if (storageUpdates.size > 0)
      for (
        var _step6,
          _iterator6 = Json._createForOfIteratorHelperLoose(
            state.listeners.storage
          );
        !(_step6 = _iterator6()).done;

      ) {
        (0, _step6.value)(Array.from(storageUpdates.values()));
      }
  }
  function getConnectionId() {
    if (
      "open" === state.connection.state ||
      "connecting" === state.connection.state
    )
      return state.connection.id;
    if (null !== state.lastConnectionId) return state.lastConnectionId;
    throw new Error(
      "Internal. Tried to get connection id but connection was never open"
    );
  }
  function generateId() {
    return getConnectionId() + ":" + state.clock++;
  }
  function generateOpId() {
    return getConnectionId() + ":" + state.opClock++;
  }
  function apply(item, isLocal) {
    for (
      var _step7,
        result = {
          reverse: [],
          updates: { storageUpdates: new Map(), presence: !1 },
        },
        createdNodeIds = new Set(),
        _iterator7 = Json._createForOfIteratorHelperLoose(item);
      !(_step7 = _iterator7()).done;

    ) {
      var op = _step7.value;
      if ("presence" === op.type) {
        var reverse = { type: "presence", data: {} };
        for (var _key2 in op.data) reverse.data[_key2] = state.me[_key2];
        if (
          ((state.me = Json._extends({}, state.me, op.data)),
          null == state.buffer.presence)
        )
          state.buffer.presence = op.data;
        else
          for (var _key3 in op.data)
            state.buffer.presence[_key3] = op.data[_key3];
        result.reverse.unshift(reverse), (result.updates.presence = !0);
      } else {
        var source = void 0;
        if ((op.opId || (op.opId = generateOpId()), isLocal))
          source = Json.OpSource.UNDOREDO_RECONNECT;
        else
          source = state.offlineOperations.delete(Json.nn(op.opId))
            ? Json.OpSource.ACK
            : Json.OpSource.REMOTE;
        var applyOpResult = applyOp(op, source);
        if (applyOpResult.modified) {
          var _result$reverse,
            parentId =
              "HasParent" === applyOpResult.modified.node.parent.type
                ? Json.nn(
                    applyOpResult.modified.node.parent.node._id,
                    "Expected parent node to have an ID"
                  )
                : void 0;
          if (!parentId || !createdNodeIds.has(parentId))
            result.updates.storageUpdates.set(
              Json.nn(applyOpResult.modified.node._id),
              Json.mergeStorageUpdates(
                result.updates.storageUpdates.get(
                  Json.nn(applyOpResult.modified.node._id)
                ),
                applyOpResult.modified
              )
            ),
              (_result$reverse = result.reverse).unshift.apply(
                _result$reverse,
                applyOpResult.reverse
              );
          (op.type !== Json.OpCode.CREATE_LIST &&
            op.type !== Json.OpCode.CREATE_MAP &&
            op.type !== Json.OpCode.CREATE_OBJECT) ||
            createdNodeIds.add(Json.nn(applyOpResult.modified.node._id));
        }
      }
    }
    return result;
  }
  function applyOp(op, source) {
    switch (op.type) {
      case Json.OpCode.DELETE_OBJECT_KEY:
      case Json.OpCode.UPDATE_OBJECT:
      case Json.OpCode.DELETE_CRDT:
        var item = state.items.get(op.id);
        return null == item
          ? { modified: !1 }
          : item._apply(op, source === Json.OpSource.UNDOREDO_RECONNECT);
      case Json.OpCode.SET_PARENT_KEY:
        var _item = state.items.get(op.id);
        return null == _item
          ? { modified: !1 }
          : "HasParent" === _item.parent.type &&
            Json.isLiveList(_item.parent.node)
          ? _item.parent.node._setChildKey(op.parentKey, _item, source)
          : { modified: !1 };
      case Json.OpCode.CREATE_OBJECT:
      case Json.OpCode.CREATE_LIST:
      case Json.OpCode.CREATE_MAP:
      case Json.OpCode.CREATE_REGISTER:
        if (void 0 === op.parentId) return { modified: !1 };
        var parent = state.items.get(op.parentId);
        return null == parent
          ? { modified: !1 }
          : parent._attachChild(op, source);
    }
  }
  function connect() {
    var _context$polyfills$fe,
      _context$polyfills,
      _context$polyfills$We,
      _context$polyfills2;
    if (
      "closed" !== state.connection.state &&
      "unavailable" !== state.connection.state
    )
      return null;
    var auth = (function (authentication, fetchPolyfill) {
        if ("public" === authentication.type) {
          if ("undefined" == typeof window && null == fetchPolyfill)
            throw new Error(
              "To use Liveblocks client in a non-dom environment with a publicApiKey, you need to provide a fetch polyfill."
            );
          return function (room) {
            return fetchAuthEndpoint(
              fetchPolyfill || fetch,
              authentication.url,
              { room: room, publicApiKey: authentication.publicApiKey }
            );
          };
        }
        if ("private" === authentication.type) {
          if ("undefined" == typeof window && null == fetchPolyfill)
            throw new Error(
              "To use Liveblocks client in a non-dom environment with a url as auth endpoint, you need to provide a fetch polyfill."
            );
          return function (room) {
            return fetchAuthEndpoint(
              fetchPolyfill || fetch,
              authentication.url,
              { room: room }
            );
          };
        }
        if ("custom" === authentication.type) {
          return function (room) {
            return authentication.callback(room).then(function (response) {
              if (!response || !response.token)
                throw new Error(
                  'Authentication error. We expect the authentication callback to return a token, but it does not. Hint: the return value should look like: { token: "..." }'
                );
              return response;
            });
          };
        }
        throw new Error("Internal error. Unexpected authentication type");
      })(
        context.authentication,
        null !=
          (_context$polyfills$fe =
            null == (_context$polyfills = context.polyfills)
              ? void 0
              : _context$polyfills.fetch)
          ? _context$polyfills$fe
          : context.fetchPolyfill
      ),
      createWebSocket = (function (liveblocksServer, WebSocketPolyfill) {
        if ("undefined" == typeof window && null == WebSocketPolyfill)
          throw new Error(
            "To use Liveblocks client in a non-dom environment, you need to provide a WebSocket polyfill."
          );
        var ws = WebSocketPolyfill || WebSocket;
        return function (token) {
          return new ws(
            liveblocksServer + "/?token=" + token + "&version=0.17.7"
          );
        };
      })(
        context.liveblocksServer,
        null !=
          (_context$polyfills$We =
            null == (_context$polyfills2 = context.polyfills)
              ? void 0
              : _context$polyfills2.WebSocket)
          ? _context$polyfills$We
          : context.WebSocketPolyfill
      );
    updateConnection({ state: "authenticating" }),
      effects.authenticate(auth, createWebSocket);
  }
  function authenticationSuccess(token, socket) {
    var connectionId, count;
    socket.addEventListener("message", onMessage),
      socket.addEventListener("open", onOpen),
      socket.addEventListener("close", onClose),
      socket.addEventListener("error", onError),
      updateConnection({
        state: "connecting",
        id: token.actor,
        userInfo: token.info,
        userId: token.id,
      }),
      (state.idFactory =
        ((connectionId = token.actor),
        (count = 0),
        function () {
          return connectionId + ":" + count++;
        })),
      (state.socket = socket);
  }
  function onUpdatePresenceMessage(message) {
    var user = state.users[message.actor];
    if (
      void 0 !== message.targetActor ||
      null == user ||
      user._hasReceivedInitialPresence
    )
      return (
        (state.users[message.actor] =
          null == user
            ? {
                connectionId: message.actor,
                presence: message.data,
                id: void 0,
                info: void 0,
                _hasReceivedInitialPresence: !0,
              }
            : {
                id: user.id,
                info: user.info,
                connectionId: message.actor,
                presence: Json._extends({}, user.presence, message.data),
                _hasReceivedInitialPresence: !0,
              }),
        {
          type: "update",
          updates: message.data,
          user: state.users[message.actor],
        }
      );
  }
  function onUserLeftMessage(message) {
    var userLeftMessage = message,
      user = state.users[userLeftMessage.actor];
    return user
      ? (delete state.users[userLeftMessage.actor],
        { type: "leave", user: user })
      : null;
  }
  function onRoomStateMessage(message) {
    var newUsers = {};
    for (var _key5 in message.users) {
      var _connectionId = Number.parseInt(_key5),
        user = message.users[_key5];
      newUsers[_connectionId] = {
        connectionId: _connectionId,
        info: user.info,
        id: user.id,
      };
    }
    return (state.users = newUsers), { type: "reset" };
  }
  function onEvent(message) {
    for (
      var _step8,
        _iterator8 = Json._createForOfIteratorHelperLoose(
          state.listeners.event
        );
      !(_step8 = _iterator8()).done;

    ) {
      (0, _step8.value)({ connectionId: message.actor, event: message.event });
    }
  }
  function onUserJoinedMessage(message) {
    return (
      (state.users[message.actor] = {
        connectionId: message.actor,
        info: message.info,
        id: message.id,
        _hasReceivedInitialPresence: !0,
      }),
      state.me &&
        (state.buffer.messages.push({
          type: Json.ClientMsgCode.UPDATE_PRESENCE,
          data: state.me,
          targetActor: message.actor,
        }),
        tryFlushing()),
      { type: "enter", user: state.users[message.actor] }
    );
  }
  function parseServerMessage(data) {
    return Json.isJsonObject(data) ? data : null;
  }
  function onMessage(event) {
    if ("pong" !== event.data) {
      var text,
        data,
        messages =
          ((text = event.data),
          void 0 === (data = Json.tryParseJson(text))
            ? null
            : Json.isJsonArray(data)
            ? Json.compact(
                data.map(function (item) {
                  return parseServerMessage(item);
                })
              )
            : Json.compact([parseServerMessage(data)]));
      if (null !== messages && 0 !== messages.length) {
        for (
          var _step9,
            updates = { storageUpdates: new Map(), others: [] },
            _iterator9 = Json._createForOfIteratorHelperLoose(messages);
          !(_step9 = _iterator9()).done;

        ) {
          var message = _step9.value;
          switch (message.type) {
            case Json.ServerMsgCode.USER_JOINED:
              updates.others.push(onUserJoinedMessage(message));
              break;
            case Json.ServerMsgCode.UPDATE_PRESENCE:
              var othersPresenceUpdate = onUpdatePresenceMessage(message);
              othersPresenceUpdate && updates.others.push(othersPresenceUpdate);
              break;
            case Json.ServerMsgCode.BROADCASTED_EVENT:
              onEvent(message);
              break;
            case Json.ServerMsgCode.USER_LEFT:
              var _event2 = onUserLeftMessage(message);
              _event2 && updates.others.push(_event2);
              break;
            case Json.ServerMsgCode.ROOM_STATE:
              updates.others.push(onRoomStateMessage(message));
              break;
            case Json.ServerMsgCode.INITIAL_STORAGE_STATE:
              var offlineOps = new Map(state.offlineOperations);
              createOrUpdateRootFromMessage(message),
                applyAndSendOfflineOps(offlineOps),
                null == _getInitialStateResolver || _getInitialStateResolver();
              break;
            case Json.ServerMsgCode.UPDATE_STORAGE:
              apply(message.ops, !1).updates.storageUpdates.forEach(function (
                value,
                key
              ) {
                updates.storageUpdates.set(
                  key,
                  Json.mergeStorageUpdates(
                    updates.storageUpdates.get(key),
                    value
                  )
                );
              });
          }
        }
        notify(updates);
      }
    } else clearTimeout(state.timeoutHandles.pongTimeout);
  }
  function onClose(event) {
    if (
      ((state.socket = null),
      clearTimeout(state.timeoutHandles.pongTimeout),
      clearInterval(state.intervalHandles.heartbeat),
      state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush),
      clearTimeout(state.timeoutHandles.reconnect),
      (state.users = {}),
      notify({ others: [{ type: "reset" }] }),
      event.code >= 4e3 && event.code <= 4100)
    ) {
      updateConnection({ state: "failed" });
      for (
        var _step10,
          error = new LiveblocksError(event.reason, event.code),
          _iterator10 = Json._createForOfIteratorHelperLoose(
            state.listeners.error
          );
        !(_step10 = _iterator10()).done;

      ) {
        (0, _step10.value)(error);
      }
      var _delay = getRetryDelay(!0);
      state.numberOfRetry++,
        "production" !== process.env.NODE_ENV &&
          console.error(
            "Connection to Liveblocks websocket server closed. Reason: " +
              error.message +
              " (code: " +
              error.code +
              "). Retrying in " +
              _delay +
              "ms."
          ),
        updateConnection({ state: "unavailable" }),
        (state.timeoutHandles.reconnect = effects.scheduleReconnect(_delay));
    } else if (event.code === Json.WebsocketCloseCodes.CLOSE_WITHOUT_RETRY)
      updateConnection({ state: "closed" });
    else {
      var _delay2 = getRetryDelay();
      state.numberOfRetry++,
        "production" !== process.env.NODE_ENV &&
          console.warn(
            "Connection to Liveblocks websocket server closed (code: " +
              event.code +
              "). Retrying in " +
              _delay2 +
              "ms."
          ),
        updateConnection({ state: "unavailable" }),
        (state.timeoutHandles.reconnect = effects.scheduleReconnect(_delay2));
    }
  }
  function updateConnection(connection) {
    state.connection = connection;
    for (
      var _step11,
        _iterator11 = Json._createForOfIteratorHelperLoose(
          state.listeners.connection
        );
      !(_step11 = _iterator11()).done;

    ) {
      (0, _step11.value)(connection.state);
    }
  }
  function getRetryDelay(slow) {
    return (
      void 0 === slow && (slow = !1),
      slow
        ? BACKOFF_RETRY_DELAYS_SLOW[
            state.numberOfRetry < BACKOFF_RETRY_DELAYS_SLOW.length
              ? state.numberOfRetry
              : BACKOFF_RETRY_DELAYS_SLOW.length - 1
          ]
        : BACKOFF_RETRY_DELAYS[
            state.numberOfRetry < BACKOFF_RETRY_DELAYS.length
              ? state.numberOfRetry
              : BACKOFF_RETRY_DELAYS.length - 1
          ]
    );
  }
  function onError() {}
  function onOpen() {
    clearInterval(state.intervalHandles.heartbeat),
      (state.intervalHandles.heartbeat = effects.startHeartbeatInterval()),
      "connecting" === state.connection.state &&
        (updateConnection(
          Json._extends({}, state.connection, { state: "open" })
        ),
        (state.numberOfRetry = 0),
        void 0 !== state.lastConnectionId &&
          ((state.buffer.presence = state.me), tryFlushing()),
        (state.lastConnectionId = state.connection.id),
        state.root &&
          state.buffer.messages.push({
            type: Json.ClientMsgCode.FETCH_STORAGE,
          }),
        tryFlushing());
  }
  function heartbeat() {
    null != state.socket &&
      (clearTimeout(state.timeoutHandles.pongTimeout),
      (state.timeoutHandles.pongTimeout = effects.schedulePongTimeout()),
      state.socket.readyState === state.socket.OPEN &&
        state.socket.send("ping"));
  }
  function pongTimeout() {
    reconnect();
  }
  function reconnect() {
    state.socket &&
      (state.socket.removeEventListener("open", onOpen),
      state.socket.removeEventListener("message", onMessage),
      state.socket.removeEventListener("close", onClose),
      state.socket.removeEventListener("error", onError),
      state.socket.close(),
      (state.socket = null)),
      updateConnection({ state: "unavailable" }),
      clearTimeout(state.timeoutHandles.pongTimeout),
      state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush),
      clearTimeout(state.timeoutHandles.reconnect),
      clearInterval(state.intervalHandles.heartbeat),
      connect();
  }
  function applyAndSendOfflineOps(offlineOps) {
    if (0 !== offlineOps.size) {
      var messages = [],
        ops = Array.from(offlineOps.values()),
        result = apply(ops, !0);
      messages.push({ type: Json.ClientMsgCode.UPDATE_STORAGE, ops: ops }),
        notify(result.updates),
        effects.send(messages);
    }
  }
  function tryFlushing() {
    var storageOps = state.buffer.storageOperations;
    if (
      (storageOps.length > 0 &&
        storageOps.forEach(function (op) {
          state.offlineOperations.set(Json.nn(op.opId), op);
        }),
      null != state.socket && state.socket.readyState === state.socket.OPEN)
    ) {
      var now = Date.now();
      if (now - state.lastFlushTime > context.throttleDelay) {
        var _messages = (function (state) {
          var messages = [];
          state.buffer.presence &&
            messages.push({
              type: Json.ClientMsgCode.UPDATE_PRESENCE,
              data: state.buffer.presence,
            });
          for (
            var _step12,
              _iterator12 = Json._createForOfIteratorHelperLoose(
                state.buffer.messages
              );
            !(_step12 = _iterator12()).done;

          ) {
            var _event3 = _step12.value;
            messages.push(_event3);
          }
          state.buffer.storageOperations.length > 0 &&
            messages.push({
              type: Json.ClientMsgCode.UPDATE_STORAGE,
              ops: state.buffer.storageOperations,
            });
          return messages;
        })(state);
        if (0 === _messages.length) return;
        effects.send(_messages),
          (state.buffer = {
            messages: [],
            storageOperations: [],
            presence: null,
          }),
          (state.lastFlushTime = now);
      } else
        null != state.timeoutHandles.flush &&
          clearTimeout(state.timeoutHandles.flush),
          (state.timeoutHandles.flush = effects.delayFlush(
            context.throttleDelay - (now - state.lastFlushTime)
          ));
    } else state.buffer.storageOperations = [];
  }
  function getPresence() {
    return state.me;
  }
  function dispatch(ops) {
    var _state$buffer$storage;
    (_state$buffer$storage = state.buffer.storageOperations).push.apply(
      _state$buffer$storage,
      ops
    ),
      tryFlushing();
  }
  var _getInitialStatePromise = null,
    _getInitialStateResolver = null;
  return {
    onClose: onClose,
    onMessage: onMessage,
    authenticationSuccess: authenticationSuccess,
    heartbeat: heartbeat,
    onNavigatorOnline: function () {
      "unavailable" === state.connection.state && reconnect();
    },
    simulateSocketClose: function () {
      state.socket && (state.socket = null);
    },
    simulateSendCloseEvent: function (event) {
      onClose(event);
    },
    onVisibilityChange: function (visibilityState) {
      "visible" === visibilityState &&
        "open" === state.connection.state &&
        heartbeat();
    },
    getUndoStack: function () {
      return state.undoStack;
    },
    getItemsCount: function () {
      return state.items.size;
    },
    connect: connect,
    disconnect: function () {
      state.socket &&
        (state.socket.removeEventListener("open", onOpen),
        state.socket.removeEventListener("message", onMessage),
        state.socket.removeEventListener("close", onClose),
        state.socket.removeEventListener("error", onError),
        state.socket.close(),
        (state.socket = null)),
        updateConnection({ state: "closed" }),
        state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush),
        clearTimeout(state.timeoutHandles.reconnect),
        clearTimeout(state.timeoutHandles.pongTimeout),
        clearInterval(state.intervalHandles.heartbeat),
        (state.users = {}),
        notify({ others: [{ type: "reset" }] }),
        (function () {
          for (var _key6 in state.listeners) state.listeners[_key6] = [];
        })();
    },
    subscribe: function (first, second, options) {
      if (void 0 === second || "function" == typeof first) {
        if ("function" == typeof first) return genericSubscribe(first);
        throw new Error("Please specify a listener callback");
      }
      if (Json.isLiveNode(first)) {
        var _node = first;
        return null != options && options.isDeep
          ? ((node = _node),
            (callback = second),
            genericSubscribe(function (updates) {
              var relatedUpdates = updates.filter(function (update) {
                return Json.isSameNodeOrChildOf(update.node, node);
              });
              relatedUpdates.length > 0 && callback(relatedUpdates);
            }))
          : (function (node, callback) {
              return genericSubscribe(function (updates) {
                for (
                  var _step,
                    _iterator = Json._createForOfIteratorHelperLoose(updates);
                  !(_step = _iterator()).done;

                ) {
                  var update = _step.value;
                  update.node._id === node._id && callback(update.node);
                }
              });
            })(_node, second);
      }
      var node, callback;
      if (!Json.isRoomEventName(first))
        throw new Error('"' + first + '" is not a valid event name');
      var eventName = first,
        eventListener = second;
      return (
        state.listeners[eventName].push(eventListener),
        function () {
          var callbacks = state.listeners[eventName];
          Json.remove(callbacks, eventListener);
        }
      );
    },
    updatePresence: function (overrides, options) {
      var oldValues = {};
      for (var _key4 in (null == state.buffer.presence &&
        (state.buffer.presence = {}),
      overrides)) {
        var overrideValue = overrides[_key4];
        void 0 !== overrideValue &&
          ((state.buffer.presence[_key4] = overrideValue),
          (oldValues[_key4] = state.me[_key4]));
      }
      (state.me = Json._extends({}, state.me, overrides)),
        state.isBatching
          ? (null != options &&
              options.addToHistory &&
              state.batch.reverseOps.push({
                type: "presence",
                data: oldValues,
              }),
            (state.batch.updates.presence = !0))
          : (tryFlushing(),
            null != options &&
              options.addToHistory &&
              addToUndoStack([{ type: "presence", data: oldValues }]),
            notify({ presence: !0 }));
    },
    broadcastEvent: function (event, options) {
      void 0 === options && (options = { shouldQueueEventIfNotReady: !1 }),
        (null == state.socket && 0 == options.shouldQueueEventIfNotReady) ||
          (state.buffer.messages.push({
            type: Json.ClientMsgCode.BROADCAST_EVENT,
            event: event,
          }),
          tryFlushing());
    },
    batch: function (callback) {
      if (state.isBatching)
        throw new Error("batch should not be called during a batch");
      state.isBatching = !0;
      try {
        callback();
      } finally {
        (state.isBatching = !1),
          state.batch.reverseOps.length > 0 &&
            addToUndoStack(state.batch.reverseOps),
          state.batch.ops.length > 0 && (state.redoStack = []),
          state.batch.ops.length > 0 && dispatch(state.batch.ops),
          notify(state.batch.updates),
          (state.batch = {
            ops: [],
            reverseOps: [],
            updates: { others: [], storageUpdates: new Map(), presence: !1 },
          }),
          tryFlushing();
      }
    },
    undo: function () {
      if (state.isBatching)
        throw new Error("undo is not allowed during a batch");
      var historyItem = state.undoStack.pop();
      if (null != historyItem) {
        state.isHistoryPaused = !1;
        var result = apply(historyItem, !0);
        notify(result.updates), state.redoStack.push(result.reverse);
        for (
          var _step13,
            _iterator13 = Json._createForOfIteratorHelperLoose(historyItem);
          !(_step13 = _iterator13()).done;

        ) {
          var op = _step13.value;
          "presence" !== op.type && state.buffer.storageOperations.push(op);
        }
        tryFlushing();
      }
    },
    redo: function () {
      if (state.isBatching)
        throw new Error("redo is not allowed during a batch");
      var historyItem = state.redoStack.pop();
      if (null != historyItem) {
        state.isHistoryPaused = !1;
        var result = apply(historyItem, !0);
        notify(result.updates), state.undoStack.push(result.reverse);
        for (
          var _step14,
            _iterator14 = Json._createForOfIteratorHelperLoose(historyItem);
          !(_step14 = _iterator14()).done;

        ) {
          var op = _step14.value;
          "presence" !== op.type && state.buffer.storageOperations.push(op);
        }
        tryFlushing();
      }
    },
    pauseHistory: function () {
      (state.pausedHistory = []), (state.isHistoryPaused = !0);
    },
    resumeHistory: function () {
      (state.isHistoryPaused = !1),
        state.pausedHistory.length > 0 && addToUndoStack(state.pausedHistory),
        (state.pausedHistory = []);
    },
    getStorage: function () {
      return state.root
        ? new Promise(function (resolve) {
            return resolve({ root: state.root });
          })
        : (null == _getInitialStatePromise &&
            (state.buffer.messages.push({
              type: Json.ClientMsgCode.FETCH_STORAGE,
            }),
            tryFlushing(),
            (_getInitialStatePromise = new Promise(function (resolve) {
              return (_getInitialStateResolver = resolve);
            }))),
          _getInitialStatePromise.then(function () {
            return { root: Json.nn(state.root) };
          }));
    },
    selectors: {
      getConnectionState: function () {
        return state.connection.state;
      },
      getSelf: function () {
        return "open" === state.connection.state ||
          "connecting" === state.connection.state
          ? {
              connectionId: state.connection.id,
              id: state.connection.userId,
              info: state.connection.userInfo,
              presence: getPresence(),
            }
          : null;
      },
      getPresence: getPresence,
      getOthers: function () {
        return state.others;
      },
    },
  };
}
function createRoom(options, context) {
  var _options$initialPrese,
    _options$initialStora,
    initialPresence =
      null != (_options$initialPrese = options.initialPresence)
        ? _options$initialPrese
        : options.defaultPresence,
    initialStorage =
      null != (_options$initialStora = options.initialStorage)
        ? _options$initialStora
        : options.defaultStorageRoot,
    machine = makeStateMachine(
      (function (initialPresence, initialStorage) {
        return {
          connection: { state: "closed" },
          token: null,
          lastConnectionId: null,
          socket: null,
          listeners: {
            event: [],
            others: [],
            "my-presence": [],
            error: [],
            connection: [],
            storage: [],
          },
          numberOfRetry: 0,
          lastFlushTime: 0,
          timeoutHandles: { flush: null, reconnect: 0, pongTimeout: 0 },
          buffer: {
            presence: null == initialPresence ? {} : initialPresence,
            messages: [],
            storageOperations: [],
          },
          intervalHandles: { heartbeat: 0 },
          me: null == initialPresence ? {} : initialPresence,
          users: {},
          others: makeOthers({}),
          defaultStorageRoot: initialStorage,
          idFactory: null,
          clock: 0,
          opClock: 0,
          items: new Map(),
          root: void 0,
          undoStack: [],
          redoStack: [],
          isHistoryPaused: !1,
          pausedHistory: [],
          isBatching: !1,
          batch: {
            ops: [],
            updates: { storageUpdates: new Map(), presence: !1, others: [] },
            reverseOps: [],
          },
          offlineOperations: new Map(),
        };
      })(
        "function" == typeof initialPresence
          ? initialPresence(context.roomId)
          : initialPresence,
        "function" == typeof initialStorage
          ? initialStorage(context.roomId)
          : initialStorage
      ),
      context
    ),
    room = {
      id: context.roomId,
      getConnectionState: machine.selectors.getConnectionState,
      getSelf: machine.selectors.getSelf,
      subscribe: machine.subscribe,
      getPresence: machine.selectors.getPresence,
      updatePresence: machine.updatePresence,
      getOthers: machine.selectors.getOthers,
      broadcastEvent: machine.broadcastEvent,
      getStorage: machine.getStorage,
      batch: machine.batch,
      history: {
        undo: machine.undo,
        redo: machine.redo,
        pause: machine.pauseHistory,
        resume: machine.resumeHistory,
      },
      __INTERNAL_DO_NOT_USE: {
        simulateCloseWebsocket: machine.simulateSocketClose,
        simulateSendCloseEvent: machine.simulateSendCloseEvent,
      },
    };
  return {
    connect: machine.connect,
    disconnect: machine.disconnect,
    onNavigatorOnline: machine.onNavigatorOnline,
    onVisibilityChange: machine.onVisibilityChange,
    room: room,
  };
}
var LiveblocksError = (function (_Error) {
  function LiveblocksError(message, code) {
    return _Error.call(this, message) || this;
  }
  return Json._inheritsLoose(LiveblocksError, _Error), LiveblocksError;
})(Json._wrapNativeSuper(Error));
function fetchAuthEndpoint(fetch, endpoint, body) {
  return fetch(endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  })
    .then(function (res) {
      if (!res.ok)
        throw new AuthenticationError(
          "Expected a status 200 but got " +
            res.status +
            ' when doing a POST request on "' +
            endpoint +
            '"'
        );
      return res.json().catch(function (er) {
        throw new AuthenticationError(
          'Expected a JSON response when doing a POST request on "' +
            endpoint +
            '". ' +
            er
        );
      });
    })
    .then(function (data) {
      if (!Json.isPlainObject(data) || "string" != typeof data.token)
        throw new AuthenticationError(
          'Expected a JSON response of the form `{ token: "..." }` when doing a POST request on "' +
            endpoint +
            '", but got ' +
            JSON.stringify(data)
        );
      return { token: data.token };
    });
}
var AuthenticationError = (function (_Error2) {
  function AuthenticationError(message) {
    return _Error2.call(this, message) || this;
  }
  return Json._inheritsLoose(AuthenticationError, _Error2), AuthenticationError;
})(Json._wrapNativeSuper(Error));
function prepareAuthentication(clientOptions) {
  var publicApiKey = clientOptions.publicApiKey,
    authEndpoint = clientOptions.authEndpoint;
  if (void 0 !== authEndpoint && void 0 !== publicApiKey)
    throw new Error(
      "You cannot use both publicApiKey and authEndpoint. Please use either publicApiKey or authEndpoint, but not both. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
    );
  if ("string" == typeof publicApiKey) {
    if (publicApiKey.startsWith("sk_"))
      throw new Error(
        "Invalid publicApiKey. You are using the secret key which is not supported. Please use the public key instead. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    if (!publicApiKey.startsWith("pk_"))
      throw new Error(
        "Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    return {
      type: "public",
      publicApiKey: publicApiKey,
      url:
        clientOptions.publicAuthorizeEndpoint ||
        "https://liveblocks.io/api/public/authorize",
    };
  }
  if ("string" == typeof authEndpoint)
    return { type: "private", url: authEndpoint };
  if ("function" == typeof authEndpoint)
    return { type: "custom", callback: authEndpoint };
  if (void 0 !== authEndpoint)
    throw new Error(
      "authEndpoint must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint"
    );
  throw new Error(
    "Invalid Liveblocks client options. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
  );
}
(exports.LiveList = Json.LiveList),
  (exports.LiveMap = Json.LiveMap),
  (exports.LiveObject = Json.LiveObject),
  (exports.createClient = function (options) {
    var clientOptions = options,
      throttleDelay = (function (options) {
        if (void 0 === options.throttle) return 100;
        if (
          "number" != typeof options.throttle ||
          options.throttle < 80 ||
          options.throttle > 1e3
        )
          throw new Error("throttle should be a number between 80 and 1000.");
        return options.throttle;
      })(options),
      rooms = new Map();
    return (
      "undefined" != typeof window &&
        void 0 !== window.addEventListener &&
        window.addEventListener("online", function () {
          for (
            var _step, _iterator = Json._createForOfIteratorHelperLoose(rooms);
            !(_step = _iterator()).done;

          ) {
            _step.value[1].onNavigatorOnline();
          }
        }),
      "undefined" != typeof document &&
        document.addEventListener("visibilitychange", function () {
          for (
            var _step2,
              _iterator2 = Json._createForOfIteratorHelperLoose(rooms);
            !(_step2 = _iterator2()).done;

          ) {
            _step2.value[1].onVisibilityChange(document.visibilityState);
          }
        }),
      {
        getRoom: function (roomId) {
          var internalRoom = rooms.get(roomId);
          return internalRoom ? internalRoom.room : null;
        },
        enter: function (roomId, options) {
          void 0 === options && (options = {});
          var internalRoom = rooms.get(roomId);
          if (internalRoom) return internalRoom.room;
          if (
            (Json.errorIf(
              options.defaultPresence,
              "Argument `defaultPresence` will be removed in @liveblocks/client 0.18. Please use `initialPresence` instead. For more info, see https://bit.ly/3Niy5aP"
            ),
            Json.errorIf(
              options.defaultStorageRoot,
              "Argument `defaultStorageRoot` will be removed in @liveblocks/client 0.18. Please use `initialStorage` instead. For more info, see https://bit.ly/3Niy5aP"
            ),
            (internalRoom = createRoom(
              {
                initialPresence: options.initialPresence,
                initialStorage: options.initialStorage,
                defaultPresence: options.defaultPresence,
                defaultStorageRoot: options.defaultStorageRoot,
              },
              {
                roomId: roomId,
                throttleDelay: throttleDelay,
                polyfills: clientOptions.polyfills,
                WebSocketPolyfill: clientOptions.WebSocketPolyfill,
                fetchPolyfill: clientOptions.fetchPolyfill,
                liveblocksServer:
                  (null == clientOptions
                    ? void 0
                    : clientOptions.liveblocksServer) ||
                  "wss://liveblocks.net/v6",
                authentication: prepareAuthentication(clientOptions),
              }
            )),
            rooms.set(roomId, internalRoom),
            !options.DO_NOT_USE_withoutConnecting)
          ) {
            if ("undefined" == typeof atob) {
              var _clientOptions$polyfi;
              if (
                null ==
                (null == (_clientOptions$polyfi = clientOptions.polyfills)
                  ? void 0
                  : _clientOptions$polyfi.atob)
              )
                throw new Error(
                  "You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill"
                );
              global.atob = clientOptions.polyfills.atob;
            }
            internalRoom.connect();
          }
          return internalRoom.room;
        },
        leave: function (roomId) {
          var room = rooms.get(roomId);
          room && (room.disconnect(), rooms.delete(roomId));
        },
      }
    );
  });
