"use strict";
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    (descriptor.enumerable = descriptor.enumerable || !1),
      (descriptor.configurable = !0),
      "value" in descriptor && (descriptor.writable = !0),
      Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  return (
    protoProps && _defineProperties(Constructor.prototype, protoProps),
    staticProps && _defineProperties(Constructor, staticProps),
    Object.defineProperty(Constructor, "prototype", { writable: !1 }),
    Constructor
  );
}
function _extends() {
  return (
    (_extends =
      Object.assign ||
      function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) &&
              (target[key] = source[key]);
        }
        return target;
      }),
    _extends.apply(this, arguments)
  );
}
function _inheritsLoose(subClass, superClass) {
  (subClass.prototype = Object.create(superClass.prototype)),
    (subClass.prototype.constructor = subClass),
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  return (
    (_getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        }),
    _getPrototypeOf(o)
  );
}
function _setPrototypeOf(o, p) {
  return (
    (_setPrototypeOf =
      Object.setPrototypeOf ||
      function (o, p) {
        return (o.__proto__ = p), o;
      }),
    _setPrototypeOf(o, p)
  );
}
function _isNativeReflectConstruct() {
  if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
  if (Reflect.construct.sham) return !1;
  if ("function" == typeof Proxy) return !0;
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    );
  } catch (e) {
    return !1;
  }
}
function _construct(Parent, args, Class) {
  return (
    (_construct = _isNativeReflectConstruct()
      ? Reflect.construct
      : function (Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var instance = new (Function.bind.apply(Parent, a))();
          return Class && _setPrototypeOf(instance, Class.prototype), instance;
        }),
    _construct.apply(null, arguments)
  );
}
function _wrapNativeSuper(Class) {
  var _cache = "function" == typeof Map ? new Map() : void 0;
  return (
    (_wrapNativeSuper = function (Class) {
      if (
        null === Class ||
        ((fn = Class),
        -1 === Function.toString.call(fn).indexOf("[native code]"))
      )
        return Class;
      var fn;
      if ("function" != typeof Class)
        throw new TypeError(
          "Super expression must either be null or a function"
        );
      if (void 0 !== _cache) {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }
      return (
        (Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })),
        _setPrototypeOf(Wrapper, Class)
      );
    }),
    _wrapNativeSuper(Class)
  );
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (null == source) return {};
  var key,
    i,
    target = {},
    sourceKeys = Object.keys(source);
  for (i = 0; i < sourceKeys.length; i++)
    (key = sourceKeys[i]),
      excluded.indexOf(key) >= 0 || (target[key] = source[key]);
  return target;
}
function _assertThisInitialized(self) {
  if (void 0 === self)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return self;
}
function _arrayLikeToArray(arr, len) {
  (null == len || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it =
    ("undefined" != typeof Symbol && o[Symbol.iterator]) || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (
    Array.isArray(o) ||
    (it = (function (o, minLen) {
      if (o) {
        if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        return (
          "Object" === n && o.constructor && (n = o.constructor.name),
          "Map" === n || "Set" === n
            ? Array.from(o)
            : "Arguments" === n ||
              /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
            ? _arrayLikeToArray(o, minLen)
            : void 0
        );
      }
    })(o)) ||
    (allowArrayLike && o && "number" == typeof o.length)
  ) {
    it && (o = it);
    var i = 0;
    return function () {
      return i >= o.length ? { done: !0 } : { done: !1, value: o[i++] };
    };
  }
  throw new TypeError(
    "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
  );
}
var ClientMsgCode,
  OpCode,
  CrdtType,
  ServerMsgCode,
  WebsocketCloseCodes,
  OpSource,
  _emittedDeprecationWarnings = new Set();
function deprecate(message, key) {
  void 0 === key && (key = message),
    "production" !== process.env.NODE_ENV &&
      (_emittedDeprecationWarnings.has(key) ||
        (_emittedDeprecationWarnings.add(key),
        console.error("DEPRECATION WARNING: " + message)));
}
function throwUsageError(message) {
  if ("production" !== process.env.NODE_ENV) {
    var usageError = new Error(message);
    throw ((usageError.name = "Usage error"), usageError);
  }
}
function errorIf(condition, message) {
  "production" !== process.env.NODE_ENV &&
    condition &&
    throwUsageError(message);
}
function assertNever(_value, errmsg) {
  throw new Error(errmsg);
}
function nn(value, errmsg) {
  return (
    void 0 === errmsg && (errmsg = "Expected value to be non-nullable"),
    (function (condition, errmsg) {
      if ("production" !== process.env.NODE_ENV && !condition) {
        var err = new Error(errmsg);
        throw ((err.name = "Assertion failure"), err);
      }
    })(null != value, errmsg),
    value
  );
}
function isChildCrdt(crdt) {
  return void 0 !== crdt.parentId && void 0 !== crdt.parentKey;
}
function HasParent(node, key) {
  return Object.freeze({ type: "HasParent", node: node, key: key });
}
(exports.ClientMsgCode = void 0),
  ((ClientMsgCode = exports.ClientMsgCode || (exports.ClientMsgCode = {}))[
    (ClientMsgCode.UPDATE_PRESENCE = 100)
  ] = "UPDATE_PRESENCE"),
  (ClientMsgCode[(ClientMsgCode.BROADCAST_EVENT = 103)] = "BROADCAST_EVENT"),
  (ClientMsgCode[(ClientMsgCode.FETCH_STORAGE = 200)] = "FETCH_STORAGE"),
  (ClientMsgCode[(ClientMsgCode.UPDATE_STORAGE = 201)] = "UPDATE_STORAGE"),
  (exports.OpCode = void 0),
  ((OpCode = exports.OpCode || (exports.OpCode = {}))[(OpCode.INIT = 0)] =
    "INIT"),
  (OpCode[(OpCode.SET_PARENT_KEY = 1)] = "SET_PARENT_KEY"),
  (OpCode[(OpCode.CREATE_LIST = 2)] = "CREATE_LIST"),
  (OpCode[(OpCode.UPDATE_OBJECT = 3)] = "UPDATE_OBJECT"),
  (OpCode[(OpCode.CREATE_OBJECT = 4)] = "CREATE_OBJECT"),
  (OpCode[(OpCode.DELETE_CRDT = 5)] = "DELETE_CRDT"),
  (OpCode[(OpCode.DELETE_OBJECT_KEY = 6)] = "DELETE_OBJECT_KEY"),
  (OpCode[(OpCode.CREATE_MAP = 7)] = "CREATE_MAP"),
  (OpCode[(OpCode.CREATE_REGISTER = 8)] = "CREATE_REGISTER"),
  (exports.CrdtType = void 0),
  ((CrdtType = exports.CrdtType || (exports.CrdtType = {}))[
    (CrdtType.OBJECT = 0)
  ] = "OBJECT"),
  (CrdtType[(CrdtType.LIST = 1)] = "LIST"),
  (CrdtType[(CrdtType.MAP = 2)] = "MAP"),
  (CrdtType[(CrdtType.REGISTER = 3)] = "REGISTER"),
  (exports.ServerMsgCode = void 0),
  ((ServerMsgCode = exports.ServerMsgCode || (exports.ServerMsgCode = {}))[
    (ServerMsgCode.UPDATE_PRESENCE = 100)
  ] = "UPDATE_PRESENCE"),
  (ServerMsgCode[(ServerMsgCode.USER_JOINED = 101)] = "USER_JOINED"),
  (ServerMsgCode[(ServerMsgCode.USER_LEFT = 102)] = "USER_LEFT"),
  (ServerMsgCode[(ServerMsgCode.BROADCASTED_EVENT = 103)] =
    "BROADCASTED_EVENT"),
  (ServerMsgCode[(ServerMsgCode.ROOM_STATE = 104)] = "ROOM_STATE"),
  (ServerMsgCode[(ServerMsgCode.INITIAL_STORAGE_STATE = 200)] =
    "INITIAL_STORAGE_STATE"),
  (ServerMsgCode[(ServerMsgCode.UPDATE_STORAGE = 201)] = "UPDATE_STORAGE"),
  (exports.WebsocketCloseCodes = void 0),
  ((WebsocketCloseCodes =
    exports.WebsocketCloseCodes || (exports.WebsocketCloseCodes = {}))[
    (WebsocketCloseCodes.CLOSE_ABNORMAL = 1006)
  ] = "CLOSE_ABNORMAL"),
  (WebsocketCloseCodes[(WebsocketCloseCodes.INVALID_MESSAGE_FORMAT = 4e3)] =
    "INVALID_MESSAGE_FORMAT"),
  (WebsocketCloseCodes[(WebsocketCloseCodes.NOT_ALLOWED = 4001)] =
    "NOT_ALLOWED"),
  (WebsocketCloseCodes[
    (WebsocketCloseCodes.MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002)
  ] = "MAX_NUMBER_OF_MESSAGES_PER_SECONDS"),
  (WebsocketCloseCodes[
    (WebsocketCloseCodes.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003)
  ] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS"),
  (WebsocketCloseCodes[
    (WebsocketCloseCodes.MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004)
  ] = "MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP"),
  (WebsocketCloseCodes[
    (WebsocketCloseCodes.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005)
  ] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM"),
  (WebsocketCloseCodes[(WebsocketCloseCodes.CLOSE_WITHOUT_RETRY = 4999)] =
    "CLOSE_WITHOUT_RETRY"),
  (exports.OpSource = void 0),
  ((OpSource = exports.OpSource || (exports.OpSource = {}))[
    (OpSource.UNDOREDO_RECONNECT = 0)
  ] = "UNDOREDO_RECONNECT"),
  (OpSource[(OpSource.REMOTE = 1)] = "REMOTE"),
  (OpSource[(OpSource.ACK = 2)] = "ACK");
var NoParent = Object.freeze({ type: "NoParent" });
function Orphaned(oldKey) {
  return Object.freeze({ type: "Orphaned", oldKey: oldKey });
}
var _Symbol$iterator$1,
  _Symbol$iterator2,
  AbstractCrdt = (function () {
    function AbstractCrdt() {
      (this.__doc = void 0), (this.__id = void 0), (this._parent = NoParent);
    }
    var _proto = AbstractCrdt.prototype;
    return (
      (_proto._getParentKeyOrThrow = function () {
        switch (this.parent.type) {
          case "HasParent":
            return this.parent.key;
          case "NoParent":
            throw new Error("Parent key is missing");
          case "Orphaned":
            return this.parent.oldKey;
          default:
            return assertNever(this.parent, "Unknown state");
        }
      }),
      (_proto._apply = function (op, _isLocal) {
        return op.type === exports.OpCode.DELETE_CRDT &&
          "HasParent" === this.parent.type
          ? this.parent.node._detachChild(this)
          : { modified: !1 };
      }),
      (_proto._setParentLink = function (newParentNode, newParentKey) {
        switch (this.parent.type) {
          case "HasParent":
            if (this.parent.node !== newParentNode)
              throw new Error("Cannot attach parent if it already exist");
            return void (this._parent = HasParent(newParentNode, newParentKey));
          case "Orphaned":
          case "NoParent":
            return void (this._parent = HasParent(newParentNode, newParentKey));
          default:
            return assertNever(this.parent, "Unknown state");
        }
      }),
      (_proto._attach = function (id, doc) {
        if (this.__id || this.__doc)
          throw new Error("Cannot attach if CRDT is already attached");
        doc.addItem(id, this), (this.__id = id), (this.__doc = doc);
      }),
      (_proto._detach = function () {
        switch (
          (this.__doc && this.__id && this.__doc.deleteItem(this.__id),
          this.parent.type)
        ) {
          case "HasParent":
            this._parent = Orphaned(this.parent.key);
            break;
          case "NoParent":
            this._parent = NoParent;
            break;
          case "Orphaned":
            this._parent = Orphaned(this.parent.oldKey);
            break;
          default:
            assertNever(this.parent, "Unknown state");
        }
        this.__doc = void 0;
      }),
      _createClass(AbstractCrdt, [
        {
          key: "_doc",
          get: function () {
            return this.__doc;
          },
        },
        {
          key: "roomId",
          get: function () {
            return this.__doc ? this.__doc.roomId : null;
          },
        },
        {
          key: "_id",
          get: function () {
            return this.__id;
          },
        },
        {
          key: "parent",
          get: function () {
            return this._parent;
          },
        },
        {
          key: "_parentNode",
          get: function () {
            switch (this.parent.type) {
              case "HasParent":
                return this.parent.node;
              case "NoParent":
              case "Orphaned":
                return null;
              default:
                return assertNever(this.parent, "Unknown state");
            }
          },
        },
        {
          key: "_parentKey",
          get: function () {
            switch (this.parent.type) {
              case "HasParent":
                return this.parent.key;
              case "NoParent":
                return null;
              case "Orphaned":
                return this.parent.oldKey;
              default:
                return assertNever(this.parent, "Unknown state");
            }
          },
        },
      ]),
      AbstractCrdt
    );
  })(),
  LiveRegister = (function (_AbstractCrdt) {
    function LiveRegister(data) {
      var _this;
      return (
        ((_this = _AbstractCrdt.call(this) || this)._data = void 0),
        (_this._data = data),
        _this
      );
    }
    _inheritsLoose(LiveRegister, _AbstractCrdt),
      (LiveRegister._deserialize = function (_ref, _parentToChildren, doc) {
        var id = _ref[0],
          register = new LiveRegister(_ref[1].data);
        return register._attach(id, doc), register;
      });
    var _proto = LiveRegister.prototype;
    return (
      (_proto._serialize = function (parentId, parentKey, doc) {
        if (null == this._id || null == parentId || null == parentKey)
          throw new Error(
            "Cannot serialize register if parentId or parentKey is undefined"
          );
        return [
          {
            type: exports.OpCode.CREATE_REGISTER,
            opId: null == doc ? void 0 : doc.generateOpId(),
            id: this._id,
            parentId: parentId,
            parentKey: parentKey,
            data: this.data,
          },
        ];
      }),
      (_proto._toSerializedCrdt = function () {
        if ("HasParent" !== this.parent.type)
          throw new Error("Cannot serialize LiveRegister if parent is missing");
        return {
          type: exports.CrdtType.REGISTER,
          parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
          parentKey: this.parent.key,
          data: this.data,
        };
      }),
      (_proto._attachChild = function (_op) {
        throw new Error("Method not implemented.");
      }),
      (_proto._detachChild = function (_crdt) {
        throw new Error("Method not implemented.");
      }),
      (_proto._apply = function (op, isLocal) {
        return _AbstractCrdt.prototype._apply.call(this, op, isLocal);
      }),
      _createClass(LiveRegister, [
        {
          key: "data",
          get: function () {
            return this._data;
          },
        },
      ]),
      LiveRegister
    );
  })(AbstractCrdt);
function makePosition(before, after) {
  return null != before && null != after
    ? pos(makePositionFromCodes(posCodes(before), posCodes(after)))
    : null != before
    ? (function (before) {
        for (
          var result = [], beforeCodes = posCodes(before), i = 0;
          i < beforeCodes.length;
          i++
        ) {
          var code = beforeCodes[i];
          if (126 !== code) {
            result.push(code + 1);
            break;
          }
          if ((result.push(code), beforeCodes.length - 1 === i)) {
            result.push(33);
            break;
          }
        }
        return pos(result);
      })(before)
    : null != after
    ? (function (after) {
        for (
          var result = [], afterCodes = posCodes(after), i = 0;
          i < afterCodes.length;
          i++
        ) {
          var code = afterCodes[i];
          if (!(code <= 33)) {
            result.push(code - 1);
            break;
          }
          if ((result.push(32), afterCodes.length - 1 === i)) {
            result.push(126);
            break;
          }
        }
        return pos(result);
      })(after)
    : pos([33]);
}
function makePositionFromCodes(before, after) {
  for (var index = 0, result = []; ; ) {
    var beforeDigit = before[index] || 32,
      afterDigit = after[index] || 126;
    if (beforeDigit > afterDigit)
      throw new Error(
        "Impossible to generate position between " + before + " and " + after
      );
    if (beforeDigit !== afterDigit) {
      if (afterDigit - beforeDigit == 1) {
        result.push(beforeDigit),
          result.push.apply(
            result,
            makePositionFromCodes(before.slice(index + 1), [])
          );
        break;
      }
      var mid = (afterDigit + beforeDigit) >> 1;
      result.push(mid);
      break;
    }
    result.push(beforeDigit), index++;
  }
  return result;
}
function posCodes(str) {
  for (var codes = [], i = 0; i < str.length; i++)
    codes.push(str.charCodeAt(i));
  return codes;
}
function pos(codes) {
  return String.fromCharCode.apply(String, codes);
}
function comparePosition(posA, posB) {
  for (
    var aCodes = posCodes(posA),
      bCodes = posCodes(posB),
      maxLength = Math.max(aCodes.length, bCodes.length),
      i = 0;
    i < maxLength;
    i++
  ) {
    var a = null == aCodes[i] ? 32 : aCodes[i],
      b = null == bCodes[i] ? 32 : bCodes[i];
    if (a !== b) return a - b;
  }
  throw new Error(
    'Impossible to compare similar position "' + posA + '" and "' + posB + '"'
  );
}
function compareNodePosition(itemA, itemB) {
  return comparePosition(
    itemA._getParentKeyOrThrow(),
    itemB._getParentKeyOrThrow()
  );
}
_Symbol$iterator$1 = Symbol.iterator;
var LiveList = (function (_AbstractCrdt) {
  function LiveList(items) {
    var _this;
    void 0 === items && (items = []),
      ((_this = _AbstractCrdt.call(this) || this)._items = void 0),
      (_this._implicitlyDeletedItems = void 0),
      (_this._unacknowledgedSets = void 0),
      (_this._items = []),
      (_this._implicitlyDeletedItems = new Set()),
      (_this._unacknowledgedSets = new Map());
    for (var position = void 0, i = 0; i < items.length; i++) {
      var newPosition = makePosition(position),
        item = lsonToLiveNode(items[i]);
      item._setParentLink(_assertThisInitialized(_this), newPosition),
        _this._items.push(item),
        (position = newPosition);
    }
    return _this;
  }
  _inheritsLoose(LiveList, _AbstractCrdt),
    (LiveList._deserialize = function (_ref, parentToChildren, doc) {
      var id = _ref[0],
        list = new LiveList();
      list._attach(id, doc);
      var children = parentToChildren.get(id);
      if (null == children) return list;
      for (
        var _step, _iterator = _createForOfIteratorHelperLoose(children);
        !(_step = _iterator()).done;

      ) {
        var _step$value = _step.value,
          _id = _step$value[0],
          crdt = _step$value[1],
          child = deserialize([_id, crdt], parentToChildren, doc);
        child._setParentLink(list, crdt.parentKey), list._insertAndSort(child);
      }
      return list;
    });
  var _proto = LiveList.prototype;
  return (
    (_proto._serialize = function (parentId, parentKey, doc) {
      if (null == this._id)
        throw new Error("Cannot serialize item is not attached");
      var ops = [],
        op = {
          id: this._id,
          opId: null == doc ? void 0 : doc.generateOpId(),
          type: exports.OpCode.CREATE_LIST,
          parentId: parentId,
          parentKey: parentKey,
        };
      ops.push(op);
      for (
        var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._items);
        !(_step2 = _iterator2()).done;

      ) {
        var item = _step2.value;
        ops.push.apply(
          ops,
          item._serialize(this._id, item._getParentKeyOrThrow(), doc)
        );
      }
      return ops;
    }),
    (_proto._insertAndSort = function (item) {
      this._items.push(item), this._sortItems();
    }),
    (_proto._sortItems = function () {
      this._items.sort(compareNodePosition);
    }),
    (_proto._indexOfPosition = function (position) {
      return this._items.findIndex(function (item) {
        return item._getParentKeyOrThrow() === position;
      });
    }),
    (_proto._attach = function (id, doc) {
      _AbstractCrdt.prototype._attach.call(this, id, doc);
      for (
        var _step3, _iterator3 = _createForOfIteratorHelperLoose(this._items);
        !(_step3 = _iterator3()).done;

      ) {
        _step3.value._attach(doc.generateId(), doc);
      }
    }),
    (_proto._detach = function () {
      _AbstractCrdt.prototype._detach.call(this);
      for (
        var _step4, _iterator4 = _createForOfIteratorHelperLoose(this._items);
        !(_step4 = _iterator4()).done;

      ) {
        _step4.value._detach();
      }
    }),
    (_proto._applySetRemote = function (op) {
      if (null == this._doc)
        throw new Error("Can't attach child if doc is not present");
      var id = op.id,
        key = op.parentKey,
        child = creationOpToLiveNode(op);
      child._attach(id, this._doc), child._setParentLink(this, key);
      var deletedId = op.deletedId,
        indexOfItemWithSamePosition = this._indexOfPosition(key);
      if (-1 !== indexOfItemWithSamePosition) {
        var itemWithSamePosition = this._items[indexOfItemWithSamePosition];
        if (itemWithSamePosition._id === deletedId)
          return (
            itemWithSamePosition._detach(),
            (this._items[indexOfItemWithSamePosition] = child),
            {
              modified: makeUpdate(this, [
                setDelta(indexOfItemWithSamePosition, child),
              ]),
              reverse: [],
            }
          );
        this._implicitlyDeletedItems.add(itemWithSamePosition),
          (this._items[indexOfItemWithSamePosition] = child);
        var delta = [setDelta(indexOfItemWithSamePosition, child)],
          _deleteDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
        return (
          _deleteDelta && delta.push(_deleteDelta),
          { modified: makeUpdate(this, delta), reverse: [] }
        );
      }
      var updates = [],
        _deleteDelta2 = this._detachItemAssociatedToSetOperation(op.deletedId);
      return (
        _deleteDelta2 && updates.push(_deleteDelta2),
        this._insertAndSort(child),
        updates.push(insertDelta(this._indexOfPosition(key), child)),
        { reverse: [], modified: makeUpdate(this, updates) }
      );
    }),
    (_proto._applySetAck = function (op) {
      if (null == this._doc)
        throw new Error("Can't attach child if doc is not present");
      var delta = [],
        deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
      deletedDelta && delta.push(deletedDelta);
      var unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);
      if (null != unacknowledgedOpId) {
        if (unacknowledgedOpId !== op.opId)
          return 0 === delta.length
            ? { modified: !1 }
            : { modified: makeUpdate(this, delta), reverse: [] };
        this._unacknowledgedSets.delete(op.parentKey);
      }
      var indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey),
        existingItem = this._items.find(function (item) {
          return item._id === op.id;
        });
      if (null != existingItem) {
        if (existingItem._parentKey === op.parentKey)
          return {
            modified: delta.length > 0 && makeUpdate(this, delta),
            reverse: [],
          };
        -1 !== indexOfItemWithSamePosition &&
          (this._implicitlyDeletedItems.add(
            this._items[indexOfItemWithSamePosition]
          ),
          this._items.splice(indexOfItemWithSamePosition, 1),
          delta.push(deleteDelta(indexOfItemWithSamePosition)));
        var previousIndex = this._items.indexOf(existingItem);
        existingItem._setParentLink(this, op.parentKey), this._sortItems();
        var newIndex = this._items.indexOf(existingItem);
        return (
          newIndex !== previousIndex &&
            delta.push(moveDelta(previousIndex, newIndex, existingItem)),
          { modified: delta.length > 0 && makeUpdate(this, delta), reverse: [] }
        );
      }
      var orphan = this._doc.getItem(op.id);
      if (orphan && this._implicitlyDeletedItems.has(orphan)) {
        orphan._setParentLink(this, op.parentKey),
          this._implicitlyDeletedItems.delete(orphan),
          this._insertAndSort(orphan);
        var recreatedItemIndex = this._items.indexOf(orphan);
        return {
          modified: makeUpdate(
            this,
            [
              -1 === indexOfItemWithSamePosition
                ? insertDelta(recreatedItemIndex, orphan)
                : setDelta(recreatedItemIndex, orphan),
            ].concat(delta)
          ),
          reverse: [],
        };
      }
      -1 !== indexOfItemWithSamePosition &&
        this._items.splice(indexOfItemWithSamePosition, 1);
      var _this$_createAttachIt = this._createAttachItemAndSort(
          op,
          op.parentKey
        ),
        newItem = _this$_createAttachIt.newItem,
        _newIndex = _this$_createAttachIt.newIndex;
      return {
        modified: makeUpdate(
          this,
          [
            -1 === indexOfItemWithSamePosition
              ? insertDelta(_newIndex, newItem)
              : setDelta(_newIndex, newItem),
          ].concat(delta)
        ),
        reverse: [],
      };
    }),
    (_proto._detachItemAssociatedToSetOperation = function (deletedId) {
      if (null == deletedId || null == this._doc) return null;
      var deletedItem = this._doc.getItem(deletedId);
      if (null == deletedItem) return null;
      var result = this._detachChild(deletedItem);
      return !1 === result.modified ? null : result.modified.updates[0];
    }),
    (_proto._applyRemoteInsert = function (op) {
      if (null == this._doc)
        throw new Error("Can't attach child if doc is not present");
      var key = op.parentKey,
        existingItemIndex = this._indexOfPosition(key);
      -1 !== existingItemIndex &&
        this._shiftItemPosition(existingItemIndex, key);
      var _this$_createAttachIt2 = this._createAttachItemAndSort(op, key),
        newItem = _this$_createAttachIt2.newItem;
      return {
        modified: makeUpdate(this, [
          insertDelta(_this$_createAttachIt2.newIndex, newItem),
        ]),
        reverse: [],
      };
    }),
    (_proto._applyInsertAck = function (op) {
      var existingItem = this._items.find(function (item) {
          return item._id === op.id;
        }),
        key = op.parentKey,
        itemIndexAtPosition = this._indexOfPosition(key);
      if (existingItem) {
        if (existingItem._parentKey === key) return { modified: !1 };
        var oldPositionIndex = this._items.indexOf(existingItem);
        -1 !== itemIndexAtPosition &&
          this._shiftItemPosition(itemIndexAtPosition, key),
          existingItem._setParentLink(this, key),
          this._sortItems();
        var newIndex = this._indexOfPosition(key);
        return newIndex === oldPositionIndex
          ? { modified: !1 }
          : {
              modified: makeUpdate(this, [
                moveDelta(oldPositionIndex, newIndex, existingItem),
              ]),
              reverse: [],
            };
      }
      var orphan = nn(this._doc).getItem(op.id);
      if (orphan && this._implicitlyDeletedItems.has(orphan))
        return (
          orphan._setParentLink(this, key),
          this._implicitlyDeletedItems.delete(orphan),
          this._insertAndSort(orphan),
          {
            modified: makeUpdate(this, [
              insertDelta(this._indexOfPosition(key), orphan),
            ]),
            reverse: [],
          }
        );
      -1 !== itemIndexAtPosition &&
        this._shiftItemPosition(itemIndexAtPosition, key);
      var _this$_createAttachIt3 = this._createAttachItemAndSort(op, key),
        newItem = _this$_createAttachIt3.newItem;
      return {
        modified: makeUpdate(this, [
          insertDelta(_this$_createAttachIt3.newIndex, newItem),
        ]),
        reverse: [],
      };
    }),
    (_proto._applyInsertUndoRedo = function (op) {
      var _this$_doc,
        id = op.id,
        key = op.parentKey,
        child = creationOpToLiveNode(op);
      if (
        void 0 !==
        (null == (_this$_doc = this._doc) ? void 0 : _this$_doc.getItem(id))
      )
        return { modified: !1 };
      child._attach(id, nn(this._doc)), child._setParentLink(this, key);
      var existingItemIndex = this._indexOfPosition(key),
        newKey = key;
      -1 !== existingItemIndex &&
        ((newKey = makePosition(
          this._items[existingItemIndex]
            ? this._items[existingItemIndex]._getParentKeyOrThrow()
            : void 0,
          this._items[existingItemIndex + 1]
            ? this._items[existingItemIndex + 1]._getParentKeyOrThrow()
            : void 0
        )),
        child._setParentLink(this, newKey));
      return (
        this._insertAndSort(child),
        {
          modified: makeUpdate(this, [
            insertDelta(this._indexOfPosition(newKey), child),
          ]),
          reverse: [{ type: exports.OpCode.DELETE_CRDT, id: id }],
        }
      );
    }),
    (_proto._applySetUndoRedo = function (op) {
      var _this$_doc2,
        id = op.id,
        key = op.parentKey,
        child = creationOpToLiveNode(op);
      if (
        void 0 !==
        (null == (_this$_doc2 = this._doc) ? void 0 : _this$_doc2.getItem(id))
      )
        return { modified: !1 };
      this._unacknowledgedSets.set(key, nn(op.opId));
      var indexOfItemWithSameKey = this._indexOfPosition(key);
      child._attach(id, nn(this._doc)), child._setParentLink(this, key);
      var newKey = key;
      if (-1 !== indexOfItemWithSameKey) {
        var existingItem = this._items[indexOfItemWithSameKey];
        existingItem._detach(), (this._items[indexOfItemWithSameKey] = child);
        var reverse = existingItem._serialize(nn(this._id), key, this._doc);
        addIntentAndDeletedIdToOperation(reverse, op.id);
        var delta = [setDelta(indexOfItemWithSameKey, child)],
          deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
        return (
          deletedDelta && delta.push(deletedDelta),
          { modified: makeUpdate(this, delta), reverse: reverse }
        );
      }
      this._insertAndSort(child),
        this._detachItemAssociatedToSetOperation(op.deletedId);
      var newIndex = this._indexOfPosition(newKey);
      return {
        reverse: [{ type: exports.OpCode.DELETE_CRDT, id: id }],
        modified: makeUpdate(this, [insertDelta(newIndex, child)]),
      };
    }),
    (_proto._attachChild = function (op, source) {
      if (null == this._doc)
        throw new Error("Can't attach child if doc is not present");
      if ("set" === op.intent) {
        if (source === exports.OpSource.REMOTE) return this._applySetRemote(op);
        if (source === exports.OpSource.UNDOREDO_RECONNECT)
          return this._applySetUndoRedo(op);
        if (source === exports.OpSource.ACK) return this._applySetAck(op);
      }
      return source === exports.OpSource.REMOTE
        ? this._applyRemoteInsert(op)
        : source === exports.OpSource.ACK
        ? this._applyInsertAck(op)
        : this._applyInsertUndoRedo(op);
    }),
    (_proto._detachChild = function (child) {
      if (child) {
        var parentKey = nn(child._parentKey),
          reverse = child._serialize(nn(this._id), parentKey, this._doc),
          indexToDelete = this._items.indexOf(child);
        return -1 === indexToDelete
          ? { modified: !1 }
          : (this._items.splice(indexToDelete, 1),
            child._detach(),
            {
              modified: makeUpdate(this, [deleteDelta(indexToDelete)]),
              reverse: reverse,
            });
      }
      return { modified: !1 };
    }),
    (_proto._applySetChildKeyRemote = function (newKey, child) {
      if (this._implicitlyDeletedItems.has(child))
        return (
          this._implicitlyDeletedItems.delete(child),
          child._setParentLink(this, newKey),
          this._insertAndSort(child),
          {
            modified: makeUpdate(this, [
              insertDelta(this._items.indexOf(child), child),
            ]),
            reverse: [],
          }
        );
      if (newKey === child._parentKey) return { modified: !1 };
      var _this$_items,
        existingItemIndex = this._indexOfPosition(newKey);
      if (-1 === existingItemIndex) {
        var previousIndex = this._items.indexOf(child);
        child._setParentLink(this, newKey), this._sortItems();
        var _newIndex4 = this._items.indexOf(child);
        return _newIndex4 === previousIndex
          ? { modified: !1 }
          : {
              modified: makeUpdate(this, [
                moveDelta(previousIndex, _newIndex4, child),
              ]),
              reverse: [],
            };
      }
      this._items[existingItemIndex]._setParentLink(
        this,
        makePosition(
          newKey,
          null == (_this$_items = this._items[existingItemIndex + 1])
            ? void 0
            : _this$_items._getParentKeyOrThrow()
        )
      );
      var _previousIndex = this._items.indexOf(child);
      child._setParentLink(this, newKey), this._sortItems();
      var _newIndex5 = this._items.indexOf(child);
      return _newIndex5 === _previousIndex
        ? { modified: !1 }
        : {
            modified: makeUpdate(this, [
              moveDelta(_previousIndex, _newIndex5, child),
            ]),
            reverse: [],
          };
    }),
    (_proto._applySetChildKeyAck = function (newKey, child) {
      var previousKey = nn(child._parentKey);
      if (this._implicitlyDeletedItems.has(child)) {
        var _this$_items2,
          existingItemIndex = this._indexOfPosition(newKey);
        if (
          (this._implicitlyDeletedItems.delete(child), -1 !== existingItemIndex)
        )
          this._items[existingItemIndex]._setParentLink(
            this,
            makePosition(
              newKey,
              null == (_this$_items2 = this._items[existingItemIndex + 1])
                ? void 0
                : _this$_items2._getParentKeyOrThrow()
            )
          );
        return (
          child._setParentLink(this, newKey),
          this._insertAndSort(child),
          { modified: !1 }
        );
      }
      if (newKey === previousKey) return { modified: !1 };
      var _this$_items3,
        previousIndex = this._items.indexOf(child),
        _existingItemIndex = this._indexOfPosition(newKey);
      -1 !== _existingItemIndex &&
        this._items[_existingItemIndex]._setParentLink(
          this,
          makePosition(
            newKey,
            null == (_this$_items3 = this._items[_existingItemIndex + 1])
              ? void 0
              : _this$_items3._getParentKeyOrThrow()
          )
        ),
        child._setParentLink(this, newKey),
        this._sortItems();
      var newIndex = this._items.indexOf(child);
      return previousIndex === newIndex
        ? { modified: !1 }
        : {
            modified: makeUpdate(this, [
              moveDelta(previousIndex, newIndex, child),
            ]),
            reverse: [],
          };
    }),
    (_proto._applySetChildKeyUndoRedo = function (newKey, child) {
      var _this$_items4,
        previousKey = nn(child._parentKey),
        previousIndex = this._items.indexOf(child),
        existingItemIndex = this._indexOfPosition(newKey);
      -1 !== existingItemIndex &&
        this._items[existingItemIndex]._setParentLink(
          this,
          makePosition(
            newKey,
            null == (_this$_items4 = this._items[existingItemIndex + 1])
              ? void 0
              : _this$_items4._getParentKeyOrThrow()
          )
        );
      child._setParentLink(this, newKey), this._sortItems();
      var newIndex = this._items.indexOf(child);
      return previousIndex === newIndex
        ? { modified: !1 }
        : {
            modified: makeUpdate(this, [
              moveDelta(previousIndex, newIndex, child),
            ]),
            reverse: [
              {
                type: exports.OpCode.SET_PARENT_KEY,
                id: nn(child._id),
                parentKey: previousKey,
              },
            ],
          };
    }),
    (_proto._setChildKey = function (newKey, child, source) {
      return source === exports.OpSource.REMOTE
        ? this._applySetChildKeyRemote(newKey, child)
        : source === exports.OpSource.ACK
        ? this._applySetChildKeyAck(newKey, child)
        : this._applySetChildKeyUndoRedo(newKey, child);
    }),
    (_proto._apply = function (op, isLocal) {
      return _AbstractCrdt.prototype._apply.call(this, op, isLocal);
    }),
    (_proto._toSerializedCrdt = function () {
      if ("HasParent" !== this.parent.type)
        throw new Error("Cannot serialize LiveList if parent is missing");
      return {
        type: exports.CrdtType.LIST,
        parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
        parentKey: this.parent.key,
      };
    }),
    (_proto.push = function (element) {
      return this.insert(element, this.length);
    }),
    (_proto.insert = function (element, index) {
      if (index < 0 || index > this._items.length)
        throw new Error(
          'Cannot insert list item at index "' +
            index +
            '". index should be between 0 and ' +
            this._items.length
        );
      var position = makePosition(
          this._items[index - 1]
            ? this._items[index - 1]._getParentKeyOrThrow()
            : void 0,
          this._items[index]
            ? this._items[index]._getParentKeyOrThrow()
            : void 0
        ),
        value = lsonToLiveNode(element);
      if (
        (value._setParentLink(this, position),
        this._insertAndSort(value),
        this._doc && this._id)
      ) {
        var id = this._doc.generateId();
        value._attach(id, this._doc),
          this._doc.dispatch(
            value._serialize(this._id, position, this._doc),
            [{ type: exports.OpCode.DELETE_CRDT, id: id }],
            new Map([[this._id, makeUpdate(this, [insertDelta(index, value)])]])
          );
      }
    }),
    (_proto.move = function (index, targetIndex) {
      if (targetIndex < 0) throw new Error("targetIndex cannot be less than 0");
      if (targetIndex >= this._items.length)
        throw new Error(
          "targetIndex cannot be greater or equal than the list length"
        );
      if (index < 0) throw new Error("index cannot be less than 0");
      if (index >= this._items.length)
        throw new Error(
          "index cannot be greater or equal than the list length"
        );
      var beforePosition = null,
        afterPosition = null;
      index < targetIndex
        ? ((afterPosition =
            targetIndex === this._items.length - 1
              ? void 0
              : this._items[targetIndex + 1]._getParentKeyOrThrow()),
          (beforePosition = this._items[targetIndex]._getParentKeyOrThrow()))
        : ((afterPosition = this._items[targetIndex]._getParentKeyOrThrow()),
          (beforePosition =
            0 === targetIndex
              ? void 0
              : this._items[targetIndex - 1]._getParentKeyOrThrow()));
      var position = makePosition(beforePosition, afterPosition),
        item = this._items[index],
        previousPosition = item._getParentKeyOrThrow();
      if (
        (item._setParentLink(this, position),
        this._sortItems(),
        this._doc && this._id)
      ) {
        var storageUpdates = new Map([
          [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])],
        ]);
        this._doc.dispatch(
          [
            {
              type: exports.OpCode.SET_PARENT_KEY,
              id: nn(item._id),
              opId: this._doc.generateOpId(),
              parentKey: position,
            },
          ],
          [
            {
              type: exports.OpCode.SET_PARENT_KEY,
              id: nn(item._id),
              parentKey: previousPosition,
            },
          ],
          storageUpdates
        );
      }
    }),
    (_proto.delete = function (index) {
      if (index < 0 || index >= this._items.length)
        throw new Error(
          'Cannot delete list item at index "' +
            index +
            '". index should be between 0 and ' +
            (this._items.length - 1)
        );
      var item = this._items[index];
      if ((item._detach(), this._items.splice(index, 1), this._doc)) {
        var childRecordId = item._id;
        if (childRecordId) {
          var storageUpdates = new Map();
          storageUpdates.set(
            nn(this._id),
            makeUpdate(this, [deleteDelta(index)])
          ),
            this._doc.dispatch(
              [
                {
                  id: childRecordId,
                  opId: this._doc.generateOpId(),
                  type: exports.OpCode.DELETE_CRDT,
                },
              ],
              item._serialize(nn(this._id), item._getParentKeyOrThrow()),
              storageUpdates
            );
        }
      }
    }),
    (_proto.clear = function () {
      if (this._doc) {
        for (
          var _step5,
            ops = [],
            reverseOps = [],
            updateDelta = [],
            _iterator5 = _createForOfIteratorHelperLoose(this._items);
          !(_step5 = _iterator5()).done;

        ) {
          var item = _step5.value;
          item._detach();
          var childId = item._id;
          childId &&
            (ops.push({
              type: exports.OpCode.DELETE_CRDT,
              id: childId,
              opId: this._doc.generateOpId(),
            }),
            reverseOps.push.apply(
              reverseOps,
              item._serialize(nn(this._id), item._getParentKeyOrThrow())
            ),
            updateDelta.push(deleteDelta(0)));
        }
        this._items = [];
        var storageUpdates = new Map();
        storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta)),
          this._doc.dispatch(ops, reverseOps, storageUpdates);
      } else {
        for (
          var _step6, _iterator6 = _createForOfIteratorHelperLoose(this._items);
          !(_step6 = _iterator6()).done;

        ) {
          _step6.value._detach();
        }
        this._items = [];
      }
    }),
    (_proto.set = function (index, item) {
      if (index < 0 || index >= this._items.length)
        throw new Error(
          'Cannot set list item at index "' +
            index +
            '". index should be between 0 and ' +
            (this._items.length - 1)
        );
      var existingItem = this._items[index],
        position = existingItem._getParentKeyOrThrow(),
        existingId = existingItem._id;
      existingItem._detach();
      var value = lsonToLiveNode(item);
      if (
        (value._setParentLink(this, position),
        (this._items[index] = value),
        this._doc && this._id)
      ) {
        var id = this._doc.generateId();
        value._attach(id, this._doc);
        var storageUpdates = new Map();
        storageUpdates.set(
          this._id,
          makeUpdate(this, [setDelta(index, value)])
        );
        var ops = value._serialize(this._id, position, this._doc);
        addIntentAndDeletedIdToOperation(ops, existingId),
          this._unacknowledgedSets.set(position, nn(ops[0].opId));
        var reverseOps = existingItem._serialize(this._id, position, void 0);
        addIntentAndDeletedIdToOperation(reverseOps, id),
          this._doc.dispatch(ops, reverseOps, storageUpdates);
      }
    }),
    (_proto.toArray = function () {
      return this._items.map(function (entry) {
        return liveNodeToLson(entry);
      });
    }),
    (_proto.every = function (predicate) {
      return this.toArray().every(predicate);
    }),
    (_proto.filter = function (predicate) {
      return this.toArray().filter(predicate);
    }),
    (_proto.find = function (predicate) {
      return this.toArray().find(predicate);
    }),
    (_proto.findIndex = function (predicate) {
      return this.toArray().findIndex(predicate);
    }),
    (_proto.forEach = function (callbackfn) {
      return this.toArray().forEach(callbackfn);
    }),
    (_proto.get = function (index) {
      if (!(index < 0 || index >= this._items.length))
        return liveNodeToLson(this._items[index]);
    }),
    (_proto.indexOf = function (searchElement, fromIndex) {
      return this.toArray().indexOf(searchElement, fromIndex);
    }),
    (_proto.lastIndexOf = function (searchElement, fromIndex) {
      return this.toArray().lastIndexOf(searchElement, fromIndex);
    }),
    (_proto.map = function (callback) {
      return this._items.map(function (entry, i) {
        return callback(liveNodeToLson(entry), i);
      });
    }),
    (_proto.some = function (predicate) {
      return this.toArray().some(predicate);
    }),
    (_proto[_Symbol$iterator$1] = function () {
      return new LiveListIterator(this._items);
    }),
    (_proto._createAttachItemAndSort = function (op, key) {
      var newItem = creationOpToLiveNode(op);
      return (
        newItem._attach(op.id, nn(this._doc)),
        newItem._setParentLink(this, key),
        this._insertAndSort(newItem),
        { newItem: newItem, newIndex: this._indexOfPosition(key) }
      );
    }),
    (_proto._shiftItemPosition = function (index, key) {
      var _this$_items5,
        shiftedPosition = makePosition(
          key,
          this._items.length > index + 1
            ? null == (_this$_items5 = this._items[index + 1])
              ? void 0
              : _this$_items5._getParentKeyOrThrow()
            : void 0
        );
      this._items[index]._setParentLink(this, shiftedPosition);
    }),
    _createClass(LiveList, [
      {
        key: "length",
        get: function () {
          return this._items.length;
        },
      },
    ]),
    LiveList
  );
})(AbstractCrdt);
_Symbol$iterator2 = Symbol.iterator;
var _Symbol$iterator,
  LiveListIterator = (function () {
    function LiveListIterator(items) {
      (this._innerIterator = void 0),
        (this._innerIterator = items[Symbol.iterator]());
    }
    var _proto2 = LiveListIterator.prototype;
    return (
      (_proto2[_Symbol$iterator2] = function () {
        return this;
      }),
      (_proto2.next = function () {
        var result = this._innerIterator.next();
        return result.done
          ? { done: !0, value: void 0 }
          : { value: liveNodeToLson(result.value) };
      }),
      LiveListIterator
    );
  })();
function makeUpdate(liveList, deltaUpdates) {
  return { node: liveList, type: "LiveList", updates: deltaUpdates };
}
function setDelta(index, item) {
  return {
    index: index,
    type: "set",
    item: item instanceof LiveRegister ? item.data : item,
  };
}
function deleteDelta(index) {
  return { index: index, type: "delete" };
}
function insertDelta(index, item) {
  return {
    index: index,
    type: "insert",
    item: item instanceof LiveRegister ? item.data : item,
  };
}
function moveDelta(previousIndex, index, item) {
  return {
    index: index,
    type: "move",
    previousIndex: previousIndex,
    item: item instanceof LiveRegister ? item.data : item,
  };
}
function addIntentAndDeletedIdToOperation(ops, deletedId) {
  if (0 === ops.length)
    throw new Error(
      "Internal error. Serialized LiveStructure should have at least 1 operation"
    );
  var firstOp = ops[0];
  (firstOp.intent = "set"), (firstOp.deletedId = deletedId);
}
_Symbol$iterator = Symbol.iterator;
var LiveMap = (function (_AbstractCrdt) {
    function LiveMap(entries) {
      var _this;
      if (
        (((_this = _AbstractCrdt.call(this) || this)._map = void 0),
        (_this.unacknowledgedSet = void 0),
        errorIf(
          null === entries,
          "Support for calling `new LiveMap(null)` will be removed in @liveblocks/client 0.18. Please call as `new LiveMap()`, or `new LiveMap([])`."
        ),
        (_this.unacknowledgedSet = new Map()),
        entries)
      ) {
        for (
          var _step,
            mappedEntries = [],
            _iterator = _createForOfIteratorHelperLoose(entries);
          !(_step = _iterator()).done;

        ) {
          var entry = _step.value,
            _value = lsonToLiveNode(entry[1]);
          _value._setParentLink(_assertThisInitialized(_this), entry[0]),
            mappedEntries.push([entry[0], _value]);
        }
        _this._map = new Map(mappedEntries);
      } else _this._map = new Map();
      return _this;
    }
    _inheritsLoose(LiveMap, _AbstractCrdt);
    var _proto = LiveMap.prototype;
    return (
      (_proto._serialize = function (parentId, parentKey, doc) {
        if (null == this._id)
          throw new Error("Cannot serialize item is not attached");
        var ops = [],
          op = {
            id: this._id,
            opId: null == doc ? void 0 : doc.generateOpId(),
            type: exports.OpCode.CREATE_MAP,
            parentId: parentId,
            parentKey: parentKey,
          };
        ops.push(op);
        for (
          var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._map);
          !(_step2 = _iterator2()).done;

        ) {
          var _step2$value = _step2.value,
            _key2 = _step2$value[0],
            _value2 = _step2$value[1];
          ops.push.apply(ops, _value2._serialize(this._id, _key2, doc));
        }
        return ops;
      }),
      (LiveMap._deserialize = function (_ref, parentToChildren, doc) {
        var id = _ref[0];
        _ref[1];
        var map = new LiveMap();
        map._attach(id, doc);
        var children = parentToChildren.get(id);
        if (null == children) return map;
        for (
          var _step3, _iterator3 = _createForOfIteratorHelperLoose(children);
          !(_step3 = _iterator3()).done;

        ) {
          var _step3$value = _step3.value,
            _id = _step3$value[0],
            crdt = _step3$value[1],
            child = deserialize([_id, crdt], parentToChildren, doc);
          child._setParentLink(map, crdt.parentKey),
            map._map.set(crdt.parentKey, child);
        }
        return map;
      }),
      (_proto._attach = function (id, doc) {
        _AbstractCrdt.prototype._attach.call(this, id, doc);
        for (
          var _step4, _iterator4 = _createForOfIteratorHelperLoose(this._map);
          !(_step4 = _iterator4()).done;

        ) {
          var _step4$value = _step4.value;
          _step4$value[0];
          var _value3 = _step4$value[1];
          isLiveNode(_value3) && _value3._attach(doc.generateId(), doc);
        }
      }),
      (_proto._attachChild = function (op, source) {
        var _updates;
        if (null == this._doc)
          throw new Error("Can't attach child if doc is not present");
        var id = op.id,
          parentKey = op.parentKey,
          opId = op.opId,
          key = parentKey,
          child = creationOpToLiveNode(op);
        if (void 0 !== this._doc.getItem(id)) return { modified: !1 };
        if (source === exports.OpSource.ACK) {
          var lastUpdateOpId = this.unacknowledgedSet.get(key);
          if (lastUpdateOpId === opId)
            return this.unacknowledgedSet.delete(key), { modified: !1 };
          if (null != lastUpdateOpId) return { modified: !1 };
        } else
          source === exports.OpSource.REMOTE &&
            this.unacknowledgedSet.delete(key);
        var reverse,
          previousValue = this._map.get(key);
        if (previousValue) {
          var thisId = nn(this._id);
          (reverse = previousValue._serialize(thisId, key)),
            previousValue._detach();
        } else reverse = [{ type: exports.OpCode.DELETE_CRDT, id: id }];
        return (
          child._setParentLink(this, key),
          child._attach(id, this._doc),
          this._map.set(key, child),
          {
            modified: {
              node: this,
              type: "LiveMap",
              updates:
                ((_updates = {}),
                (_updates[key] = { type: "update" }),
                _updates),
            },
            reverse: reverse,
          }
        );
      }),
      (_proto._detach = function () {
        _AbstractCrdt.prototype._detach.call(this);
        for (
          var _step5,
            _iterator5 = _createForOfIteratorHelperLoose(this._map.values());
          !(_step5 = _iterator5()).done;

        ) {
          _step5.value._detach();
        }
      }),
      (_proto._detachChild = function (child) {
        for (
          var _updates2,
            _step6,
            id = nn(this._id),
            parentKey = nn(child._parentKey),
            reverse = child._serialize(id, parentKey, this._doc),
            _iterator6 = _createForOfIteratorHelperLoose(this._map);
          !(_step6 = _iterator6()).done;

        ) {
          var _step6$value = _step6.value,
            _key3 = _step6$value[0];
          _step6$value[1] === child && this._map.delete(_key3);
        }
        return (
          child._detach(),
          {
            modified: {
              node: this,
              type: "LiveMap",
              updates:
                ((_updates2 = {}),
                (_updates2[parentKey] = { type: "delete" }),
                _updates2),
            },
            reverse: reverse,
          }
        );
      }),
      (_proto._toSerializedCrdt = function () {
        if ("HasParent" !== this.parent.type)
          throw new Error("Cannot serialize LiveMap if parent is missing");
        return {
          type: exports.CrdtType.MAP,
          parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
          parentKey: this.parent.key,
        };
      }),
      (_proto.get = function (key) {
        var value = this._map.get(key);
        if (null != value) return liveNodeToLson(value);
      }),
      (_proto.set = function (key, value) {
        var oldValue = this._map.get(key);
        oldValue && oldValue._detach();
        var item = lsonToLiveNode(value);
        if (
          (item._setParentLink(this, key),
          this._map.set(key, item),
          this._doc && this._id)
        ) {
          var _updates3,
            id = this._doc.generateId();
          item._attach(id, this._doc);
          var storageUpdates = new Map();
          storageUpdates.set(this._id, {
            node: this,
            type: "LiveMap",
            updates:
              ((_updates3 = {}),
              (_updates3[key] = { type: "update" }),
              _updates3),
          });
          var ops = item._serialize(this._id, key, this._doc);
          this.unacknowledgedSet.set(key, nn(ops[0].opId)),
            this._doc.dispatch(
              item._serialize(this._id, key, this._doc),
              oldValue
                ? oldValue._serialize(this._id, key)
                : [{ type: exports.OpCode.DELETE_CRDT, id: id }],
              storageUpdates
            );
        }
      }),
      (_proto.has = function (key) {
        return this._map.has(key);
      }),
      (_proto.delete = function (key) {
        var item = this._map.get(key);
        if (null == item) return !1;
        if ((item._detach(), this._map.delete(key), this._doc && item._id)) {
          var _updates4,
            thisId = nn(this._id),
            storageUpdates = new Map();
          storageUpdates.set(thisId, {
            node: this,
            type: "LiveMap",
            updates:
              ((_updates4 = {}),
              (_updates4[key] = { type: "delete" }),
              _updates4),
          }),
            this._doc.dispatch(
              [
                {
                  type: exports.OpCode.DELETE_CRDT,
                  id: item._id,
                  opId: this._doc.generateOpId(),
                },
              ],
              item._serialize(thisId, key),
              storageUpdates
            );
        }
        return !0;
      }),
      (_proto.entries = function () {
        var _ref2,
          innerIterator = this._map.entries();
        return (
          ((_ref2 = {})[Symbol.iterator] = function () {
            return this;
          }),
          (_ref2.next = function () {
            var iteratorValue = innerIterator.next();
            return iteratorValue.done
              ? { done: !0, value: void 0 }
              : {
                  value: [
                    iteratorValue.value[0],
                    liveNodeToLson(iteratorValue.value[1]),
                  ],
                };
          }),
          _ref2
        );
      }),
      (_proto[_Symbol$iterator] = function () {
        return this.entries();
      }),
      (_proto.keys = function () {
        return this._map.keys();
      }),
      (_proto.values = function () {
        var _ref3,
          innerIterator = this._map.values();
        return (
          ((_ref3 = {})[Symbol.iterator] = function () {
            return this;
          }),
          (_ref3.next = function () {
            var iteratorValue = innerIterator.next();
            return iteratorValue.done
              ? { done: !0, value: void 0 }
              : { value: liveNodeToLson(iteratorValue.value) };
          }),
          _ref3
        );
      }),
      (_proto.forEach = function (callback) {
        for (
          var _step7, _iterator7 = _createForOfIteratorHelperLoose(this);
          !(_step7 = _iterator7()).done;

        ) {
          var entry = _step7.value;
          callback(entry[1], entry[0], this);
        }
      }),
      _createClass(LiveMap, [
        {
          key: "size",
          get: function () {
            return this._map.size;
          },
        },
      ]),
      LiveMap
    );
  })(AbstractCrdt),
  LiveObject = (function (_AbstractCrdt) {
    function LiveObject(obj) {
      var _this;
      for (var key in (void 0 === obj && (obj = {}),
      ((_this = _AbstractCrdt.call(this) || this)._map = void 0),
      (_this._propToLastUpdate = void 0),
      (_this._propToLastUpdate = new Map()),
      obj)) {
        var value = obj[key];
        void 0 !== value &&
          isLiveNode(value) &&
          value._setParentLink(_assertThisInitialized(_this), key);
      }
      return (_this._map = new Map(Object.entries(obj))), _this;
    }
    _inheritsLoose(LiveObject, _AbstractCrdt);
    var _proto = LiveObject.prototype;
    return (
      (_proto._serialize = function (parentId, parentKey, doc) {
        if (null == this._id)
          throw new Error("Cannot serialize item is not attached");
        var opId = null == doc ? void 0 : doc.generateOpId(),
          ops = [],
          op =
            void 0 !== parentId && void 0 !== parentKey
              ? {
                  type: exports.OpCode.CREATE_OBJECT,
                  id: this._id,
                  opId: opId,
                  parentId: parentId,
                  parentKey: parentKey,
                  data: {},
                }
              : {
                  type: exports.OpCode.CREATE_OBJECT,
                  id: this._id,
                  opId: opId,
                  data: {},
                };
        ops.push(op);
        for (
          var _step, _iterator = _createForOfIteratorHelperLoose(this._map);
          !(_step = _iterator()).done;

        ) {
          var _step$value = _step.value,
            key = _step$value[0],
            value = _step$value[1];
          isLiveNode(value)
            ? ops.push.apply(ops, value._serialize(this._id, key, doc))
            : (op.data[key] = value);
        }
        return ops;
      }),
      (LiveObject._deserialize = function (_ref, parentToChildren, doc) {
        var id = _ref[0],
          liveObj = new LiveObject(_ref[1].data);
        return (
          liveObj._attach(id, doc),
          this._deserializeChildren(liveObj, parentToChildren, doc)
        );
      }),
      (LiveObject._deserializeChildren = function (
        liveObj,
        parentToChildren,
        doc
      ) {
        var children = parentToChildren.get(nn(liveObj._id));
        if (null == children) return liveObj;
        for (
          var _step2, _iterator2 = _createForOfIteratorHelperLoose(children);
          !(_step2 = _iterator2()).done;

        ) {
          var _step2$value = _step2.value,
            id = _step2$value[0],
            crdt = _step2$value[1],
            child = deserializeToLson([id, crdt], parentToChildren, doc);
          isLiveStructure(child) &&
            child._setParentLink(liveObj, crdt.parentKey),
            liveObj._map.set(crdt.parentKey, child);
        }
        return liveObj;
      }),
      (_proto._attach = function (id, doc) {
        _AbstractCrdt.prototype._attach.call(this, id, doc);
        for (
          var _step3, _iterator3 = _createForOfIteratorHelperLoose(this._map);
          !(_step3 = _iterator3()).done;

        ) {
          var _step3$value = _step3.value;
          _step3$value[0];
          var value = _step3$value[1];
          isLiveNode(value) && value._attach(doc.generateId(), doc);
        }
      }),
      (_proto._attachChild = function (op, source) {
        var _updates;
        if (null == this._doc)
          throw new Error("Can't attach child if doc is not present");
        var id = op.id,
          opId = op.opId,
          key = op.parentKey,
          child = creationOpToLson(op);
        if (void 0 !== this._doc.getItem(id))
          return (
            this._propToLastUpdate.get(key) === opId &&
              this._propToLastUpdate.delete(key),
            { modified: !1 }
          );
        if (source === exports.OpSource.UNDOREDO_RECONNECT)
          this._propToLastUpdate.set(key, nn(opId));
        else if (void 0 !== this._propToLastUpdate.get(key))
          return this._propToLastUpdate.get(key) === opId
            ? (this._propToLastUpdate.delete(key), { modified: !1 })
            : { modified: !1 };
        var reverse,
          thisId = nn(this._id),
          previousValue = this._map.get(key);
        if (isLiveNode(previousValue))
          (reverse = previousValue._serialize(thisId, key)),
            previousValue._detach();
        else if (void 0 === previousValue)
          reverse = [
            { type: exports.OpCode.DELETE_OBJECT_KEY, id: thisId, key: key },
          ];
        else {
          var _data;
          reverse = [
            {
              type: exports.OpCode.UPDATE_OBJECT,
              id: thisId,
              data: ((_data = {}), (_data[key] = previousValue), _data),
            },
          ];
        }
        return (
          this._map.set(key, child),
          isLiveStructure(child) &&
            (child._setParentLink(this, key), child._attach(id, this._doc)),
          {
            reverse: reverse,
            modified: {
              node: this,
              type: "LiveObject",
              updates:
                ((_updates = {}),
                (_updates[key] = { type: "update" }),
                _updates),
            },
          }
        );
      }),
      (_proto._detachChild = function (child) {
        if (child) {
          for (
            var _updates2,
              _step4,
              id = nn(this._id),
              _parentKey = nn(child._parentKey),
              reverse = child._serialize(id, _parentKey, this._doc),
              _iterator4 = _createForOfIteratorHelperLoose(this._map);
            !(_step4 = _iterator4()).done;

          ) {
            var _step4$value = _step4.value,
              key = _step4$value[0];
            _step4$value[1] === child && this._map.delete(key);
          }
          return (
            child._detach(),
            {
              modified: {
                node: this,
                type: "LiveObject",
                updates:
                  ((_updates2 = {}),
                  (_updates2[_parentKey] = { type: "delete" }),
                  _updates2),
              },
              reverse: reverse,
            }
          );
        }
        return { modified: !1 };
      }),
      (_proto._detach = function () {
        _AbstractCrdt.prototype._detach.call(this);
        for (
          var _step5,
            _iterator5 = _createForOfIteratorHelperLoose(this._map.values());
          !(_step5 = _iterator5()).done;

        ) {
          var value = _step5.value;
          isLiveNode(value) && value._detach();
        }
      }),
      (_proto._apply = function (op, isLocal) {
        return op.type === exports.OpCode.UPDATE_OBJECT
          ? this._applyUpdate(op, isLocal)
          : op.type === exports.OpCode.DELETE_OBJECT_KEY
          ? this._applyDeleteObjectKey(op)
          : _AbstractCrdt.prototype._apply.call(this, op, isLocal);
      }),
      (_proto._toSerializedCrdt = function () {
        for (
          var _step6,
            data = {},
            _iterator6 = _createForOfIteratorHelperLoose(this._map);
          !(_step6 = _iterator6()).done;

        ) {
          var _step6$value = _step6.value,
            key = _step6$value[0],
            value = _step6$value[1];
          isLiveNode(value) || (data[key] = value);
        }
        return "HasParent" === this.parent.type && this.parent.node._id
          ? {
              type: exports.CrdtType.OBJECT,
              parentId: this.parent.node._id,
              parentKey: this.parent.key,
              data: data,
            }
          : { type: exports.CrdtType.OBJECT, data: data };
      }),
      (_proto._applyUpdate = function (op, isLocal) {
        var isModified = !1,
          id = nn(this._id),
          reverse = [],
          reverseUpdate = {
            type: exports.OpCode.UPDATE_OBJECT,
            id: id,
            data: {},
          };
        for (var key in (reverse.push(reverseUpdate), op.data)) {
          var oldValue = this._map.get(key);
          isLiveNode(oldValue)
            ? (reverse.push.apply(reverse, oldValue._serialize(id, key)),
              oldValue._detach())
            : void 0 !== oldValue
            ? (reverseUpdate.data[key] = oldValue)
            : void 0 === oldValue &&
              reverse.push({
                type: exports.OpCode.DELETE_OBJECT_KEY,
                id: id,
                key: key,
              });
        }
        var updateDelta = {};
        for (var _key2 in op.data) {
          var value = op.data[_key2];
          if (void 0 !== value) {
            if (isLocal) this._propToLastUpdate.set(_key2, nn(op.opId));
            else {
              if (null != this._propToLastUpdate.get(_key2)) {
                if (this._propToLastUpdate.get(_key2) === op.opId) {
                  this._propToLastUpdate.delete(_key2);
                  continue;
                }
                continue;
              }
              isModified = !0;
            }
            var _oldValue = this._map.get(_key2);
            isLiveNode(_oldValue) && _oldValue._detach(),
              (isModified = !0),
              (updateDelta[_key2] = { type: "update" }),
              this._map.set(_key2, value);
          }
        }
        return (
          0 !== Object.keys(reverseUpdate.data).length &&
            reverse.unshift(reverseUpdate),
          isModified
            ? {
                modified: {
                  node: this,
                  type: "LiveObject",
                  updates: updateDelta,
                },
                reverse: reverse,
              }
            : { modified: !1 }
        );
      }),
      (_proto._applyDeleteObjectKey = function (op) {
        var _updates3,
          key = op.key;
        if (!1 === this._map.has(key)) return { modified: !1 };
        if (void 0 !== this._propToLastUpdate.get(key)) return { modified: !1 };
        var oldValue = this._map.get(key),
          id = nn(this._id),
          reverse = [];
        if (isLiveNode(oldValue))
          (reverse = oldValue._serialize(id, op.key)), oldValue._detach();
        else if (void 0 !== oldValue) {
          var _data2;
          reverse = [
            {
              type: exports.OpCode.UPDATE_OBJECT,
              id: id,
              data: ((_data2 = {}), (_data2[key] = oldValue), _data2),
            },
          ];
        }
        return (
          this._map.delete(key),
          {
            modified: {
              node: this,
              type: "LiveObject",
              updates:
                ((_updates3 = {}),
                (_updates3[op.key] = { type: "delete" }),
                _updates3),
            },
            reverse: reverse,
          }
        );
      }),
      (_proto.toObject = function () {
        return (function (iterable) {
          for (
            var _step3,
              obj = {},
              _iterator3 = _createForOfIteratorHelperLoose(iterable);
            !(_step3 = _iterator3()).done;

          ) {
            var _step3$value = _step3.value,
              _key4 = _step3$value[0],
              val = _step3$value[1];
            obj[_key4] = val;
          }
          return obj;
        })(this._map);
      }),
      (_proto.set = function (key, value) {
        var _this$update;
        this.update((((_this$update = {})[key] = value), _this$update));
      }),
      (_proto.get = function (key) {
        return this._map.get(key);
      }),
      (_proto.delete = function (key) {
        var _updates4,
          keyAsString = key,
          oldValue = this._map.get(keyAsString);
        if (void 0 !== oldValue) {
          if (null == this._doc || null == this._id)
            return (
              isLiveNode(oldValue) && oldValue._detach(),
              void this._map.delete(keyAsString)
            );
          var reverse, _data3;
          if (isLiveNode(oldValue))
            oldValue._detach(),
              (reverse = oldValue._serialize(this._id, keyAsString));
          else
            reverse = [
              {
                type: exports.OpCode.UPDATE_OBJECT,
                data: ((_data3 = {}), (_data3[keyAsString] = oldValue), _data3),
                id: this._id,
              },
            ];
          this._map.delete(keyAsString);
          var storageUpdates = new Map();
          storageUpdates.set(this._id, {
            node: this,
            type: "LiveObject",
            updates:
              ((_updates4 = {}),
              (_updates4[key] = { type: "delete" }),
              _updates4),
          }),
            this._doc.dispatch(
              [
                {
                  type: exports.OpCode.DELETE_OBJECT_KEY,
                  key: keyAsString,
                  id: this._id,
                  opId: this._doc.generateOpId(),
                },
              ],
              reverse,
              storageUpdates
            );
        }
      }),
      (_proto.update = function (overrides) {
        var _this2 = this;
        if (null != this._doc && null != this._id) {
          var ops = [],
            reverseOps = [],
            opId = this._doc.generateOpId(),
            updatedProps = {},
            reverseUpdateOp = {
              id: this._id,
              type: exports.OpCode.UPDATE_OBJECT,
              data: {},
            },
            updateDelta = {};
          for (var _key3 in overrides) {
            var _newValue = overrides[_key3];
            if (void 0 !== _newValue) {
              var _oldValue2 = this._map.get(_key3);
              if (
                (isLiveNode(_oldValue2)
                  ? (reverseOps.push.apply(
                      reverseOps,
                      _oldValue2._serialize(this._id, _key3)
                    ),
                    _oldValue2._detach())
                  : void 0 === _oldValue2
                  ? reverseOps.push({
                      type: exports.OpCode.DELETE_OBJECT_KEY,
                      id: this._id,
                      key: _key3,
                    })
                  : (reverseUpdateOp.data[_key3] = _oldValue2),
                isLiveNode(_newValue))
              ) {
                _newValue._setParentLink(this, _key3),
                  _newValue._attach(this._doc.generateId(), this._doc);
                var newAttachChildOps = _newValue._serialize(
                    this._id,
                    _key3,
                    this._doc
                  ),
                  createCrdtOp = newAttachChildOps.find(function (op) {
                    return op.parentId === _this2._id;
                  });
                createCrdtOp &&
                  this._propToLastUpdate.set(_key3, nn(createCrdtOp.opId)),
                  ops.push.apply(ops, newAttachChildOps);
              } else
                (updatedProps[_key3] = _newValue),
                  this._propToLastUpdate.set(_key3, opId);
              this._map.set(_key3, _newValue),
                (updateDelta[_key3] = { type: "update" });
            }
          }
          0 !== Object.keys(reverseUpdateOp.data).length &&
            reverseOps.unshift(reverseUpdateOp),
            0 !== Object.keys(updatedProps).length &&
              ops.unshift({
                opId: opId,
                id: this._id,
                type: exports.OpCode.UPDATE_OBJECT,
                data: updatedProps,
              });
          var storageUpdates = new Map();
          storageUpdates.set(this._id, {
            node: this,
            type: "LiveObject",
            updates: updateDelta,
          }),
            this._doc.dispatch(ops, reverseOps, storageUpdates);
        } else
          for (var key in overrides) {
            var newValue = overrides[key];
            if (void 0 !== newValue) {
              var oldValue = this._map.get(key);
              isLiveNode(oldValue) && oldValue._detach(),
                isLiveNode(newValue) && newValue._setParentLink(this, key),
                this._map.set(key, newValue);
            }
          }
      }),
      LiveObject
    );
  })(AbstractCrdt);
function creationOpToLiveNode(op) {
  return lsonToLiveNode(creationOpToLson(op));
}
function creationOpToLson(op) {
  switch (op.type) {
    case exports.OpCode.CREATE_REGISTER:
      return op.data;
    case exports.OpCode.CREATE_OBJECT:
      return new LiveObject(op.data);
    case exports.OpCode.CREATE_MAP:
      return new LiveMap();
    case exports.OpCode.CREATE_LIST:
      return new LiveList();
    default:
      return assertNever(0, "Unknown creation Op");
  }
}
function deserialize(_ref, parentToChildren, doc) {
  var id = _ref[0],
    crdt = _ref[1];
  switch (crdt.type) {
    case exports.CrdtType.OBJECT:
      return LiveObject._deserialize([id, crdt], parentToChildren, doc);
    case exports.CrdtType.LIST:
      return LiveList._deserialize([id, crdt], parentToChildren, doc);
    case exports.CrdtType.MAP:
      return LiveMap._deserialize([id, crdt], parentToChildren, doc);
    case exports.CrdtType.REGISTER:
      return LiveRegister._deserialize([id, crdt], parentToChildren, doc);
    default:
      throw new Error("Unexpected CRDT type");
  }
}
function deserializeToLson(_ref2, parentToChildren, doc) {
  var id = _ref2[0],
    crdt = _ref2[1];
  switch (crdt.type) {
    case exports.CrdtType.OBJECT:
      return LiveObject._deserialize([id, crdt], parentToChildren, doc);
    case exports.CrdtType.LIST:
      return LiveList._deserialize([id, crdt], parentToChildren, doc);
    case exports.CrdtType.MAP:
      return LiveMap._deserialize([id, crdt], parentToChildren, doc);
    case exports.CrdtType.REGISTER:
      return crdt.data;
    default:
      throw new Error("Unexpected CRDT type");
  }
}
function isLiveStructure(value) {
  return (
    isLiveList(value) ||
    (function (value) {
      return value instanceof LiveMap;
    })(value) ||
    isLiveObject(value)
  );
}
function isLiveNode(value) {
  return (
    isLiveStructure(value) ||
    (function (value) {
      return value instanceof LiveRegister;
    })(value)
  );
}
function isLiveList(value) {
  return value instanceof LiveList;
}
function isLiveObject(value) {
  return value instanceof LiveObject;
}
function liveNodeToLson(obj) {
  return obj instanceof LiveRegister
    ? obj.data
    : obj instanceof LiveList ||
      obj instanceof LiveMap ||
      obj instanceof LiveObject
    ? obj
    : assertNever(0, "Unknown AbstractCrdt");
}
function lsonToLiveNode(value) {
  return value instanceof LiveObject ||
    value instanceof LiveMap ||
    value instanceof LiveList
    ? value
    : new LiveRegister(value);
}
function isPlain(value) {
  var type = typeof value;
  return (
    null == value ||
    "string" === type ||
    "boolean" === type ||
    "number" === type ||
    Array.isArray(value) ||
    isPlainObject(value)
  );
}
function isPlainObject(blob) {
  return (
    null !== blob &&
    "object" == typeof blob &&
    "[object Object]" === Object.prototype.toString.call(blob)
  );
}
function entries(obj) {
  return Object.entries(obj);
}
function tryParseJson(rawMessage) {
  try {
    return JSON.parse(rawMessage);
  } catch (e) {
    return;
  }
}
function b64decode(b64value) {
  try {
    var formattedValue = b64value.replace(/-/g, "+").replace(/_/g, "/");
    return decodeURIComponent(
      atob(formattedValue)
        .split("")
        .map(function (c) {
          return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
        })
        .join("")
    );
  } catch (err) {
    return atob(b64value);
  }
}
var _excluded = ["maxConnections"],
  SCOPES = [
    "websocket:presence",
    "websocket:storage",
    "room:read",
    "room:write",
    "rooms:read",
    "rooms:write",
  ];
function isStringList(value) {
  return (
    Array.isArray(value) &&
    value.every(function (i) {
      return "string" == typeof i;
    })
  );
}
function isAppOnlyAuthToken(data) {
  return (
    "string" == typeof data.appId &&
    void 0 === data.roomId &&
    isStringList(data.scopes)
  );
}
function isRoomAuthToken(data) {
  return (
    "string" == typeof data.appId &&
    "string" == typeof data.roomId &&
    "number" == typeof data.actor &&
    (void 0 === data.id || "string" == typeof data.id) &&
    isStringList(data.scopes) &&
    (void 0 === data.maxConnectionsPerRoom ||
      "number" == typeof data.maxConnectionsPerRoom)
  );
}
function parseJwtToken(token) {
  var tokenParts = token.split(".");
  if (3 !== tokenParts.length)
    throw new Error("Authentication error: invalid JWT token");
  var data = tryParseJson(b64decode(tokenParts[1]));
  if (
    data &&
    (function (data) {
      if (!isPlainObject(data)) return !1;
      var iat = data.iat,
        exp = data.exp;
      return "number" == typeof iat && "number" == typeof exp;
    })(data)
  )
    return data;
  throw new Error("Authentication error: missing JWT metadata");
}
function isJsonScalar(data) {
  return (
    null === data ||
    "string" == typeof data ||
    "number" == typeof data ||
    "boolean" == typeof data
  );
}
function isJsonArray(data) {
  return Array.isArray(data);
}
(exports.LiveList = LiveList),
  (exports.LiveMap = LiveMap),
  (exports.LiveObject = LiveObject),
  (exports.LiveRegister = LiveRegister),
  (exports._createForOfIteratorHelperLoose = _createForOfIteratorHelperLoose),
  (exports._extends = _extends),
  (exports._inheritsLoose = _inheritsLoose),
  (exports._objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose),
  (exports._wrapNativeSuper = _wrapNativeSuper),
  (exports.assertNever = assertNever),
  (exports.b64decode = b64decode),
  (exports.compact = function (items) {
    return items.filter(function (item) {
      return null != item;
    });
  }),
  (exports.comparePosition = comparePosition),
  (exports.deprecate = deprecate),
  (exports.deprecateIf = function (condition, message, key) {
    void 0 === key && (key = message),
      "production" !== process.env.NODE_ENV &&
        condition &&
        deprecate(message, key);
  }),
  (exports.errorIf = errorIf),
  (exports.findNonSerializableValue = function findNonSerializableValue(
    value,
    path
  ) {
    if ((void 0 === path && (path = ""), !isPlain))
      return { path: path || "root", value: value };
    if ("object" != typeof value || null === value) return !1;
    for (
      var _i = 0, _Object$entries = Object.entries(value);
      _i < _Object$entries.length;
      _i++
    ) {
      var _Object$entries$_i = _Object$entries[_i],
        _key3 = _Object$entries$_i[0],
        nestedValue = _Object$entries$_i[1],
        nestedPath = path ? path + "." + _key3 : _key3;
      if (!isPlain(nestedValue))
        return { path: nestedPath, value: nestedValue };
      if ("object" == typeof nestedValue) {
        var nonSerializableNestedValue = findNonSerializableValue(
          nestedValue,
          nestedPath
        );
        if (nonSerializableNestedValue) return nonSerializableNestedValue;
      }
    }
    return !1;
  }),
  (exports.getTreesDiffOperations = function (currentItems, newItems) {
    var ops = [];
    return (
      currentItems.forEach(function (_, id) {
        newItems.get(id) ||
          ops.push({ type: exports.OpCode.DELETE_CRDT, id: id });
      }),
      newItems.forEach(function (crdt, id) {
        var currentCrdt = currentItems.get(id);
        if (currentCrdt)
          crdt.type === exports.CrdtType.OBJECT &&
            ((currentCrdt.type === exports.CrdtType.OBJECT &&
              JSON.stringify(crdt.data) === JSON.stringify(currentCrdt.data)) ||
              ops.push({
                type: exports.OpCode.UPDATE_OBJECT,
                id: id,
                data: crdt.data,
              })),
            crdt.parentKey !== currentCrdt.parentKey &&
              ops.push({
                type: exports.OpCode.SET_PARENT_KEY,
                id: id,
                parentKey: nn(crdt.parentKey, "Parent key must not be missing"),
              });
        else
          switch (crdt.type) {
            case exports.CrdtType.REGISTER:
              ops.push({
                type: exports.OpCode.CREATE_REGISTER,
                id: id,
                parentId: crdt.parentId,
                parentKey: crdt.parentKey,
                data: crdt.data,
              });
              break;
            case exports.CrdtType.LIST:
              ops.push({
                type: exports.OpCode.CREATE_LIST,
                id: id,
                parentId: crdt.parentId,
                parentKey: crdt.parentKey,
              });
              break;
            case exports.CrdtType.OBJECT:
              ops.push(
                crdt.parentId
                  ? {
                      type: exports.OpCode.CREATE_OBJECT,
                      id: id,
                      parentId: crdt.parentId,
                      parentKey: crdt.parentKey,
                      data: crdt.data,
                    }
                  : {
                      type: exports.OpCode.CREATE_OBJECT,
                      id: id,
                      data: crdt.data,
                    }
              );
              break;
            case exports.CrdtType.MAP:
              ops.push({
                type: exports.OpCode.CREATE_MAP,
                id: id,
                parentId: crdt.parentId,
                parentKey: crdt.parentKey,
              });
          }
      }),
      ops
    );
  }),
  (exports.isAppOnlyAuthToken = isAppOnlyAuthToken),
  (exports.isAuthToken = function (data) {
    return isAppOnlyAuthToken(data) || isRoomAuthToken(data);
  }),
  (exports.isChildCrdt = isChildCrdt),
  (exports.isJsonArray = isJsonArray),
  (exports.isJsonObject = function (data) {
    return !isJsonScalar(data) && !isJsonArray(data);
  }),
  (exports.isJsonScalar = isJsonScalar),
  (exports.isLiveList = isLiveList),
  (exports.isLiveNode = isLiveNode),
  (exports.isLiveObject = isLiveObject),
  (exports.isPlainObject = isPlainObject),
  (exports.isRoomAuthToken = isRoomAuthToken),
  (exports.isRoomEventName = function (value) {
    return (
      "my-presence" === value ||
      "others" === value ||
      "event" === value ||
      "error" === value ||
      "connection" === value
    );
  }),
  (exports.isRootCrdt = function (crdt) {
    return crdt.type === exports.CrdtType.OBJECT && !isChildCrdt(crdt);
  }),
  (exports.isSameNodeOrChildOf = function isSameNodeOrChildOf(node, parent) {
    return (
      node === parent ||
      ("HasParent" === node.parent.type &&
        isSameNodeOrChildOf(node.parent.node, parent))
    );
  }),
  (exports.isScope = function (value) {
    return SCOPES.includes(value);
  }),
  (exports.isTokenExpired = function (token) {
    var now = Date.now() / 1e3;
    return now > token.exp - 300 || now < token.iat + 300;
  }),
  (exports.makePosition = makePosition),
  (exports.mergeStorageUpdates = function (first, second) {
    return first
      ? "LiveObject" === first.type && "LiveObject" === second.type
        ? (function (first, second) {
            for (
              var _step,
                updates = first.updates,
                _iterator = _createForOfIteratorHelperLoose(
                  entries(second.updates)
                );
              !(_step = _iterator()).done;

            ) {
              var _step$value = _step.value,
                _key = _step$value[0],
                value = _step$value[1];
              updates[_key] = value;
            }
            return _extends({}, second, { updates: updates });
          })(first, second)
        : "LiveMap" === first.type && "LiveMap" === second.type
        ? (function (first, second) {
            for (
              var _step2,
                updates = first.updates,
                _iterator2 = _createForOfIteratorHelperLoose(
                  entries(second.updates)
                );
              !(_step2 = _iterator2()).done;

            ) {
              var _step2$value = _step2.value,
                _key2 = _step2$value[0],
                value = _step2$value[1];
              updates[_key2] = value;
            }
            return _extends({}, second, { updates: updates });
          })(first, second)
        : "LiveList" === first.type && "LiveList" === second.type
        ? (function (first, second) {
            return _extends({}, second, {
              updates: first.updates.concat(second.updates),
            });
          })(first, second)
        : second
      : second;
  }),
  (exports.nn = nn),
  (exports.parseRoomAuthToken = function (tokenString) {
    var data = parseJwtToken(tokenString);
    if (data && isRoomAuthToken(data))
      return (
        data.maxConnections, _objectWithoutPropertiesLoose(data, _excluded)
      );
    throw new Error(
      "Authentication error: we expected a room token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback"
    );
  }),
  (exports.remove = function (array, item) {
    for (var i = 0; i < array.length; i++)
      if (array[i] === item) {
        array.splice(i, 1);
        break;
      }
  }),
  (exports.throwUsageError = throwUsageError),
  (exports.tryParseJson = tryParseJson);
