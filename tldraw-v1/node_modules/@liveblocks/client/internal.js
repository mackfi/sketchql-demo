"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var Json = require("./shared.js");
function lsonObjectToJson(obj) {
  var result = {};
  for (var key in obj) {
    var val = obj[key];
    void 0 !== val && (result[key] = lsonToJson(val));
  }
  return result;
}
function lsonListToJson(value) {
  return value.map(lsonToJson);
}
function lsonToJson(value) {
  return value instanceof Json.LiveObject
    ? lsonObjectToJson(value.toObject())
    : value instanceof Json.LiveList
    ? (function (value) {
        return lsonListToJson(value.toArray());
      })(value)
    : value instanceof Json.LiveMap
    ? (function (map) {
        for (
          var _step,
            result = {},
            _iterator = Json._createForOfIteratorHelperLoose(map.entries());
          !(_step = _iterator()).done;

        ) {
          var _step$value = _step.value,
            key = _step$value[0],
            value = _step$value[1];
          result[key] = lsonToJson(value);
        }
        return result;
      })(value)
    : value instanceof Json.LiveRegister
    ? value.data
    : Array.isArray(value)
    ? lsonListToJson(value)
    : Json.isPlainObject(value)
    ? lsonObjectToJson(value)
    : value;
}
function deepLiveify(value) {
  if (Array.isArray(value)) return new Json.LiveList(value.map(deepLiveify));
  if (Json.isPlainObject(value)) {
    var init = {};
    for (var key in value) {
      var val = value[key];
      void 0 !== val && (init[key] = deepLiveify(val));
    }
    return new Json.LiveObject(init);
  }
  return value;
}
function patchLiveObjectKey(liveObject, key, prev, next) {
  if ("production" !== process.env.NODE_ENV) {
    var nonSerializableValue = Json.findNonSerializableValue(next);
    if (nonSerializableValue)
      return void console.error(
        "New state path: '" +
          nonSerializableValue.path +
          "' value: '" +
          nonSerializableValue.value +
          "' is not serializable.\nOnly serializable value can be synced with Liveblocks."
      );
  }
  var value = liveObject.get(key);
  if (void 0 === next) liveObject.delete(key);
  else if (void 0 === value) liveObject.set(key, deepLiveify(next));
  else {
    if (prev === next) return;
    Json.isLiveList(value) && Array.isArray(prev) && Array.isArray(next)
      ? (function (liveList, prev, next) {
          var i = 0,
            prevEnd = prev.length - 1,
            nextEnd = next.length - 1,
            prevNode = prev[0],
            nextNode = next[0];
          outer: {
            for (; prevNode === nextNode; ) {
              if (++i > prevEnd || i > nextEnd) break outer;
              (prevNode = prev[i]), (nextNode = next[i]);
            }
            for (
              prevNode = prev[prevEnd], nextNode = next[nextEnd];
              prevNode === nextNode;

            ) {
              if ((nextEnd--, i > --prevEnd || i > nextEnd)) break outer;
              (prevNode = prev[prevEnd]), (nextNode = next[nextEnd]);
            }
          }
          if (i > prevEnd) {
            if (i <= nextEnd)
              for (; i <= nextEnd; )
                liveList.insert(deepLiveify(next[i]), i), i++;
          } else if (i > nextEnd)
            for (var localI = i; localI <= prevEnd; )
              liveList.delete(i), localI++;
          else {
            for (; i <= prevEnd && i <= nextEnd; ) {
              (prevNode = prev[i]), (nextNode = next[i]);
              var liveListNode = liveList.get(i);
              Json.isLiveObject(liveListNode) &&
              Json.isPlainObject(prevNode) &&
              Json.isPlainObject(nextNode)
                ? patchLiveObject(liveListNode, prevNode, nextNode)
                : liveList.set(i, deepLiveify(nextNode)),
                i++;
            }
            for (; i <= nextEnd; )
              liveList.insert(deepLiveify(next[i]), i), i++;
            for (var _localI = i; _localI <= prevEnd; )
              liveList.delete(i), _localI++;
          }
        })(value, prev, next)
      : Json.isLiveObject(value) &&
        Json.isPlainObject(prev) &&
        Json.isPlainObject(next)
      ? patchLiveObject(value, prev, next)
      : liveObject.set(key, deepLiveify(next));
  }
}
function patchLiveObject(root, prev, next) {
  var updates = {};
  for (var key in next) patchLiveObjectKey(root, key, prev[key], next[key]);
  for (var _key in prev) void 0 === next[_key] && root.delete(_key);
  Object.keys(updates).length > 0 && root.update(updates);
}
function patchImmutableNode(state, path, update) {
  var pathItem = path.pop();
  if (void 0 === pathItem)
    switch (update.type) {
      case "LiveObject":
        if (null === state || "object" != typeof state || Array.isArray(state))
          throw new Error(
            "Internal: received update on LiveObject but state was not an object"
          );
        var newState = Object.assign({}, state);
        for (var key in update.updates) {
          var _update$updates$key, _update$updates$key2;
          if (
            "update" ===
            (null == (_update$updates$key = update.updates[key])
              ? void 0
              : _update$updates$key.type)
          ) {
            var val = update.node.get(key);
            void 0 !== val && (newState[key] = lsonToJson(val));
          } else
            "delete" ===
              (null == (_update$updates$key2 = update.updates[key])
                ? void 0
                : _update$updates$key2.type) && delete newState[key];
        }
        return newState;
      case "LiveList":
        if (!Array.isArray(state))
          throw new Error(
            "Internal: received update on LiveList but state was not an array"
          );
        for (
          var _step2,
            _newState = state.map(function (x) {
              return x;
            }),
            _loop = function () {
              var listUpdate = _step2.value;
              "set" === listUpdate.type
                ? (_newState = _newState.map(function (item, index) {
                    return index === listUpdate.index
                      ? lsonToJson(listUpdate.item)
                      : item;
                  }))
                : "insert" === listUpdate.type
                ? listUpdate.index === _newState.length
                  ? _newState.push(lsonToJson(listUpdate.item))
                  : (_newState = [].concat(
                      _newState.slice(0, listUpdate.index),
                      [lsonToJson(listUpdate.item)],
                      _newState.slice(listUpdate.index)
                    ))
                : "delete" === listUpdate.type
                ? _newState.splice(listUpdate.index, 1)
                : "move" === listUpdate.type &&
                  (_newState =
                    listUpdate.previousIndex > listUpdate.index
                      ? [].concat(
                          _newState.slice(0, listUpdate.index),
                          [lsonToJson(listUpdate.item)],
                          _newState.slice(
                            listUpdate.index,
                            listUpdate.previousIndex
                          ),
                          _newState.slice(listUpdate.previousIndex + 1)
                        )
                      : [].concat(
                          _newState.slice(0, listUpdate.previousIndex),
                          _newState.slice(
                            listUpdate.previousIndex + 1,
                            listUpdate.index + 1
                          ),
                          [lsonToJson(listUpdate.item)],
                          _newState.slice(listUpdate.index + 1)
                        ));
            },
            _iterator2 = Json._createForOfIteratorHelperLoose(update.updates);
          !(_step2 = _iterator2()).done;

        )
          _loop();
        return _newState;
      case "LiveMap":
        if (null === state || "object" != typeof state || Array.isArray(state))
          throw new Error(
            "Internal: received update on LiveMap but state was not an object"
          );
        var _newState2 = Object.assign({}, state);
        for (var _key2 in update.updates) {
          var _update$updates$_key, _update$updates$_key2;
          if (
            "update" ===
            (null == (_update$updates$_key = update.updates[_key2])
              ? void 0
              : _update$updates$_key.type)
          ) {
            var value = update.node.get(_key2);
            void 0 !== value && (_newState2[_key2] = lsonToJson(value));
          } else
            "delete" ===
              (null == (_update$updates$_key2 = update.updates[_key2])
                ? void 0
                : _update$updates$_key2.type) && delete _newState2[_key2];
        }
        return _newState2;
    }
  if (Array.isArray(state)) {
    var newArray = [].concat(state);
    return (
      (newArray[pathItem] = patchImmutableNode(state[pathItem], path, update)),
      newArray
    );
  }
  if (null !== state && "object" == typeof state) {
    var _extends2,
      node = state[pathItem];
    return void 0 === node
      ? state
      : Json._extends(
          {},
          state,
          (((_extends2 = {})[pathItem] = patchImmutableNode(
            node,
            path,
            update
          )),
          _extends2)
        );
  }
  return state;
}
Object.defineProperty(exports, "ClientMsgCode", {
  enumerable: !0,
  get: function () {
    return Json.ClientMsgCode;
  },
}),
  Object.defineProperty(exports, "CrdtType", {
    enumerable: !0,
    get: function () {
      return Json.CrdtType;
    },
  }),
  Object.defineProperty(exports, "OpCode", {
    enumerable: !0,
    get: function () {
      return Json.OpCode;
    },
  }),
  Object.defineProperty(exports, "ServerMsgCode", {
    enumerable: !0,
    get: function () {
      return Json.ServerMsgCode;
    },
  }),
  Object.defineProperty(exports, "WebsocketCloseCodes", {
    enumerable: !0,
    get: function () {
      return Json.WebsocketCloseCodes;
    },
  }),
  (exports.assertNever = Json.assertNever),
  (exports.b64decode = Json.b64decode),
  (exports.comparePosition = Json.comparePosition),
  (exports.deprecate = Json.deprecate),
  (exports.deprecateIf = Json.deprecateIf),
  (exports.errorIf = Json.errorIf),
  (exports.isAppOnlyAuthToken = Json.isAppOnlyAuthToken),
  (exports.isAuthToken = Json.isAuthToken),
  (exports.isChildCrdt = Json.isChildCrdt),
  (exports.isJsonArray = Json.isJsonArray),
  (exports.isJsonObject = Json.isJsonObject),
  (exports.isJsonScalar = Json.isJsonScalar),
  (exports.isPlainObject = Json.isPlainObject),
  (exports.isRoomAuthToken = Json.isRoomAuthToken),
  (exports.isRootCrdt = Json.isRootCrdt),
  (exports.isScope = Json.isScope),
  (exports.makePosition = Json.makePosition),
  (exports.nn = Json.nn),
  (exports.throwUsageError = Json.throwUsageError),
  (exports.tryParseJson = Json.tryParseJson),
  (exports.lsonToJson = lsonToJson),
  (exports.patchImmutableObject = function (state, updates) {
    return updates.reduce(function (state, update) {
      return (function (state, update) {
        var path = (function (node) {
          for (var path = []; "HasParent" === node.parent.type; )
            Json.isLiveList(node.parent.node)
              ? path.push(node.parent.node._indexOfPosition(node.parent.key))
              : path.push(node.parent.key),
              (node = node.parent.node);
          return path;
        })(update.node);
        return patchImmutableNode(state, path, update);
      })(state, update);
    }, state);
  }),
  (exports.patchLiveObjectKey = patchLiveObjectKey);
