const _emittedDeprecationWarnings = new Set();
function deprecate(message, key = message) {
  "production" !== process.env.NODE_ENV &&
    (_emittedDeprecationWarnings.has(key) ||
      (_emittedDeprecationWarnings.add(key),
      console.error(`DEPRECATION WARNING: ${message}`)));
}
function deprecateIf(condition, message, key = message) {
  "production" !== process.env.NODE_ENV && condition && deprecate(message, key);
}
function throwUsageError(message) {
  if ("production" !== process.env.NODE_ENV) {
    const usageError = new Error(message);
    throw ((usageError.name = "Usage error"), usageError);
  }
}
function errorIf(condition, message) {
  "production" !== process.env.NODE_ENV &&
    condition &&
    throwUsageError(message);
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    Object.prototype.hasOwnProperty.call(s, p) &&
      e.indexOf(p) < 0 &&
      (t[p] = s[p]);
  if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s); i < p.length; i++)
      e.indexOf(p[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(s, p[i]) &&
        (t[p[i]] = s[p[i]]);
  }
  return t;
}
function assertNever(_value, errmsg) {
  throw new Error(errmsg);
}
function nn(value, errmsg = "Expected value to be non-nullable") {
  return (
    (function (condition, errmsg) {
      if ("production" !== process.env.NODE_ENV && !condition) {
        const err = new Error(errmsg);
        throw ((err.name = "Assertion failure"), err);
      }
    })(null != value, errmsg),
    value
  );
}
var ClientMsgCode,
  OpCode,
  CrdtType,
  ServerMsgCode,
  WebsocketCloseCodes,
  OpSource;
function isRootCrdt(crdt) {
  return crdt.type === CrdtType.OBJECT && !isChildCrdt(crdt);
}
function isChildCrdt(crdt) {
  return void 0 !== crdt.parentId && void 0 !== crdt.parentKey;
}
function isRoomEventName(value) {
  return (
    "my-presence" === value ||
    "others" === value ||
    "event" === value ||
    "error" === value ||
    "connection" === value
  );
}
function HasParent(node, key) {
  return Object.freeze({ type: "HasParent", node: node, key: key });
}
!(function (ClientMsgCode) {
  (ClientMsgCode[(ClientMsgCode.UPDATE_PRESENCE = 100)] = "UPDATE_PRESENCE"),
    (ClientMsgCode[(ClientMsgCode.BROADCAST_EVENT = 103)] = "BROADCAST_EVENT"),
    (ClientMsgCode[(ClientMsgCode.FETCH_STORAGE = 200)] = "FETCH_STORAGE"),
    (ClientMsgCode[(ClientMsgCode.UPDATE_STORAGE = 201)] = "UPDATE_STORAGE");
})(ClientMsgCode || (ClientMsgCode = {})),
  (function (OpCode) {
    (OpCode[(OpCode.INIT = 0)] = "INIT"),
      (OpCode[(OpCode.SET_PARENT_KEY = 1)] = "SET_PARENT_KEY"),
      (OpCode[(OpCode.CREATE_LIST = 2)] = "CREATE_LIST"),
      (OpCode[(OpCode.UPDATE_OBJECT = 3)] = "UPDATE_OBJECT"),
      (OpCode[(OpCode.CREATE_OBJECT = 4)] = "CREATE_OBJECT"),
      (OpCode[(OpCode.DELETE_CRDT = 5)] = "DELETE_CRDT"),
      (OpCode[(OpCode.DELETE_OBJECT_KEY = 6)] = "DELETE_OBJECT_KEY"),
      (OpCode[(OpCode.CREATE_MAP = 7)] = "CREATE_MAP"),
      (OpCode[(OpCode.CREATE_REGISTER = 8)] = "CREATE_REGISTER");
  })(OpCode || (OpCode = {})),
  (function (CrdtType) {
    (CrdtType[(CrdtType.OBJECT = 0)] = "OBJECT"),
      (CrdtType[(CrdtType.LIST = 1)] = "LIST"),
      (CrdtType[(CrdtType.MAP = 2)] = "MAP"),
      (CrdtType[(CrdtType.REGISTER = 3)] = "REGISTER");
  })(CrdtType || (CrdtType = {})),
  (function (ServerMsgCode) {
    (ServerMsgCode[(ServerMsgCode.UPDATE_PRESENCE = 100)] = "UPDATE_PRESENCE"),
      (ServerMsgCode[(ServerMsgCode.USER_JOINED = 101)] = "USER_JOINED"),
      (ServerMsgCode[(ServerMsgCode.USER_LEFT = 102)] = "USER_LEFT"),
      (ServerMsgCode[(ServerMsgCode.BROADCASTED_EVENT = 103)] =
        "BROADCASTED_EVENT"),
      (ServerMsgCode[(ServerMsgCode.ROOM_STATE = 104)] = "ROOM_STATE"),
      (ServerMsgCode[(ServerMsgCode.INITIAL_STORAGE_STATE = 200)] =
        "INITIAL_STORAGE_STATE"),
      (ServerMsgCode[(ServerMsgCode.UPDATE_STORAGE = 201)] = "UPDATE_STORAGE");
  })(ServerMsgCode || (ServerMsgCode = {})),
  (function (WebsocketCloseCodes) {
    (WebsocketCloseCodes[(WebsocketCloseCodes.CLOSE_ABNORMAL = 1006)] =
      "CLOSE_ABNORMAL"),
      (WebsocketCloseCodes[(WebsocketCloseCodes.INVALID_MESSAGE_FORMAT = 4e3)] =
        "INVALID_MESSAGE_FORMAT"),
      (WebsocketCloseCodes[(WebsocketCloseCodes.NOT_ALLOWED = 4001)] =
        "NOT_ALLOWED"),
      (WebsocketCloseCodes[
        (WebsocketCloseCodes.MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002)
      ] = "MAX_NUMBER_OF_MESSAGES_PER_SECONDS"),
      (WebsocketCloseCodes[
        (WebsocketCloseCodes.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003)
      ] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS"),
      (WebsocketCloseCodes[
        (WebsocketCloseCodes.MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004)
      ] = "MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP"),
      (WebsocketCloseCodes[
        (WebsocketCloseCodes.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005)
      ] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM"),
      (WebsocketCloseCodes[(WebsocketCloseCodes.CLOSE_WITHOUT_RETRY = 4999)] =
        "CLOSE_WITHOUT_RETRY");
  })(WebsocketCloseCodes || (WebsocketCloseCodes = {})),
  (function (OpSource) {
    (OpSource[(OpSource.UNDOREDO_RECONNECT = 0)] = "UNDOREDO_RECONNECT"),
      (OpSource[(OpSource.REMOTE = 1)] = "REMOTE"),
      (OpSource[(OpSource.ACK = 2)] = "ACK");
  })(OpSource || (OpSource = {}));
const NoParent = Object.freeze({ type: "NoParent" });
function Orphaned(oldKey) {
  return Object.freeze({ type: "Orphaned", oldKey: oldKey });
}
class AbstractCrdt {
  constructor() {
    this._parent = NoParent;
  }
  _getParentKeyOrThrow() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        throw new Error("Parent key is missing");
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  get _doc() {
    return this.__doc;
  }
  get roomId() {
    return this.__doc ? this.__doc.roomId : null;
  }
  get _id() {
    return this.__id;
  }
  get parent() {
    return this._parent;
  }
  get _parentNode() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.node;
      case "NoParent":
      case "Orphaned":
        return null;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  get _parentKey() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        return null;
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  _apply(op, _isLocal) {
    return op.type === OpCode.DELETE_CRDT && "HasParent" === this.parent.type
      ? this.parent.node._detachChild(this)
      : { modified: !1 };
  }
  _setParentLink(newParentNode, newParentKey) {
    switch (this.parent.type) {
      case "HasParent":
        if (this.parent.node !== newParentNode)
          throw new Error("Cannot attach parent if it already exist");
        return void (this._parent = HasParent(newParentNode, newParentKey));
      case "Orphaned":
      case "NoParent":
        return void (this._parent = HasParent(newParentNode, newParentKey));
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  _attach(id, doc) {
    if (this.__id || this.__doc)
      throw new Error("Cannot attach if CRDT is already attached");
    doc.addItem(id, this), (this.__id = id), (this.__doc = doc);
  }
  _detach() {
    switch (
      (this.__doc && this.__id && this.__doc.deleteItem(this.__id),
      this.parent.type)
    ) {
      case "HasParent":
        this._parent = Orphaned(this.parent.key);
        break;
      case "NoParent":
        this._parent = NoParent;
        break;
      case "Orphaned":
        this._parent = Orphaned(this.parent.oldKey);
        break;
      default:
        assertNever(this.parent, "Unknown state");
    }
    this.__doc = void 0;
  }
}
class LiveRegister extends AbstractCrdt {
  constructor(data) {
    super(), (this._data = data);
  }
  get data() {
    return this._data;
  }
  static _deserialize([id, item], _parentToChildren, doc) {
    const register = new LiveRegister(item.data);
    return register._attach(id, doc), register;
  }
  _serialize(parentId, parentKey, doc) {
    if (null == this._id || null == parentId || null == parentKey)
      throw new Error(
        "Cannot serialize register if parentId or parentKey is undefined"
      );
    return [
      {
        type: OpCode.CREATE_REGISTER,
        opId: null == doc ? void 0 : doc.generateOpId(),
        id: this._id,
        parentId: parentId,
        parentKey: parentKey,
        data: this.data,
      },
    ];
  }
  _toSerializedCrdt() {
    if ("HasParent" !== this.parent.type)
      throw new Error("Cannot serialize LiveRegister if parent is missing");
    return {
      type: CrdtType.REGISTER,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key,
      data: this.data,
    };
  }
  _attachChild(_op) {
    throw new Error("Method not implemented.");
  }
  _detachChild(_crdt) {
    throw new Error("Method not implemented.");
  }
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
}
function makePosition(before, after) {
  return null != before && null != after
    ? pos(makePositionFromCodes(posCodes(before), posCodes(after)))
    : null != before
    ? (function (before) {
        const result = [],
          beforeCodes = posCodes(before);
        for (let i = 0; i < beforeCodes.length; i++) {
          const code = beforeCodes[i];
          if (126 !== code) {
            result.push(code + 1);
            break;
          }
          if ((result.push(code), beforeCodes.length - 1 === i)) {
            result.push(33);
            break;
          }
        }
        return pos(result);
      })(before)
    : null != after
    ? (function (after) {
        const result = [],
          afterCodes = posCodes(after);
        for (let i = 0; i < afterCodes.length; i++) {
          const code = afterCodes[i];
          if (!(code <= 33)) {
            result.push(code - 1);
            break;
          }
          if ((result.push(32), afterCodes.length - 1 === i)) {
            result.push(126);
            break;
          }
        }
        return pos(result);
      })(after)
    : pos([33]);
}
function makePositionFromCodes(before, after) {
  let index = 0;
  const result = [];
  for (;;) {
    const beforeDigit = before[index] || 32,
      afterDigit = after[index] || 126;
    if (beforeDigit > afterDigit)
      throw new Error(
        `Impossible to generate position between ${before} and ${after}`
      );
    if (beforeDigit === afterDigit) {
      result.push(beforeDigit), index++;
      continue;
    }
    if (afterDigit - beforeDigit == 1) {
      result.push(beforeDigit),
        result.push(...makePositionFromCodes(before.slice(index + 1), []));
      break;
    }
    const mid = (afterDigit + beforeDigit) >> 1;
    result.push(mid);
    break;
  }
  return result;
}
function posCodes(str) {
  const codes = [];
  for (let i = 0; i < str.length; i++) codes.push(str.charCodeAt(i));
  return codes;
}
function pos(codes) {
  return String.fromCharCode(...codes);
}
function comparePosition(posA, posB) {
  const aCodes = posCodes(posA),
    bCodes = posCodes(posB),
    maxLength = Math.max(aCodes.length, bCodes.length);
  for (let i = 0; i < maxLength; i++) {
    const a = null == aCodes[i] ? 32 : aCodes[i],
      b = null == bCodes[i] ? 32 : bCodes[i];
    if (a !== b) return a - b;
  }
  throw new Error(
    `Impossible to compare similar position "${posA}" and "${posB}"`
  );
}
function compareNodePosition(itemA, itemB) {
  return comparePosition(
    itemA._getParentKeyOrThrow(),
    itemB._getParentKeyOrThrow()
  );
}
class LiveList extends AbstractCrdt {
  constructor(items = []) {
    let position;
    super(),
      (this._items = []),
      (this._implicitlyDeletedItems = new Set()),
      (this._unacknowledgedSets = new Map());
    for (let i = 0; i < items.length; i++) {
      const newPosition = makePosition(position),
        item = lsonToLiveNode(items[i]);
      item._setParentLink(this, newPosition),
        this._items.push(item),
        (position = newPosition);
    }
  }
  static _deserialize([id], parentToChildren, doc) {
    const list = new LiveList();
    list._attach(id, doc);
    const children = parentToChildren.get(id);
    if (null == children) return list;
    for (const [id, crdt] of children) {
      const child = deserialize([id, crdt], parentToChildren, doc);
      child._setParentLink(list, crdt.parentKey), list._insertAndSort(child);
    }
    return list;
  }
  _serialize(parentId, parentKey, doc) {
    if (null == this._id)
      throw new Error("Cannot serialize item is not attached");
    const ops = [],
      op = {
        id: this._id,
        opId: null == doc ? void 0 : doc.generateOpId(),
        type: OpCode.CREATE_LIST,
        parentId: parentId,
        parentKey: parentKey,
      };
    ops.push(op);
    for (const item of this._items)
      ops.push(...item._serialize(this._id, item._getParentKeyOrThrow(), doc));
    return ops;
  }
  _insertAndSort(item) {
    this._items.push(item), this._sortItems();
  }
  _sortItems() {
    this._items.sort(compareNodePosition);
  }
  _indexOfPosition(position) {
    return this._items.findIndex(
      (item) => item._getParentKeyOrThrow() === position
    );
  }
  _attach(id, doc) {
    super._attach(id, doc);
    for (const item of this._items) item._attach(doc.generateId(), doc);
  }
  _detach() {
    super._detach();
    for (const item of this._items) item._detach();
  }
  _applySetRemote(op) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    const { id: id, parentKey: key } = op,
      child = creationOpToLiveNode(op);
    child._attach(id, this._doc), child._setParentLink(this, key);
    const deletedId = op.deletedId,
      indexOfItemWithSamePosition = this._indexOfPosition(key);
    if (-1 !== indexOfItemWithSamePosition) {
      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];
      if (itemWithSamePosition._id === deletedId)
        return (
          itemWithSamePosition._detach(),
          (this._items[indexOfItemWithSamePosition] = child),
          {
            modified: makeUpdate(this, [
              setDelta(indexOfItemWithSamePosition, child),
            ]),
            reverse: [],
          }
        );
      {
        this._implicitlyDeletedItems.add(itemWithSamePosition),
          (this._items[indexOfItemWithSamePosition] = child);
        const delta = [setDelta(indexOfItemWithSamePosition, child)],
          deleteDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
        return (
          deleteDelta && delta.push(deleteDelta),
          { modified: makeUpdate(this, delta), reverse: [] }
        );
      }
    }
    {
      const updates = [],
        deleteDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
      return (
        deleteDelta && updates.push(deleteDelta),
        this._insertAndSort(child),
        updates.push(insertDelta(this._indexOfPosition(key), child)),
        { reverse: [], modified: makeUpdate(this, updates) }
      );
    }
  }
  _applySetAck(op) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    const delta = [],
      deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
    deletedDelta && delta.push(deletedDelta);
    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);
    if (null != unacknowledgedOpId) {
      if (unacknowledgedOpId !== op.opId)
        return 0 === delta.length
          ? { modified: !1 }
          : { modified: makeUpdate(this, delta), reverse: [] };
      this._unacknowledgedSets.delete(op.parentKey);
    }
    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey),
      existingItem = this._items.find((item) => item._id === op.id);
    if (null != existingItem) {
      if (existingItem._parentKey === op.parentKey)
        return {
          modified: delta.length > 0 && makeUpdate(this, delta),
          reverse: [],
        };
      -1 !== indexOfItemWithSamePosition &&
        (this._implicitlyDeletedItems.add(
          this._items[indexOfItemWithSamePosition]
        ),
        this._items.splice(indexOfItemWithSamePosition, 1),
        delta.push(deleteDelta(indexOfItemWithSamePosition)));
      const previousIndex = this._items.indexOf(existingItem);
      existingItem._setParentLink(this, op.parentKey), this._sortItems();
      const newIndex = this._items.indexOf(existingItem);
      return (
        newIndex !== previousIndex &&
          delta.push(moveDelta(previousIndex, newIndex, existingItem)),
        { modified: delta.length > 0 && makeUpdate(this, delta), reverse: [] }
      );
    }
    {
      const orphan = this._doc.getItem(op.id);
      if (orphan && this._implicitlyDeletedItems.has(orphan)) {
        orphan._setParentLink(this, op.parentKey),
          this._implicitlyDeletedItems.delete(orphan),
          this._insertAndSort(orphan);
        const recreatedItemIndex = this._items.indexOf(orphan);
        return {
          modified: makeUpdate(this, [
            -1 === indexOfItemWithSamePosition
              ? insertDelta(recreatedItemIndex, orphan)
              : setDelta(recreatedItemIndex, orphan),
            ...delta,
          ]),
          reverse: [],
        };
      }
      {
        -1 !== indexOfItemWithSamePosition &&
          this._items.splice(indexOfItemWithSamePosition, 1);
        const { newItem: newItem, newIndex: newIndex } =
          this._createAttachItemAndSort(op, op.parentKey);
        return {
          modified: makeUpdate(this, [
            -1 === indexOfItemWithSamePosition
              ? insertDelta(newIndex, newItem)
              : setDelta(newIndex, newItem),
            ...delta,
          ]),
          reverse: [],
        };
      }
    }
  }
  _detachItemAssociatedToSetOperation(deletedId) {
    if (null == deletedId || null == this._doc) return null;
    const deletedItem = this._doc.getItem(deletedId);
    if (null == deletedItem) return null;
    const result = this._detachChild(deletedItem);
    return !1 === result.modified ? null : result.modified.updates[0];
  }
  _applyRemoteInsert(op) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    const key = op.parentKey,
      existingItemIndex = this._indexOfPosition(key);
    -1 !== existingItemIndex && this._shiftItemPosition(existingItemIndex, key);
    const { newItem: newItem, newIndex: newIndex } =
      this._createAttachItemAndSort(op, key);
    return {
      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
      reverse: [],
    };
  }
  _applyInsertAck(op) {
    const existingItem = this._items.find((item) => item._id === op.id),
      key = op.parentKey,
      itemIndexAtPosition = this._indexOfPosition(key);
    if (existingItem) {
      if (existingItem._parentKey === key) return { modified: !1 };
      {
        const oldPositionIndex = this._items.indexOf(existingItem);
        -1 !== itemIndexAtPosition &&
          this._shiftItemPosition(itemIndexAtPosition, key),
          existingItem._setParentLink(this, key),
          this._sortItems();
        const newIndex = this._indexOfPosition(key);
        return newIndex === oldPositionIndex
          ? { modified: !1 }
          : {
              modified: makeUpdate(this, [
                moveDelta(oldPositionIndex, newIndex, existingItem),
              ]),
              reverse: [],
            };
      }
    }
    {
      const orphan = nn(this._doc).getItem(op.id);
      if (orphan && this._implicitlyDeletedItems.has(orphan)) {
        orphan._setParentLink(this, key),
          this._implicitlyDeletedItems.delete(orphan),
          this._insertAndSort(orphan);
        return {
          modified: makeUpdate(this, [
            insertDelta(this._indexOfPosition(key), orphan),
          ]),
          reverse: [],
        };
      }
      {
        -1 !== itemIndexAtPosition &&
          this._shiftItemPosition(itemIndexAtPosition, key);
        const { newItem: newItem, newIndex: newIndex } =
          this._createAttachItemAndSort(op, key);
        return {
          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
          reverse: [],
        };
      }
    }
  }
  _applyInsertUndoRedo(op) {
    var _a;
    const { id: id, parentKey: key } = op,
      child = creationOpToLiveNode(op);
    if (
      void 0 !==
      (null === (_a = this._doc) || void 0 === _a ? void 0 : _a.getItem(id))
    )
      return { modified: !1 };
    child._attach(id, nn(this._doc)), child._setParentLink(this, key);
    const existingItemIndex = this._indexOfPosition(key);
    let newKey = key;
    if (-1 !== existingItemIndex) {
      (newKey = makePosition(
        this._items[existingItemIndex]
          ? this._items[existingItemIndex]._getParentKeyOrThrow()
          : void 0,
        this._items[existingItemIndex + 1]
          ? this._items[existingItemIndex + 1]._getParentKeyOrThrow()
          : void 0
      )),
        child._setParentLink(this, newKey);
    }
    this._insertAndSort(child);
    return {
      modified: makeUpdate(this, [
        insertDelta(this._indexOfPosition(newKey), child),
      ]),
      reverse: [{ type: OpCode.DELETE_CRDT, id: id }],
    };
  }
  _applySetUndoRedo(op) {
    var _a;
    const { id: id, parentKey: key } = op,
      child = creationOpToLiveNode(op);
    if (
      void 0 !==
      (null === (_a = this._doc) || void 0 === _a ? void 0 : _a.getItem(id))
    )
      return { modified: !1 };
    this._unacknowledgedSets.set(key, nn(op.opId));
    const indexOfItemWithSameKey = this._indexOfPosition(key);
    child._attach(id, nn(this._doc)), child._setParentLink(this, key);
    const newKey = key;
    if (-1 !== indexOfItemWithSameKey) {
      const existingItem = this._items[indexOfItemWithSameKey];
      existingItem._detach(), (this._items[indexOfItemWithSameKey] = child);
      const reverse = existingItem._serialize(nn(this._id), key, this._doc);
      addIntentAndDeletedIdToOperation(reverse, op.id);
      const delta = [setDelta(indexOfItemWithSameKey, child)],
        deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
      return (
        deletedDelta && delta.push(deletedDelta),
        { modified: makeUpdate(this, delta), reverse: reverse }
      );
    }
    {
      this._insertAndSort(child),
        this._detachItemAssociatedToSetOperation(op.deletedId);
      const newIndex = this._indexOfPosition(newKey);
      return {
        reverse: [{ type: OpCode.DELETE_CRDT, id: id }],
        modified: makeUpdate(this, [insertDelta(newIndex, child)]),
      };
    }
  }
  _attachChild(op, source) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    if ("set" === op.intent) {
      if (source === OpSource.REMOTE) return this._applySetRemote(op);
      if (source === OpSource.UNDOREDO_RECONNECT)
        return this._applySetUndoRedo(op);
      if (source === OpSource.ACK) return this._applySetAck(op);
    }
    return source === OpSource.REMOTE
      ? this._applyRemoteInsert(op)
      : source === OpSource.ACK
      ? this._applyInsertAck(op)
      : this._applyInsertUndoRedo(op);
  }
  _detachChild(child) {
    if (child) {
      const parentKey = nn(child._parentKey),
        reverse = child._serialize(nn(this._id), parentKey, this._doc),
        indexToDelete = this._items.indexOf(child);
      return -1 === indexToDelete
        ? { modified: !1 }
        : (this._items.splice(indexToDelete, 1),
          child._detach(),
          {
            modified: makeUpdate(this, [deleteDelta(indexToDelete)]),
            reverse: reverse,
          });
    }
    return { modified: !1 };
  }
  _applySetChildKeyRemote(newKey, child) {
    var _a;
    if (this._implicitlyDeletedItems.has(child)) {
      this._implicitlyDeletedItems.delete(child),
        child._setParentLink(this, newKey),
        this._insertAndSort(child);
      return {
        modified: makeUpdate(this, [
          insertDelta(this._items.indexOf(child), child),
        ]),
        reverse: [],
      };
    }
    if (newKey === child._parentKey) return { modified: !1 };
    const existingItemIndex = this._indexOfPosition(newKey);
    if (-1 === existingItemIndex) {
      const previousIndex = this._items.indexOf(child);
      child._setParentLink(this, newKey), this._sortItems();
      const newIndex = this._items.indexOf(child);
      return newIndex === previousIndex
        ? { modified: !1 }
        : {
            modified: makeUpdate(this, [
              moveDelta(previousIndex, newIndex, child),
            ]),
            reverse: [],
          };
    }
    {
      this._items[existingItemIndex]._setParentLink(
        this,
        makePosition(
          newKey,
          null === (_a = this._items[existingItemIndex + 1]) || void 0 === _a
            ? void 0
            : _a._getParentKeyOrThrow()
        )
      );
      const previousIndex = this._items.indexOf(child);
      child._setParentLink(this, newKey), this._sortItems();
      const newIndex = this._items.indexOf(child);
      return newIndex === previousIndex
        ? { modified: !1 }
        : {
            modified: makeUpdate(this, [
              moveDelta(previousIndex, newIndex, child),
            ]),
            reverse: [],
          };
    }
  }
  _applySetChildKeyAck(newKey, child) {
    var _a, _b;
    const previousKey = nn(child._parentKey);
    if (this._implicitlyDeletedItems.has(child)) {
      const existingItemIndex = this._indexOfPosition(newKey);
      return (
        this._implicitlyDeletedItems.delete(child),
        -1 !== existingItemIndex &&
          this._items[existingItemIndex]._setParentLink(
            this,
            makePosition(
              newKey,
              null === (_a = this._items[existingItemIndex + 1]) ||
                void 0 === _a
                ? void 0
                : _a._getParentKeyOrThrow()
            )
          ),
        child._setParentLink(this, newKey),
        this._insertAndSort(child),
        { modified: !1 }
      );
    }
    {
      if (newKey === previousKey) return { modified: !1 };
      const previousIndex = this._items.indexOf(child),
        existingItemIndex = this._indexOfPosition(newKey);
      -1 !== existingItemIndex &&
        this._items[existingItemIndex]._setParentLink(
          this,
          makePosition(
            newKey,
            null === (_b = this._items[existingItemIndex + 1]) || void 0 === _b
              ? void 0
              : _b._getParentKeyOrThrow()
          )
        ),
        child._setParentLink(this, newKey),
        this._sortItems();
      const newIndex = this._items.indexOf(child);
      return previousIndex === newIndex
        ? { modified: !1 }
        : {
            modified: makeUpdate(this, [
              moveDelta(previousIndex, newIndex, child),
            ]),
            reverse: [],
          };
    }
  }
  _applySetChildKeyUndoRedo(newKey, child) {
    var _a;
    const previousKey = nn(child._parentKey),
      previousIndex = this._items.indexOf(child),
      existingItemIndex = this._indexOfPosition(newKey);
    -1 !== existingItemIndex &&
      this._items[existingItemIndex]._setParentLink(
        this,
        makePosition(
          newKey,
          null === (_a = this._items[existingItemIndex + 1]) || void 0 === _a
            ? void 0
            : _a._getParentKeyOrThrow()
        )
      ),
      child._setParentLink(this, newKey),
      this._sortItems();
    const newIndex = this._items.indexOf(child);
    return previousIndex === newIndex
      ? { modified: !1 }
      : {
          modified: makeUpdate(this, [
            moveDelta(previousIndex, newIndex, child),
          ]),
          reverse: [
            {
              type: OpCode.SET_PARENT_KEY,
              id: nn(child._id),
              parentKey: previousKey,
            },
          ],
        };
  }
  _setChildKey(newKey, child, source) {
    return source === OpSource.REMOTE
      ? this._applySetChildKeyRemote(newKey, child)
      : source === OpSource.ACK
      ? this._applySetChildKeyAck(newKey, child)
      : this._applySetChildKeyUndoRedo(newKey, child);
  }
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
  _toSerializedCrdt() {
    if ("HasParent" !== this.parent.type)
      throw new Error("Cannot serialize LiveList if parent is missing");
    return {
      type: CrdtType.LIST,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key,
    };
  }
  get length() {
    return this._items.length;
  }
  push(element) {
    return this.insert(element, this.length);
  }
  insert(element, index) {
    if (index < 0 || index > this._items.length)
      throw new Error(
        `Cannot insert list item at index "${index}". index should be between 0 and ${this._items.length}`
      );
    const position = makePosition(
        this._items[index - 1]
          ? this._items[index - 1]._getParentKeyOrThrow()
          : void 0,
        this._items[index] ? this._items[index]._getParentKeyOrThrow() : void 0
      ),
      value = lsonToLiveNode(element);
    if (
      (value._setParentLink(this, position),
      this._insertAndSort(value),
      this._doc && this._id)
    ) {
      const id = this._doc.generateId();
      value._attach(id, this._doc),
        this._doc.dispatch(
          value._serialize(this._id, position, this._doc),
          [{ type: OpCode.DELETE_CRDT, id: id }],
          new Map([[this._id, makeUpdate(this, [insertDelta(index, value)])]])
        );
    }
  }
  move(index, targetIndex) {
    if (targetIndex < 0) throw new Error("targetIndex cannot be less than 0");
    if (targetIndex >= this._items.length)
      throw new Error(
        "targetIndex cannot be greater or equal than the list length"
      );
    if (index < 0) throw new Error("index cannot be less than 0");
    if (index >= this._items.length)
      throw new Error("index cannot be greater or equal than the list length");
    let beforePosition = null,
      afterPosition = null;
    index < targetIndex
      ? ((afterPosition =
          targetIndex === this._items.length - 1
            ? void 0
            : this._items[targetIndex + 1]._getParentKeyOrThrow()),
        (beforePosition = this._items[targetIndex]._getParentKeyOrThrow()))
      : ((afterPosition = this._items[targetIndex]._getParentKeyOrThrow()),
        (beforePosition =
          0 === targetIndex
            ? void 0
            : this._items[targetIndex - 1]._getParentKeyOrThrow()));
    const position = makePosition(beforePosition, afterPosition),
      item = this._items[index],
      previousPosition = item._getParentKeyOrThrow();
    if (
      (item._setParentLink(this, position),
      this._sortItems(),
      this._doc && this._id)
    ) {
      const storageUpdates = new Map([
        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])],
      ]);
      this._doc.dispatch(
        [
          {
            type: OpCode.SET_PARENT_KEY,
            id: nn(item._id),
            opId: this._doc.generateOpId(),
            parentKey: position,
          },
        ],
        [
          {
            type: OpCode.SET_PARENT_KEY,
            id: nn(item._id),
            parentKey: previousPosition,
          },
        ],
        storageUpdates
      );
    }
  }
  delete(index) {
    if (index < 0 || index >= this._items.length)
      throw new Error(
        `Cannot delete list item at index "${index}". index should be between 0 and ${
          this._items.length - 1
        }`
      );
    const item = this._items[index];
    if ((item._detach(), this._items.splice(index, 1), this._doc)) {
      const childRecordId = item._id;
      if (childRecordId) {
        const storageUpdates = new Map();
        storageUpdates.set(
          nn(this._id),
          makeUpdate(this, [deleteDelta(index)])
        ),
          this._doc.dispatch(
            [
              {
                id: childRecordId,
                opId: this._doc.generateOpId(),
                type: OpCode.DELETE_CRDT,
              },
            ],
            item._serialize(nn(this._id), item._getParentKeyOrThrow()),
            storageUpdates
          );
      }
    }
  }
  clear() {
    if (this._doc) {
      const ops = [],
        reverseOps = [],
        updateDelta = [];
      for (const item of this._items) {
        item._detach();
        const childId = item._id;
        childId &&
          (ops.push({
            type: OpCode.DELETE_CRDT,
            id: childId,
            opId: this._doc.generateOpId(),
          }),
          reverseOps.push(
            ...item._serialize(nn(this._id), item._getParentKeyOrThrow())
          ),
          updateDelta.push(deleteDelta(0)));
      }
      this._items = [];
      const storageUpdates = new Map();
      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta)),
        this._doc.dispatch(ops, reverseOps, storageUpdates);
    } else {
      for (const item of this._items) item._detach();
      this._items = [];
    }
  }
  set(index, item) {
    if (index < 0 || index >= this._items.length)
      throw new Error(
        `Cannot set list item at index "${index}". index should be between 0 and ${
          this._items.length - 1
        }`
      );
    const existingItem = this._items[index],
      position = existingItem._getParentKeyOrThrow(),
      existingId = existingItem._id;
    existingItem._detach();
    const value = lsonToLiveNode(item);
    if (
      (value._setParentLink(this, position),
      (this._items[index] = value),
      this._doc && this._id)
    ) {
      const id = this._doc.generateId();
      value._attach(id, this._doc);
      const storageUpdates = new Map();
      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));
      const ops = value._serialize(this._id, position, this._doc);
      addIntentAndDeletedIdToOperation(ops, existingId),
        this._unacknowledgedSets.set(position, nn(ops[0].opId));
      const reverseOps = existingItem._serialize(this._id, position, void 0);
      addIntentAndDeletedIdToOperation(reverseOps, id),
        this._doc.dispatch(ops, reverseOps, storageUpdates);
    }
  }
  toArray() {
    return this._items.map((entry) => liveNodeToLson(entry));
  }
  every(predicate) {
    return this.toArray().every(predicate);
  }
  filter(predicate) {
    return this.toArray().filter(predicate);
  }
  find(predicate) {
    return this.toArray().find(predicate);
  }
  findIndex(predicate) {
    return this.toArray().findIndex(predicate);
  }
  forEach(callbackfn) {
    return this.toArray().forEach(callbackfn);
  }
  get(index) {
    if (!(index < 0 || index >= this._items.length))
      return liveNodeToLson(this._items[index]);
  }
  indexOf(searchElement, fromIndex) {
    return this.toArray().indexOf(searchElement, fromIndex);
  }
  lastIndexOf(searchElement, fromIndex) {
    return this.toArray().lastIndexOf(searchElement, fromIndex);
  }
  map(callback) {
    return this._items.map((entry, i) => callback(liveNodeToLson(entry), i));
  }
  some(predicate) {
    return this.toArray().some(predicate);
  }
  [Symbol.iterator]() {
    return new LiveListIterator(this._items);
  }
  _createAttachItemAndSort(op, key) {
    const newItem = creationOpToLiveNode(op);
    newItem._attach(op.id, nn(this._doc)),
      newItem._setParentLink(this, key),
      this._insertAndSort(newItem);
    return { newItem: newItem, newIndex: this._indexOfPosition(key) };
  }
  _shiftItemPosition(index, key) {
    var _a;
    const shiftedPosition = makePosition(
      key,
      this._items.length > index + 1
        ? null === (_a = this._items[index + 1]) || void 0 === _a
          ? void 0
          : _a._getParentKeyOrThrow()
        : void 0
    );
    this._items[index]._setParentLink(this, shiftedPosition);
  }
}
class LiveListIterator {
  constructor(items) {
    this._innerIterator = items[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const result = this._innerIterator.next();
    if (result.done) return { done: !0, value: void 0 };
    return { value: liveNodeToLson(result.value) };
  }
}
function makeUpdate(liveList, deltaUpdates) {
  return { node: liveList, type: "LiveList", updates: deltaUpdates };
}
function setDelta(index, item) {
  return {
    index: index,
    type: "set",
    item: item instanceof LiveRegister ? item.data : item,
  };
}
function deleteDelta(index) {
  return { index: index, type: "delete" };
}
function insertDelta(index, item) {
  return {
    index: index,
    type: "insert",
    item: item instanceof LiveRegister ? item.data : item,
  };
}
function moveDelta(previousIndex, index, item) {
  return {
    index: index,
    type: "move",
    previousIndex: previousIndex,
    item: item instanceof LiveRegister ? item.data : item,
  };
}
function addIntentAndDeletedIdToOperation(ops, deletedId) {
  if (0 === ops.length)
    throw new Error(
      "Internal error. Serialized LiveStructure should have at least 1 operation"
    );
  const firstOp = ops[0];
  (firstOp.intent = "set"), (firstOp.deletedId = deletedId);
}
class LiveMap extends AbstractCrdt {
  constructor(entries) {
    if (
      (super(),
      errorIf(
        null === entries,
        "Support for calling `new LiveMap(null)` will be removed in @liveblocks/client 0.18. Please call as `new LiveMap()`, or `new LiveMap([])`."
      ),
      (this.unacknowledgedSet = new Map()),
      entries)
    ) {
      const mappedEntries = [];
      for (const entry of entries) {
        const value = lsonToLiveNode(entry[1]);
        value._setParentLink(this, entry[0]),
          mappedEntries.push([entry[0], value]);
      }
      this._map = new Map(mappedEntries);
    } else this._map = new Map();
  }
  _serialize(parentId, parentKey, doc) {
    if (null == this._id)
      throw new Error("Cannot serialize item is not attached");
    const ops = [],
      op = {
        id: this._id,
        opId: null == doc ? void 0 : doc.generateOpId(),
        type: OpCode.CREATE_MAP,
        parentId: parentId,
        parentKey: parentKey,
      };
    ops.push(op);
    for (const [key, value] of this._map)
      ops.push(...value._serialize(this._id, key, doc));
    return ops;
  }
  static _deserialize([id, _item], parentToChildren, doc) {
    const map = new LiveMap();
    map._attach(id, doc);
    const children = parentToChildren.get(id);
    if (null == children) return map;
    for (const [id, crdt] of children) {
      const child = deserialize([id, crdt], parentToChildren, doc);
      child._setParentLink(map, crdt.parentKey),
        map._map.set(crdt.parentKey, child);
    }
    return map;
  }
  _attach(id, doc) {
    super._attach(id, doc);
    for (const [_key, value] of this._map)
      isLiveNode(value) && value._attach(doc.generateId(), doc);
  }
  _attachChild(op, source) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    const { id: id, parentKey: parentKey, opId: opId } = op,
      key = parentKey,
      child = creationOpToLiveNode(op);
    if (void 0 !== this._doc.getItem(id)) return { modified: !1 };
    if (source === OpSource.ACK) {
      const lastUpdateOpId = this.unacknowledgedSet.get(key);
      if (lastUpdateOpId === opId)
        return this.unacknowledgedSet.delete(key), { modified: !1 };
      if (null != lastUpdateOpId) return { modified: !1 };
    } else source === OpSource.REMOTE && this.unacknowledgedSet.delete(key);
    const previousValue = this._map.get(key);
    let reverse;
    if (previousValue) {
      const thisId = nn(this._id);
      (reverse = previousValue._serialize(thisId, key)),
        previousValue._detach();
    } else reverse = [{ type: OpCode.DELETE_CRDT, id: id }];
    return (
      child._setParentLink(this, key),
      child._attach(id, this._doc),
      this._map.set(key, child),
      {
        modified: {
          node: this,
          type: "LiveMap",
          updates: { [key]: { type: "update" } },
        },
        reverse: reverse,
      }
    );
  }
  _detach() {
    super._detach();
    for (const item of this._map.values()) item._detach();
  }
  _detachChild(child) {
    const id = nn(this._id),
      parentKey = nn(child._parentKey),
      reverse = child._serialize(id, parentKey, this._doc);
    for (const [key, value] of this._map)
      value === child && this._map.delete(key);
    child._detach();
    return {
      modified: {
        node: this,
        type: "LiveMap",
        updates: { [parentKey]: { type: "delete" } },
      },
      reverse: reverse,
    };
  }
  _toSerializedCrdt() {
    if ("HasParent" !== this.parent.type)
      throw new Error("Cannot serialize LiveMap if parent is missing");
    return {
      type: CrdtType.MAP,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key,
    };
  }
  get(key) {
    const value = this._map.get(key);
    if (null != value) return liveNodeToLson(value);
  }
  set(key, value) {
    const oldValue = this._map.get(key);
    oldValue && oldValue._detach();
    const item = lsonToLiveNode(value);
    if (
      (item._setParentLink(this, key),
      this._map.set(key, item),
      this._doc && this._id)
    ) {
      const id = this._doc.generateId();
      item._attach(id, this._doc);
      const storageUpdates = new Map();
      storageUpdates.set(this._id, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "update" } },
      });
      const ops = item._serialize(this._id, key, this._doc);
      this.unacknowledgedSet.set(key, nn(ops[0].opId)),
        this._doc.dispatch(
          item._serialize(this._id, key, this._doc),
          oldValue
            ? oldValue._serialize(this._id, key)
            : [{ type: OpCode.DELETE_CRDT, id: id }],
          storageUpdates
        );
    }
  }
  get size() {
    return this._map.size;
  }
  has(key) {
    return this._map.has(key);
  }
  delete(key) {
    const item = this._map.get(key);
    if (null == item) return !1;
    if ((item._detach(), this._map.delete(key), this._doc && item._id)) {
      const thisId = nn(this._id),
        storageUpdates = new Map();
      storageUpdates.set(thisId, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "delete" } },
      }),
        this._doc.dispatch(
          [
            {
              type: OpCode.DELETE_CRDT,
              id: item._id,
              opId: this._doc.generateOpId(),
            },
          ],
          item._serialize(thisId, key),
          storageUpdates
        );
    }
    return !0;
  }
  entries() {
    const innerIterator = this._map.entries();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done) return { done: !0, value: void 0 };
        return {
          value: [
            iteratorValue.value[0],
            liveNodeToLson(iteratorValue.value[1]),
          ],
        };
      },
    };
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  keys() {
    return this._map.keys();
  }
  values() {
    const innerIterator = this._map.values();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done) return { done: !0, value: void 0 };
        return { value: liveNodeToLson(iteratorValue.value) };
      },
    };
  }
  forEach(callback) {
    for (const entry of this) callback(entry[1], entry[0], this);
  }
}
class LiveObject extends AbstractCrdt {
  constructor(obj = {}) {
    super(), (this._propToLastUpdate = new Map());
    for (const key in obj) {
      const value = obj[key];
      void 0 !== value && isLiveNode(value) && value._setParentLink(this, key);
    }
    this._map = new Map(Object.entries(obj));
  }
  _serialize(parentId, parentKey, doc) {
    if (null == this._id)
      throw new Error("Cannot serialize item is not attached");
    const opId = null == doc ? void 0 : doc.generateOpId(),
      ops = [],
      op =
        void 0 !== parentId && void 0 !== parentKey
          ? {
              type: OpCode.CREATE_OBJECT,
              id: this._id,
              opId: opId,
              parentId: parentId,
              parentKey: parentKey,
              data: {},
            }
          : { type: OpCode.CREATE_OBJECT, id: this._id, opId: opId, data: {} };
    ops.push(op);
    for (const [key, value] of this._map)
      isLiveNode(value)
        ? ops.push(...value._serialize(this._id, key, doc))
        : (op.data[key] = value);
    return ops;
  }
  static _deserialize([id, item], parentToChildren, doc) {
    const liveObj = new LiveObject(item.data);
    return (
      liveObj._attach(id, doc),
      this._deserializeChildren(liveObj, parentToChildren, doc)
    );
  }
  static _deserializeChildren(liveObj, parentToChildren, doc) {
    const children = parentToChildren.get(nn(liveObj._id));
    if (null == children) return liveObj;
    for (const [id, crdt] of children) {
      const child = deserializeToLson([id, crdt], parentToChildren, doc);
      isLiveStructure(child) && child._setParentLink(liveObj, crdt.parentKey),
        liveObj._map.set(crdt.parentKey, child);
    }
    return liveObj;
  }
  _attach(id, doc) {
    super._attach(id, doc);
    for (const [_key, value] of this._map)
      isLiveNode(value) && value._attach(doc.generateId(), doc);
  }
  _attachChild(op, source) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    const { id: id, opId: opId, parentKey: key } = op,
      child = creationOpToLson(op);
    if (void 0 !== this._doc.getItem(id))
      return (
        this._propToLastUpdate.get(key) === opId &&
          this._propToLastUpdate.delete(key),
        { modified: !1 }
      );
    if (source === OpSource.UNDOREDO_RECONNECT)
      this._propToLastUpdate.set(key, nn(opId));
    else if (void 0 !== this._propToLastUpdate.get(key))
      return this._propToLastUpdate.get(key) === opId
        ? (this._propToLastUpdate.delete(key), { modified: !1 })
        : { modified: !1 };
    const thisId = nn(this._id),
      previousValue = this._map.get(key);
    let reverse;
    return (
      isLiveNode(previousValue)
        ? ((reverse = previousValue._serialize(thisId, key)),
          previousValue._detach())
        : (reverse =
            void 0 === previousValue
              ? [{ type: OpCode.DELETE_OBJECT_KEY, id: thisId, key: key }]
              : [
                  {
                    type: OpCode.UPDATE_OBJECT,
                    id: thisId,
                    data: { [key]: previousValue },
                  },
                ]),
      this._map.set(key, child),
      isLiveStructure(child) &&
        (child._setParentLink(this, key), child._attach(id, this._doc)),
      {
        reverse: reverse,
        modified: {
          node: this,
          type: "LiveObject",
          updates: { [key]: { type: "update" } },
        },
      }
    );
  }
  _detachChild(child) {
    if (child) {
      const id = nn(this._id),
        parentKey = nn(child._parentKey),
        reverse = child._serialize(id, parentKey, this._doc);
      for (const [key, value] of this._map)
        value === child && this._map.delete(key);
      child._detach();
      return {
        modified: {
          node: this,
          type: "LiveObject",
          updates: { [parentKey]: { type: "delete" } },
        },
        reverse: reverse,
      };
    }
    return { modified: !1 };
  }
  _detach() {
    super._detach();
    for (const value of this._map.values())
      isLiveNode(value) && value._detach();
  }
  _apply(op, isLocal) {
    return op.type === OpCode.UPDATE_OBJECT
      ? this._applyUpdate(op, isLocal)
      : op.type === OpCode.DELETE_OBJECT_KEY
      ? this._applyDeleteObjectKey(op)
      : super._apply(op, isLocal);
  }
  _toSerializedCrdt() {
    const data = {};
    for (const [key, value] of this._map)
      isLiveNode(value) || (data[key] = value);
    return "HasParent" === this.parent.type && this.parent.node._id
      ? {
          type: CrdtType.OBJECT,
          parentId: this.parent.node._id,
          parentKey: this.parent.key,
          data: data,
        }
      : { type: CrdtType.OBJECT, data: data };
  }
  _applyUpdate(op, isLocal) {
    let isModified = !1;
    const id = nn(this._id),
      reverse = [],
      reverseUpdate = { type: OpCode.UPDATE_OBJECT, id: id, data: {} };
    reverse.push(reverseUpdate);
    for (const key in op.data) {
      const oldValue = this._map.get(key);
      isLiveNode(oldValue)
        ? (reverse.push(...oldValue._serialize(id, key)), oldValue._detach())
        : void 0 !== oldValue
        ? (reverseUpdate.data[key] = oldValue)
        : void 0 === oldValue &&
          reverse.push({ type: OpCode.DELETE_OBJECT_KEY, id: id, key: key });
    }
    const updateDelta = {};
    for (const key in op.data) {
      const value = op.data[key];
      if (void 0 === value) continue;
      if (isLocal) this._propToLastUpdate.set(key, nn(op.opId));
      else {
        if (null != this._propToLastUpdate.get(key)) {
          if (this._propToLastUpdate.get(key) === op.opId) {
            this._propToLastUpdate.delete(key);
            continue;
          }
          continue;
        }
        isModified = !0;
      }
      const oldValue = this._map.get(key);
      isLiveNode(oldValue) && oldValue._detach(),
        (isModified = !0),
        (updateDelta[key] = { type: "update" }),
        this._map.set(key, value);
    }
    return (
      0 !== Object.keys(reverseUpdate.data).length &&
        reverse.unshift(reverseUpdate),
      isModified
        ? {
            modified: { node: this, type: "LiveObject", updates: updateDelta },
            reverse: reverse,
          }
        : { modified: !1 }
    );
  }
  _applyDeleteObjectKey(op) {
    const key = op.key;
    if (!1 === this._map.has(key)) return { modified: !1 };
    if (void 0 !== this._propToLastUpdate.get(key)) return { modified: !1 };
    const oldValue = this._map.get(key),
      id = nn(this._id);
    let reverse = [];
    return (
      isLiveNode(oldValue)
        ? ((reverse = oldValue._serialize(id, op.key)), oldValue._detach())
        : void 0 !== oldValue &&
          (reverse = [
            { type: OpCode.UPDATE_OBJECT, id: id, data: { [key]: oldValue } },
          ]),
      this._map.delete(key),
      {
        modified: {
          node: this,
          type: "LiveObject",
          updates: { [op.key]: { type: "delete" } },
        },
        reverse: reverse,
      }
    );
  }
  toObject() {
    return (function (iterable) {
      const obj = {};
      for (const [key, val] of iterable) obj[key] = val;
      return obj;
    })(this._map);
  }
  set(key, value) {
    this.update({ [key]: value });
  }
  get(key) {
    return this._map.get(key);
  }
  delete(key) {
    const keyAsString = key,
      oldValue = this._map.get(keyAsString);
    if (void 0 === oldValue) return;
    if (null == this._doc || null == this._id)
      return (
        isLiveNode(oldValue) && oldValue._detach(),
        void this._map.delete(keyAsString)
      );
    let reverse;
    isLiveNode(oldValue)
      ? (oldValue._detach(),
        (reverse = oldValue._serialize(this._id, keyAsString)))
      : (reverse = [
          {
            type: OpCode.UPDATE_OBJECT,
            data: { [keyAsString]: oldValue },
            id: this._id,
          },
        ]),
      this._map.delete(keyAsString);
    const storageUpdates = new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: { [key]: { type: "delete" } },
    }),
      this._doc.dispatch(
        [
          {
            type: OpCode.DELETE_OBJECT_KEY,
            key: keyAsString,
            id: this._id,
            opId: this._doc.generateOpId(),
          },
        ],
        reverse,
        storageUpdates
      );
  }
  update(overrides) {
    if (null == this._doc || null == this._id) {
      for (const key in overrides) {
        const newValue = overrides[key];
        if (void 0 === newValue) continue;
        const oldValue = this._map.get(key);
        isLiveNode(oldValue) && oldValue._detach(),
          isLiveNode(newValue) && newValue._setParentLink(this, key),
          this._map.set(key, newValue);
      }
      return;
    }
    const ops = [],
      reverseOps = [],
      opId = this._doc.generateOpId(),
      updatedProps = {},
      reverseUpdateOp = { id: this._id, type: OpCode.UPDATE_OBJECT, data: {} },
      updateDelta = {};
    for (const key in overrides) {
      const newValue = overrides[key];
      if (void 0 === newValue) continue;
      const oldValue = this._map.get(key);
      if (
        (isLiveNode(oldValue)
          ? (reverseOps.push(...oldValue._serialize(this._id, key)),
            oldValue._detach())
          : void 0 === oldValue
          ? reverseOps.push({
              type: OpCode.DELETE_OBJECT_KEY,
              id: this._id,
              key: key,
            })
          : (reverseUpdateOp.data[key] = oldValue),
        isLiveNode(newValue))
      ) {
        newValue._setParentLink(this, key),
          newValue._attach(this._doc.generateId(), this._doc);
        const newAttachChildOps = newValue._serialize(this._id, key, this._doc),
          createCrdtOp = newAttachChildOps.find(
            (op) => op.parentId === this._id
          );
        createCrdtOp && this._propToLastUpdate.set(key, nn(createCrdtOp.opId)),
          ops.push(...newAttachChildOps);
      } else
        (updatedProps[key] = newValue), this._propToLastUpdate.set(key, opId);
      this._map.set(key, newValue), (updateDelta[key] = { type: "update" });
    }
    0 !== Object.keys(reverseUpdateOp.data).length &&
      reverseOps.unshift(reverseUpdateOp),
      0 !== Object.keys(updatedProps).length &&
        ops.unshift({
          opId: opId,
          id: this._id,
          type: OpCode.UPDATE_OBJECT,
          data: updatedProps,
        });
    const storageUpdates = new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: updateDelta,
    }),
      this._doc.dispatch(ops, reverseOps, storageUpdates);
  }
}
function remove(array, item) {
  for (let i = 0; i < array.length; i++)
    if (array[i] === item) {
      array.splice(i, 1);
      break;
    }
}
function compact(items) {
  return items.filter((item) => null != item);
}
function creationOpToLiveNode(op) {
  return lsonToLiveNode(creationOpToLson(op));
}
function creationOpToLson(op) {
  switch (op.type) {
    case OpCode.CREATE_REGISTER:
      return op.data;
    case OpCode.CREATE_OBJECT:
      return new LiveObject(op.data);
    case OpCode.CREATE_MAP:
      return new LiveMap();
    case OpCode.CREATE_LIST:
      return new LiveList();
    default:
      return assertNever(0, "Unknown creation Op");
  }
}
function isSameNodeOrChildOf(node, parent) {
  return (
    node === parent ||
    ("HasParent" === node.parent.type &&
      isSameNodeOrChildOf(node.parent.node, parent))
  );
}
function deserialize([id, crdt], parentToChildren, doc) {
  switch (crdt.type) {
    case CrdtType.OBJECT:
      return LiveObject._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.LIST:
      return LiveList._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.MAP:
      return LiveMap._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.REGISTER:
      return LiveRegister._deserialize([id, crdt], parentToChildren, doc);
    default:
      throw new Error("Unexpected CRDT type");
  }
}
function deserializeToLson([id, crdt], parentToChildren, doc) {
  switch (crdt.type) {
    case CrdtType.OBJECT:
      return LiveObject._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.LIST:
      return LiveList._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.MAP:
      return LiveMap._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.REGISTER:
      return crdt.data;
    default:
      throw new Error("Unexpected CRDT type");
  }
}
function isLiveStructure(value) {
  return (
    isLiveList(value) ||
    (function (value) {
      return value instanceof LiveMap;
    })(value) ||
    isLiveObject(value)
  );
}
function isLiveNode(value) {
  return (
    isLiveStructure(value) ||
    (function (value) {
      return value instanceof LiveRegister;
    })(value)
  );
}
function isLiveList(value) {
  return value instanceof LiveList;
}
function isLiveObject(value) {
  return value instanceof LiveObject;
}
function liveNodeToLson(obj) {
  return obj instanceof LiveRegister
    ? obj.data
    : obj instanceof LiveList ||
      obj instanceof LiveMap ||
      obj instanceof LiveObject
    ? obj
    : assertNever(0, "Unknown AbstractCrdt");
}
function lsonToLiveNode(value) {
  return value instanceof LiveObject ||
    value instanceof LiveMap ||
    value instanceof LiveList
    ? value
    : new LiveRegister(value);
}
function getTreesDiffOperations(currentItems, newItems) {
  const ops = [];
  return (
    currentItems.forEach((_, id) => {
      newItems.get(id) || ops.push({ type: OpCode.DELETE_CRDT, id: id });
    }),
    newItems.forEach((crdt, id) => {
      const currentCrdt = currentItems.get(id);
      if (currentCrdt)
        crdt.type === CrdtType.OBJECT &&
          ((currentCrdt.type === CrdtType.OBJECT &&
            JSON.stringify(crdt.data) === JSON.stringify(currentCrdt.data)) ||
            ops.push({ type: OpCode.UPDATE_OBJECT, id: id, data: crdt.data })),
          crdt.parentKey !== currentCrdt.parentKey &&
            ops.push({
              type: OpCode.SET_PARENT_KEY,
              id: id,
              parentKey: nn(crdt.parentKey, "Parent key must not be missing"),
            });
      else
        switch (crdt.type) {
          case CrdtType.REGISTER:
            ops.push({
              type: OpCode.CREATE_REGISTER,
              id: id,
              parentId: crdt.parentId,
              parentKey: crdt.parentKey,
              data: crdt.data,
            });
            break;
          case CrdtType.LIST:
            ops.push({
              type: OpCode.CREATE_LIST,
              id: id,
              parentId: crdt.parentId,
              parentKey: crdt.parentKey,
            });
            break;
          case CrdtType.OBJECT:
            ops.push(
              crdt.parentId
                ? {
                    type: OpCode.CREATE_OBJECT,
                    id: id,
                    parentId: crdt.parentId,
                    parentKey: crdt.parentKey,
                    data: crdt.data,
                  }
                : { type: OpCode.CREATE_OBJECT, id: id, data: crdt.data }
            );
            break;
          case CrdtType.MAP:
            ops.push({
              type: OpCode.CREATE_MAP,
              id: id,
              parentId: crdt.parentId,
              parentKey: crdt.parentKey,
            });
        }
    }),
    ops
  );
}
function mergeStorageUpdates(first, second) {
  return first
    ? "LiveObject" === first.type && "LiveObject" === second.type
      ? (function (first, second) {
          const updates = first.updates;
          for (const [key, value] of entries(second.updates))
            updates[key] = value;
          return Object.assign(Object.assign({}, second), { updates: updates });
        })(first, second)
      : "LiveMap" === first.type && "LiveMap" === second.type
      ? (function (first, second) {
          const updates = first.updates;
          for (const [key, value] of entries(second.updates))
            updates[key] = value;
          return Object.assign(Object.assign({}, second), { updates: updates });
        })(first, second)
      : "LiveList" === first.type && "LiveList" === second.type
      ? (function (first, second) {
          const updates = first.updates;
          return Object.assign(Object.assign({}, second), {
            updates: updates.concat(second.updates),
          });
        })(first, second)
      : second
    : second;
}
function isPlain(value) {
  const type = typeof value;
  return (
    null == value ||
    "string" === type ||
    "boolean" === type ||
    "number" === type ||
    Array.isArray(value) ||
    isPlainObject(value)
  );
}
function isPlainObject(blob) {
  return (
    null !== blob &&
    "object" == typeof blob &&
    "[object Object]" === Object.prototype.toString.call(blob)
  );
}
function findNonSerializableValue(value, path = "") {
  if (!isPlain) return { path: path || "root", value: value };
  if ("object" != typeof value || null === value) return !1;
  for (const [key, nestedValue] of Object.entries(value)) {
    const nestedPath = path ? path + "." + key : key;
    if (!isPlain(nestedValue)) return { path: nestedPath, value: nestedValue };
    if ("object" == typeof nestedValue) {
      const nonSerializableNestedValue = findNonSerializableValue(
        nestedValue,
        nestedPath
      );
      if (nonSerializableNestedValue) return nonSerializableNestedValue;
    }
  }
  return !1;
}
function entries(obj) {
  return Object.entries(obj);
}
function tryParseJson(rawMessage) {
  try {
    return JSON.parse(rawMessage);
  } catch (e) {
    return;
  }
}
function b64decode(b64value) {
  try {
    const formattedValue = b64value.replace(/-/g, "+").replace(/_/g, "/");
    return decodeURIComponent(
      atob(formattedValue)
        .split("")
        .map(function (c) {
          return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
        })
        .join("")
    );
  } catch (err) {
    return atob(b64value);
  }
}
const SCOPES = [
  "websocket:presence",
  "websocket:storage",
  "room:read",
  "room:write",
  "rooms:read",
  "rooms:write",
];
function isTokenExpired(token) {
  const now = Date.now() / 1e3;
  return now > token.exp - 300 || now < token.iat + 300;
}
function isScope(value) {
  return SCOPES.includes(value);
}
function isStringList(value) {
  return Array.isArray(value) && value.every((i) => "string" == typeof i);
}
function isAppOnlyAuthToken(data) {
  return (
    "string" == typeof data.appId &&
    void 0 === data.roomId &&
    isStringList(data.scopes)
  );
}
function isRoomAuthToken(data) {
  return (
    "string" == typeof data.appId &&
    "string" == typeof data.roomId &&
    "number" == typeof data.actor &&
    (void 0 === data.id || "string" == typeof data.id) &&
    isStringList(data.scopes) &&
    (void 0 === data.maxConnectionsPerRoom ||
      "number" == typeof data.maxConnectionsPerRoom)
  );
}
function isAuthToken(data) {
  return isAppOnlyAuthToken(data) || isRoomAuthToken(data);
}
function parseJwtToken(token) {
  const tokenParts = token.split(".");
  if (3 !== tokenParts.length)
    throw new Error("Authentication error: invalid JWT token");
  const data = tryParseJson(b64decode(tokenParts[1]));
  if (
    data &&
    (function (data) {
      if (!isPlainObject(data)) return !1;
      const { iat: iat, exp: exp } = data;
      return "number" == typeof iat && "number" == typeof exp;
    })(data)
  )
    return data;
  throw new Error("Authentication error: missing JWT metadata");
}
function parseRoomAuthToken(tokenString) {
  const data = parseJwtToken(tokenString);
  if (data && isRoomAuthToken(data)) {
    return __rest(data, ["maxConnections"]);
  }
  throw new Error(
    "Authentication error: we expected a room token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback"
  );
}
function isJsonScalar(data) {
  return (
    null === data ||
    "string" == typeof data ||
    "number" == typeof data ||
    "boolean" == typeof data
  );
}
function isJsonArray(data) {
  return Array.isArray(data);
}
function isJsonObject(data) {
  return !isJsonScalar(data) && !isJsonArray(data);
}
export {
  isRoomAuthToken as A,
  isScope as B,
  ClientMsgCode as C,
  deprecate as D,
  deprecateIf as E,
  throwUsageError as F,
  comparePosition as G,
  makePosition as H,
  CrdtType as I,
  isJsonScalar as J,
  isChildCrdt as K,
  LiveObject as L,
  b64decode as M,
  OpSource as O,
  ServerMsgCode as S,
  WebsocketCloseCodes as W,
  __rest as _,
  isRoomEventName as a,
  isPlainObject as b,
  isTokenExpired as c,
  isSameNodeOrChildOf as d,
  OpCode as e,
  isLiveList as f,
  getTreesDiffOperations as g,
  isJsonArray as h,
  isLiveNode as i,
  compact as j,
  isRootCrdt as k,
  isJsonObject as l,
  mergeStorageUpdates as m,
  nn as n,
  errorIf as o,
  parseRoomAuthToken as p,
  LiveList as q,
  remove as r,
  LiveMap as s,
  tryParseJson as t,
  LiveRegister as u,
  findNonSerializableValue as v,
  isLiveObject as w,
  assertNever as x,
  isAppOnlyAuthToken as y,
  isAuthToken as z,
};
