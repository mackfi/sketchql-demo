var h=Object.defineProperty;var d=(s,n,r)=>n in s?h(s,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):s[n]=r;var m=(s,n,r)=>(d(s,typeof n!="symbol"?n+"":n,r),r);var t=class{static clamp(n,r,e){return Math.max(r,typeof e!="undefined"?Math.min(n,e):n)}static clampV(n,r,e){return n.map(b=>e?t.clamp(b,r,e):t.clamp(b,r))}static cross(n,r,e){return(r[0]-n[0])*(e[1]-n[1])-(e[0]-n[0])*(r[1]-n[1])}static snap(n,r=1){return[Math.round(n[0]/r)*r,Math.round(n[1]/r)*r]}},u=t;m(u,"neg",n=>[-n[0],-n[1]]),m(u,"add",(n,r)=>[n[0]+r[0],n[1]+r[1]]),m(u,"addScalar",(n,r)=>[n[0]+r,n[1]+r]),m(u,"sub",(n,r)=>[n[0]-r[0],n[1]-r[1]]),m(u,"subScalar",(n,r)=>[n[0]-r,n[1]-r]),m(u,"vec",(n,r)=>[r[0]-n[0],r[1]-n[1]]),m(u,"mul",(n,r)=>[n[0]*r,n[1]*r]),m(u,"mulV",(n,r)=>[n[0]*r[0],n[1]*r[1]]),m(u,"div",(n,r)=>[n[0]/r,n[1]/r]),m(u,"divV",(n,r)=>[n[0]/r[0],n[1]/r[1]]),m(u,"per",n=>[n[1],-n[0]]),m(u,"dpr",(n,r)=>n[0]*r[0]+n[1]*r[1]),m(u,"cpr",(n,r)=>n[0]*r[1]-r[0]*n[1]),m(u,"len2",n=>n[0]*n[0]+n[1]*n[1]),m(u,"len",n=>Math.hypot(n[0],n[1])),m(u,"pry",(n,r)=>t.dpr(n,r)/t.len(r)),m(u,"uni",n=>t.div(n,t.len(n))),m(u,"normalize",n=>t.uni(n)),m(u,"tangent",(n,r)=>t.uni(t.sub(n,r))),m(u,"dist2",(n,r)=>t.len2(t.sub(n,r))),m(u,"dist",(n,r)=>Math.hypot(n[1]-r[1],n[0]-r[0])),m(u,"fastDist",(n,r)=>{let e=[r[0]-n[0],r[1]-n[1]],b=[Math.abs(e[0]),Math.abs(e[1])],a=1/Math.max(b[0],b[1]);return a=a*(1.29289-(b[0]+b[1])*a*.29289),[e[0]*a,e[1]*a]}),m(u,"ang",(n,r)=>Math.atan2(t.cpr(n,r),t.dpr(n,r))),m(u,"angle",(n,r)=>Math.atan2(r[1]-n[1],r[0]-n[0])),m(u,"med",(n,r)=>t.mul(t.add(n,r),.5)),m(u,"rot",(n,r=0)=>[n[0]*Math.cos(r)-n[1]*Math.sin(r),n[0]*Math.sin(r)+n[1]*Math.cos(r)]),m(u,"rotWith",(n,r,e=0)=>{if(e===0)return n;let b=Math.sin(e),a=Math.cos(e),i=n[0]-r[0],o=n[1]-r[1],c=i*a-o*b,l=i*b+o*a;return[c+r[0],l+r[1]]}),m(u,"isEqual",(n,r)=>n[0]===r[0]&&n[1]===r[1]),m(u,"lrp",(n,r,e)=>t.add(n,t.mul(t.sub(r,n),e))),m(u,"int",(n,r,e,b,a=1)=>{let i=(t.clamp(e,b)-e)/(b-e);return t.add(t.mul(n,1-i),t.mul(r,a))}),m(u,"ang3",(n,r,e)=>{let b=t.vec(r,n),a=t.vec(r,e);return t.ang(b,a)}),m(u,"abs",n=>[Math.abs(n[0]),Math.abs(n[1])]),m(u,"rescale",(n,r)=>{let e=t.len(n);return[r*n[0]/e,r*n[1]/e]}),m(u,"isLeft",(n,r,e)=>(r[0]-n[0])*(e[1]-n[1])-(e[0]-n[0])*(r[1]-n[1])),m(u,"clockwise",(n,r,e)=>t.isLeft(n,r,e)>0),m(u,"toFixed",n=>n.map(r=>Math.round(r*100)/100)),m(u,"nearestPointOnLineThroughPoint",(n,r,e)=>t.add(n,t.mul(r,t.pry(t.sub(e,n),r)))),m(u,"distanceToLineThroughPoint",(n,r,e)=>t.dist(e,t.nearestPointOnLineThroughPoint(n,r,e))),m(u,"nearestPointOnLineSegment",(n,r,e,b=!0)=>{let a=t.uni(t.sub(r,n)),i=t.add(n,t.mul(a,t.pry(t.sub(e,n),a)));if(b){if(i[0]<Math.min(n[0],r[0]))return n[0]<r[0]?n:r;if(i[0]>Math.max(n[0],r[0]))return n[0]>r[0]?n:r;if(i[1]<Math.min(n[1],r[1]))return n[1]<r[1]?n:r;if(i[1]>Math.max(n[1],r[1]))return n[1]>r[1]?n:r}return i}),m(u,"distanceToLineSegment",(n,r,e,b=!0)=>t.dist(e,t.nearestPointOnLineSegment(n,r,e,b))),m(u,"nearestPointOnBounds",(n,r)=>[t.clamp(r[0],n.minX,n.maxX),t.clamp(r[1],n.minY,n.maxY)]),m(u,"distanceToBounds",(n,r)=>t.dist(r,t.nearestPointOnBounds(n,r))),m(u,"nudge",(n,r,e)=>t.isEqual(n,r)?n:t.add(n,t.mul(t.uni(t.sub(r,n)),e))),m(u,"nudgeAtAngle",(n,r,e)=>[Math.cos(r)*e+n[0],Math.sin(r)*e+n[1]]),m(u,"toPrecision",(n,r=4)=>[+n[0].toPrecision(r),+n[1].toPrecision(r)]),m(u,"pointsBetween",(n,r,e=6)=>Array.from(Array(e)).map((b,a)=>{let i=a/(e-1),o=Math.min(1,.5+Math.abs(.5-i));return[...t.lrp(n,r,i),o]})),m(u,"slope",(n,r)=>n[0]===r[0]?NaN:(n[1]-r[1])/(n[0]-r[0])),m(u,"max",(...n)=>[Math.max(...n.map(r=>r[0])),Math.max(...n.map(r=>r[1]))]),m(u,"min",(...n)=>[Math.min(...n.map(r=>r[0])),Math.min(...n.map(r=>r[1]))]);var p=u;export{u as Vec,p as default};
//# sourceMappingURL=index.mjs.map
