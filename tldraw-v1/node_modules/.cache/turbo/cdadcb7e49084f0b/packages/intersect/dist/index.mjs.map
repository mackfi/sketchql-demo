{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { Vec } from '@tldraw/vec'\n\nexport type TLIntersection = {\n  didIntersect: boolean\n  message: string\n  points: number[][]\n}\n\nexport interface TLBounds {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  width: number\n  height: number\n  rotation?: number\n}\n\n/**\n * Get an intersection.\n * @param message\n * @param points\n * @internal\n */\nfunction createIntersection(message: string, ...points: number[][]): TLIntersection {\n  const didIntersect = points.length > 0\n  return { didIntersect, message, points }\n}\n\n/**\n *\n * @param point\n * @param size\n * @param rotation\n * @internal\n */\nfunction getRectangleSides(point: number[], size: number[], rotation = 0): [string, number[][]][] {\n  const center = [point[0] + size[0] / 2, point[1] + size[1] / 2]\n  const tl = Vec.rotWith(point, center, rotation)\n  const tr = Vec.rotWith(Vec.add(point, [size[0], 0]), center, rotation)\n  const br = Vec.rotWith(Vec.add(point, size), center, rotation)\n  const bl = Vec.rotWith(Vec.add(point, [0, size[1]]), center, rotation)\n\n  return [\n    ['top', [tl, tr]],\n    ['right', [tr, br]],\n    ['bottom', [br, bl]],\n    ['left', [bl, tl]],\n  ]\n}\n\n/**\n * Get whether angle c lies between angles a and b.\n * @param a\n * @param b\n * @param c\n * @internal\n */\nfunction isAngleBetween(a: number, b: number, c: number): boolean {\n  if (c === a || c === b) return true\n  const PI2 = Math.PI * 2\n  const AB = (b - a + PI2) % PI2\n  const AC = (c - a + PI2) % PI2\n  return AB <= Math.PI !== AC > AB\n}\n\n/* -------------------------------------------------- */\n/*                        Line                        */\n/* -------------------------------------------------- */\n\nexport function intersectLineLine(AB: number[][], PQ: number[][]): number[] | undefined {\n  const slopeAB = Vec.slope(AB[0], AB[1])\n  const slopePQ = Vec.slope(PQ[0], PQ[1])\n\n  if (slopeAB === slopePQ) return undefined\n\n  if (Number.isNaN(slopeAB) && !Number.isNaN(slopePQ)) {\n    return [AB[0][0], (AB[0][0] - PQ[0][0]) * slopePQ + PQ[0][1]]\n  }\n\n  if (Number.isNaN(slopePQ) && !Number.isNaN(slopeAB)) {\n    return [PQ[0][0], (PQ[0][0] - AB[0][0]) * slopeAB + AB[0][1]]\n  }\n\n  const x = (slopeAB * AB[0][0] - slopePQ * PQ[0][0] + PQ[0][1] - AB[0][1]) / (slopeAB - slopePQ)\n  const y = slopePQ * (x - PQ[0][0]) + PQ[0][1]\n\n  return [x, y]\n}\n\n/* -------------------------------------------------- */\n/*                         Ray                        */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersection between a ray and a ray.\n * @param p0 The first ray's point\n * @param n0 The first ray's direction vector.\n * @param p1 The second ray's point.\n * @param n1 The second ray's direction vector.\n */\nexport function intersectRayRay(\n  p0: number[],\n  n0: number[],\n  p1: number[],\n  n1: number[]\n): TLIntersection {\n  const dx = p1[0] - p0[0]\n  const dy = p1[1] - p0[1]\n  const det = n1[0] * n0[1] - n1[1] * n0[0]\n  const u = (dy * n1[0] - dx * n1[1]) / det\n  const v = (dy * n0[0] - dx * n0[1]) / det\n  if (u < 0 || v < 0) return createIntersection('miss')\n\n  const m0 = n0[1] / n0[0]\n  const m1 = n1[1] / n1[0]\n  const b0 = p0[1] - m0 * p0[0]\n  const b1 = p1[1] - m1 * p1[0]\n  const x = (b1 - b0) / (m0 - m1)\n  const y = m0 * x + b0\n\n  return Number.isFinite(x)\n    ? createIntersection('intersection', [x, y])\n    : createIntersection('parallel')\n}\n\n/**\n * Find the intersections between a ray and a line segment.\n * @param origin\n * @param direction\n * @param a1\n * @param a2\n */\nexport function intersectRayLineSegment(\n  origin: number[],\n  direction: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  const [x, y] = origin\n  const [dx, dy] = direction\n  const [x1, y1] = a1\n  const [x2, y2] = a2\n\n  if (dy / dx !== (y2 - y1) / (x2 - x1)) {\n    const d = dx * (y2 - y1) - dy * (x2 - x1)\n    if (d !== 0) {\n      const r = ((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)) / d\n      const s = ((y - y1) * dx - (x - x1) * dy) / d\n      if (r >= 0 && s >= 0 && s <= 1) {\n        return createIntersection('intersection', [x + r * dx, y + r * dy])\n      }\n    }\n  }\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between a ray and a rectangle.\n * @param origin\n * @param direction\n * @param point\n * @param size\n * @param rotation\n */\nexport function intersectRayRectangle(\n  origin: number[],\n  direction: number[],\n  point: number[],\n  size: number[],\n  rotation = 0\n): TLIntersection[] {\n  return intersectRectangleRay(point, size, rotation, origin, direction)\n}\n\n/**\n * Find the intersections between a ray and an ellipse.\n * @param origin\n * @param direction\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectRayEllipse(\n  origin: number[],\n  direction: number[],\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation: number\n): TLIntersection {\n  const a1 = origin\n  const a2 = Vec.mul(direction, 999999999)\n  return intersectLineSegmentEllipse(a1, a2, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between a ray and a bounding box.\n * @param origin\n * @param direction\n * @param bounds\n * @param rotation\n */\nexport function intersectRayBounds(\n  origin: number[],\n  direction: number[],\n  bounds: TLBounds,\n  rotation = 0\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRayRectangle(origin, direction, [minX, minY], [width, height], rotation)\n}\n\n/* -------------------------------------------------- */\n/*                    Line Segment                    */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersection between a line segment and a ray.\n * @param a1\n * @param a2\n * @param origin\n * @param direction\n */\nexport function intersectLineSegmentRay(\n  a1: number[],\n  a2: number[],\n  origin: number[],\n  direction: number[]\n): TLIntersection {\n  return intersectRayLineSegment(origin, direction, a1, a2)\n}\n\n/**\n * Find the intersection between a line segment and a line segment.\n * @param a1\n * @param a2\n * @param b1\n * @param b2\n */\nexport function intersectLineSegmentLineSegment(\n  a1: number[],\n  a2: number[],\n  b1: number[],\n  b2: number[]\n): TLIntersection {\n  const AB = Vec.sub(a1, b1)\n  const BV = Vec.sub(b2, b1)\n  const AV = Vec.sub(a2, a1)\n\n  const ua_t = BV[0] * AB[1] - BV[1] * AB[0]\n  const ub_t = AV[0] * AB[1] - AV[1] * AB[0]\n  const u_b = BV[1] * AV[0] - BV[0] * AV[1]\n\n  if (ua_t === 0 || ub_t === 0) {\n    return createIntersection('coincident')\n  }\n\n  if (u_b === 0) {\n    return createIntersection('parallel')\n  }\n\n  if (u_b !== 0) {\n    const ua = ua_t / u_b\n    const ub = ub_t / u_b\n    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n      return createIntersection('intersection', Vec.add(a1, Vec.mul(AV, ua)))\n    }\n  }\n\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between a line segment and a rectangle.\n * @param a1\n * @param a2\n * @param point\n * @param size\n */\nexport function intersectLineSegmentRectangle(\n  a1: number[],\n  a2: number[],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleLineSegment(point, size, a1, a2)\n}\n\n/**\n * Find the intersections between a line segment and an arc.\n * @param a1\n * @param a2\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectLineSegmentArc(\n  a1: number[],\n  a2: number[],\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection {\n  const sa = Vec.angle(center, start)\n  const ea = Vec.angle(center, end)\n  const ellipseTest = intersectEllipseLineSegment(center, radius, radius, 0, a1, a2)\n\n  if (!ellipseTest.didIntersect) return createIntersection('no intersection')\n\n  const points = ellipseTest.points.filter((point) =>\n    isAngleBetween(sa, ea, Vec.angle(center, point))\n  )\n\n  if (points.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n\n/**\n * Find the intersections between a line segment and a circle.\n * @param a1\n * @param a2\n * @param c\n * @param r\n */\nexport function intersectLineSegmentCircle(\n  a1: number[],\n  a2: number[],\n  c: number[],\n  r: number\n): TLIntersection {\n  const a = (a2[0] - a1[0]) * (a2[0] - a1[0]) + (a2[1] - a1[1]) * (a2[1] - a1[1])\n  const b = 2 * ((a2[0] - a1[0]) * (a1[0] - c[0]) + (a2[1] - a1[1]) * (a1[1] - c[1]))\n  const cc =\n    c[0] * c[0] +\n    c[1] * c[1] +\n    a1[0] * a1[0] +\n    a1[1] * a1[1] -\n    2 * (c[0] * a1[0] + c[1] * a1[1]) -\n    r * r\n\n  const deter = b * b - 4 * a * cc\n\n  if (deter < 0) {\n    return createIntersection('outside')\n  }\n\n  if (deter === 0) {\n    return createIntersection('tangent')\n  }\n\n  const e = Math.sqrt(deter)\n  const u1 = (-b + e) / (2 * a)\n  const u2 = (-b - e) / (2 * a)\n  if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {\n    if ((u1 < 0 && u2 < 0) || (u1 > 1 && u2 > 1)) {\n      return createIntersection('outside')\n    } else {\n      return createIntersection('inside')\n    }\n  }\n\n  const results: number[][] = []\n  if (0 <= u1 && u1 <= 1) results.push(Vec.lrp(a1, a2, u1))\n  if (0 <= u2 && u2 <= 1) results.push(Vec.lrp(a1, a2, u2))\n\n  return createIntersection('intersection', ...results)\n}\n\n/**\n * Find the intersections between a line segment and an ellipse.\n * @param a1\n * @param a2\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectLineSegmentEllipse(\n  a1: number[],\n  a2: number[],\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection {\n  // If the ellipse or line segment are empty, return no tValues.\n  if (rx === 0 || ry === 0 || Vec.isEqual(a1, a2)) {\n    return createIntersection('no intersection')\n  }\n\n  // Get the semimajor and semiminor axes.\n  rx = rx < 0 ? rx : -rx\n  ry = ry < 0 ? ry : -ry\n\n  // Rotate points and translate so the ellipse is centered at the origin.\n  a1 = Vec.sub(Vec.rotWith(a1, center, -rotation), center)\n  a2 = Vec.sub(Vec.rotWith(a2, center, -rotation), center)\n\n  // Calculate the quadratic parameters.\n  const diff = Vec.sub(a2, a1)\n\n  const A = (diff[0] * diff[0]) / rx / rx + (diff[1] * diff[1]) / ry / ry\n  const B = (2 * a1[0] * diff[0]) / rx / rx + (2 * a1[1] * diff[1]) / ry / ry\n  const C = (a1[0] * a1[0]) / rx / rx + (a1[1] * a1[1]) / ry / ry - 1\n\n  // Make a list of t values (normalized points on the line where intersections occur).\n  const tValues: number[] = []\n\n  // Calculate the discriminant.\n  const discriminant = B * B - 4 * A * C\n\n  if (discriminant === 0) {\n    // One real solution.\n    tValues.push(-B / 2 / A)\n  } else if (discriminant > 0) {\n    const root = Math.sqrt(discriminant)\n    // Two real solutions.\n    tValues.push((-B + root) / 2 / A)\n    tValues.push((-B - root) / 2 / A)\n  }\n\n  // Filter to only points that are on the segment.\n  // Solve for points, then counter-rotate points.\n  const points = tValues\n    .filter((t) => t >= 0 && t <= 1)\n    .map((t) => Vec.add(center, Vec.add(a1, Vec.mul(Vec.sub(a2, a1), t))))\n    .map((p) => Vec.rotWith(p, center, rotation))\n\n  return createIntersection('intersection', ...points)\n}\n\n/**\n * Find the intersections between a line segment and a bounding box.\n * @param a1\n * @param a2\n * @param bounds\n */\nexport function intersectLineSegmentBounds(\n  a1: number[],\n  a2: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  return intersectBoundsLineSegment(bounds, a1, a2)\n}\n\n/**\n * Find the intersections between a line segment and a polyline.\n * @param a1\n * @param a2\n * @param points\n */\nexport function intersectLineSegmentPolyline(\n  a1: number[],\n  a2: number[],\n  points: number[][]\n): TLIntersection {\n  const pts: number[][] = []\n\n  for (let i = 1; i < points.length; i++) {\n    const int = intersectLineSegmentLineSegment(a1, a2, points[i - 1], points[i])\n\n    if (int) {\n      pts.push(...int.points)\n    }\n  }\n\n  if (pts.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n/**\n * Find the intersections between a line segment and a closed polygon.\n * @param a1\n * @param a2\n * @param points\n */\nexport function intersectLineSegmentPolygon(\n  a1: number[],\n  a2: number[],\n  points: number[][]\n): TLIntersection {\n  const pts: number[][] = []\n\n  for (let i = 1; i < points.length + 1; i++) {\n    const int = intersectLineSegmentLineSegment(a1, a2, points[i - 1], points[i % points.length])\n\n    if (int) {\n      pts.push(...int.points)\n    }\n  }\n\n  if (pts.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n\n/* -------------------------------------------------- */\n/*                      Rectangle                     */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a rectangle and a ray.\n * @param point\n * @param size\n * @param rotation\n * @param origin\n * @param direction\n */\nexport function intersectRectangleRay(\n  point: number[],\n  size: number[],\n  rotation: number,\n  origin: number[],\n  direction: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size, rotation).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectRayLineSegment(origin, direction, a1, a2)\n\n      if (intersection) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a line segment.\n * @param point\n * @param size\n * @param a1\n * @param a2\n */\nexport function intersectRectangleLineSegment(\n  point: number[],\n  size: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [b1, b2]]) => {\n      const intersection = intersectLineSegmentLineSegment(a1, a2, b1, b2)\n\n      if (intersection) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a rectangle.\n * @param point1\n * @param size1\n * @param point2\n * @param size2\n */\nexport function intersectRectangleRectangle(\n  point1: number[],\n  size1: number[],\n  point2: number[],\n  size2: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point1, size1).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersections = intersectRectangleLineSegment(point2, size2, a1, a2)\n\n      acc.push(\n        ...intersections.map((int) =>\n          createIntersection(`${message} ${int.message}`, ...int.points)\n        )\n      )\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and an arc.\n * @param point\n * @param size\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectRectangleArc(\n  point: number[],\n  size: number[],\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectArcLineSegment(center, radius, start, end, a1, a2)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a circle.\n * @param point\n * @param size\n * @param c\n * @param r\n */\nexport function intersectRectangleCircle(\n  point: number[],\n  size: number[],\n  c: number[],\n  r: number\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentCircle(a1, a2, c, r)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and an ellipse.\n * @param point\n * @param size\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectRectangleEllipse(\n  point: number[],\n  size: number[],\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentEllipse(a1, a2, c, rx, ry, rotation)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a bounding box.\n * @param point\n * @param size\n * @param bounds\n */\nexport function intersectRectangleBounds(\n  point: number[],\n  size: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRectangleRectangle(point, size, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a rectangle and a polyline.\n * @param point\n * @param size\n * @param points\n */\nexport function intersectRectanglePolyline(\n  point: number[],\n  size: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentPolyline(a1, a2, points)\n\n      if (intersection.didIntersect) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n/**\n * Find the intersections between a rectangle and a polygon.\n * @param point\n * @param size\n * @param points\n */\nexport function intersectRectanglePolygon(\n  point: number[],\n  size: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentPolygon(a1, a2, points)\n\n      if (intersection.didIntersect) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/* -------------------------------------------------- */\n/*                         Arc                        */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a arc and a line segment.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param a1\n * @param a2\n */\nexport function intersectArcLineSegment(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentArc(a1, a2, center, radius, start, end)\n}\n\n/**\n * Find the intersections between a arc and a rectangle.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param point\n * @param size\n */\nexport function intersectArcRectangle(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleArc(point, size, center, radius, start, end)\n}\n\n/**\n * Find the intersections between a arc and a bounding box.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param bounds\n */\nexport function intersectArcBounds(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectArcRectangle(center, radius, start, end, [minX, minY], [width, height])\n}\n\n/* -------------------------------------------------- */\n/*                       Circle                       */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a circle and a line segment.\n * @param c\n * @param r\n * @param a1\n * @param a2\n */\nexport function intersectCircleLineSegment(\n  c: number[],\n  r: number,\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentCircle(a1, a2, c, r)\n}\n\n/**\n * Find the intersections between a circle and a circle.\n * @param c1\n * @param r1\n * @param c2\n * @param r2\n */\nexport function intersectCircleCircle(\n  c1: number[],\n  r1: number,\n  c2: number[],\n  r2: number\n): TLIntersection {\n  let dx = c2[0] - c1[0],\n    dy = c2[1] - c1[1]\n\n  const d = Math.sqrt(dx * dx + dy * dy),\n    x = (d * d - r2 * r2 + r1 * r1) / (2 * d),\n    y = Math.sqrt(r1 * r1 - x * x)\n\n  dx /= d\n  dy /= d\n\n  return createIntersection(\n    'intersection',\n    [c1[0] + dx * x - dy * y, c1[1] + dy * x + dx * y],\n    [c1[0] + dx * x + dy * y, c1[1] + dy * x - dx * y]\n  )\n}\n\n/**\n * Find the intersections between a circle and a rectangle.\n * @param c\n * @param r\n * @param point\n * @param size\n */\nexport function intersectCircleRectangle(\n  c: number[],\n  r: number,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleCircle(point, size, c, r)\n}\n\n/**\n * Find the intersections between a circle and a bounding box.\n * @param c\n * @param r\n * @param bounds\n */\nexport function intersectCircleBounds(c: number[], r: number, bounds: TLBounds): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectCircleRectangle(c, r, [minX, minY], [width, height])\n}\n\n/* -------------------------------------------------- */\n/*                       Ellipse                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between an ellipse and a ray.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param point\n * @param direction\n */\nexport function intersectEllipseRay(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  point: number[],\n  direction: number[]\n): TLIntersection {\n  return intersectRayEllipse(point, direction, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and a line segment.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param a1\n * @param a2\n */\nexport function intersectEllipseLineSegment(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0,\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  if (rx === ry) {\n    return intersectLineSegmentCircle(a1, a2, center, rx)\n  }\n\n  return intersectLineSegmentEllipse(a1, a2, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and a rectangle.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param point\n * @param size\n */\nexport function intersectEllipseRectangle(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  if (rx === ry) {\n    return intersectRectangleCircle(point, size, center, rx)\n  }\n\n  return intersectRectangleEllipse(point, size, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and an ellipse.\n * Adapted from https://gist.github.com/drawable/92792f59b6ff8869d8b1\n * @param _c1\n * @param _rx1\n * @param _ry1\n * @param _r1\n * @param _c2\n * @param _rx2\n * @param _ry2\n * @param _r2\n */\nexport function intersectEllipseEllipse(\n  _c1: number[],\n  _rx1: number,\n  _ry1: number,\n  _r1: number,\n  _c2: number[],\n  _rx2: number,\n  _ry2: number,\n  _r2: number\n): TLIntersection {\n  // TODO\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between an ellipse and a circle.\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n * @param c2\n * @param r2\n */\nexport function intersectEllipseCircle(\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  c2: number[],\n  r2: number\n): TLIntersection {\n  return intersectEllipseEllipse(c, rx, ry, rotation, c2, r2, r2, 0)\n}\n\n/**\n * Find the intersections between an ellipse and a bounding box.\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n * @param bounds\n */\nexport function intersectEllipseBounds(\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectEllipseRectangle(c, rx, ry, rotation, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a ray.\n * @param bounds\n * @param origin\n * @param direction\n */\nexport function intersectBoundsRay(\n  bounds: TLBounds,\n  origin: number[],\n  direction: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRayRectangle(origin, direction, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a line segment.\n * @param bounds\n * @param a1\n * @param a2\n */\nexport function intersectBoundsLineSegment(\n  bounds: TLBounds,\n  a1: number[],\n  a2: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectLineSegmentRectangle(a1, a2, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a rectangle.\n * @param bounds\n * @param point\n * @param size\n */\nexport function intersectBoundsRectangle(\n  bounds: TLBounds,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRectangleRectangle(point, size, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a bounding box.\n * @param bounds1\n * @param bounds2\n */\nexport function intersectBoundsBounds(bounds1: TLBounds, bounds2: TLBounds): TLIntersection[] {\n  return intersectRectangleRectangle(\n    [bounds1.minX, bounds1.minY],\n    [bounds1.width, bounds1.height],\n    [bounds2.minX, bounds2.minY],\n    [bounds2.width, bounds2.height]\n  )\n}\n\n/**\n * Find the intersections between a bounding box and an arc.\n * @param bounds\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectBoundsArc(\n  bounds: TLBounds,\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectArcRectangle(center, radius, start, end, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a circle.\n * @param bounds\n * @param c\n * @param r\n */\nexport function intersectBoundsCircle(bounds: TLBounds, c: number[], r: number): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectCircleRectangle(c, r, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and an ellipse.\n * @param bounds\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectBoundsEllipse(\n  bounds: TLBounds,\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectEllipseRectangle(c, rx, ry, rotation, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a polyline.\n * @param bounds\n * @param points\n */\nexport function intersectBoundsPolyline(bounds: TLBounds, points: number[][]): TLIntersection[] {\n  return intersectPolylineBounds(points, bounds)\n}\n\n/**\n * Find the intersections between a bounding box and a polygon.\n * @param bounds\n * @param points\n */\nexport function intersectBoundsPolygon(bounds: TLBounds, points: number[][]): TLIntersection[] {\n  return intersectPolygonBounds(points, bounds)\n}\n\n/* -------------------------------------------------- */\n/*                      Polyline                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a polyline and a line segment.\n * @param points\n * @param a1\n * @param a2\n */\nexport function intersectPolylineLineSegment(\n  points: number[][],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentPolyline(a1, a2, points)\n}\n\n/**\n * Find the intersections between a polyline and a rectangle.\n * @param points\n * @param point\n * @param size\n */\nexport function intersectPolylineRectangle(\n  points: number[][],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectanglePolyline(point, size, points)\n}\n\n/**\n * Find the intersections between a polyline and a bounding box.\n * @param points\n * @param bounds\n */\nexport function intersectPolylineBounds(points: number[][], bounds: TLBounds): TLIntersection[] {\n  return intersectRectanglePolyline(\n    [bounds.minX, bounds.minY],\n    [bounds.width, bounds.height],\n    points\n  )\n}\n\n/* -------------------------------------------------- */\n/*                       Polygon                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a polygon nd a line segment.\n * @param points\n * @param a1\n * @param a2\n */\nexport function intersectPolygonLineSegment(\n  points: number[][],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentPolyline(a1, a2, points)\n}\n\n/**\n * Find the intersections between a polygon and a rectangle.\n * @param points\n * @param point\n * @param size\n */\nexport function intersectPolygonRectangle(\n  points: number[][],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectanglePolyline(point, size, points)\n}\n\n/**\n * Find the intersections between a polygon and a bounding box.\n * @param points\n * @param bounds\n */\nexport function intersectPolygonBounds(points: number[][], bounds: TLBounds): TLIntersection[] {\n  return intersectRectanglePolygon(\n    [bounds.minX, bounds.minY],\n    [bounds.width, bounds.height],\n    points\n  )\n}\n\n/**\n * Find the intersections between a rectangle and a ray.\n * @param point\n * @param size\n * @param rotation\n * @param origin\n * @param direction\n */\nexport function intersectRayPolygon(\n  origin: number[],\n  direction: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = pointsToLineSegments(points, true).reduce<TLIntersection[]>(\n    (acc, [a1, a2], i) => {\n      const intersection = intersectRayLineSegment(origin, direction, a1, a2)\n\n      if (intersection) {\n        acc.push(createIntersection(i.toString(), ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\nexport function pointsToLineSegments(points: number[][], closed = false) {\n  const segments = []\n  for (let i = 1; i < points.length; i++) segments.push([points[i - 1], points[i]])\n  if (closed) segments.push([points[points.length - 1], points[0]])\n  return segments\n}\n"],
  "mappings": "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",
  "names": ["Vec", "createIntersection", "message", "points", "getRectangleSides", "point", "size", "rotation", "center", "tl", "Vec", "tr", "br", "bl", "isAngleBetween", "a", "b", "c", "PI2", "AB", "AC", "intersectLineLine", "PQ", "slopeAB", "slopePQ", "x", "y", "intersectRayRay", "p0", "n0", "p1", "n1", "dx", "dy", "det", "u", "v", "m0", "m1", "b0", "intersectRayLineSegment", "origin", "direction", "a1", "a2", "x1", "y1", "x2", "y2", "d", "r", "s", "intersectRayRectangle", "intersectRectangleRay", "intersectRayEllipse", "rx", "ry", "intersectLineSegmentEllipse", "intersectRayBounds", "bounds", "minX", "minY", "width", "height", "intersectLineSegmentRay", "intersectLineSegmentLineSegment", "b1", "b2", "BV", "AV", "ua_t", "ub_t", "u_b", "ua", "ub", "intersectLineSegmentRectangle", "intersectRectangleLineSegment", "intersectLineSegmentArc", "radius", "start", "end", "sa", "ea", "ellipseTest", "intersectEllipseLineSegment", "intersectLineSegmentCircle", "cc", "deter", "e", "u1", "u2", "results", "diff", "A", "B", "C", "tValues", "discriminant", "root", "t", "p", "intersectLineSegmentBounds", "intersectBoundsLineSegment", "intersectLineSegmentPolyline", "pts", "int", "intersectLineSegmentPolygon", "acc", "intersection", "intersectRectangleRectangle", "point1", "size1", "point2", "size2", "intersections", "intersectRectangleArc", "intersectArcLineSegment", "__spreadProps", "__spreadValues", "intersectRectangleCircle", "intersectRectangleEllipse", "intersectRectangleBounds", "intersectRectanglePolyline", "intersectRectanglePolygon", "intersectArcRectangle", "intersectArcBounds", "intersectCircleLineSegment", "intersectCircleCircle", "c1", "r1", "c2", "r2", "intersectCircleRectangle", "intersectCircleBounds", "intersectEllipseRay", "intersectEllipseRectangle", "intersectEllipseEllipse", "_c1", "_rx1", "_ry1", "_r1", "_c2", "_rx2", "_ry2", "_r2", "intersectEllipseCircle", "intersectEllipseBounds", "intersectBoundsRay", "intersectBoundsRectangle", "intersectBoundsBounds", "bounds1", "bounds2", "intersectBoundsArc", "intersectBoundsCircle", "intersectBoundsEllipse", "intersectBoundsPolyline", "intersectPolylineBounds", "intersectBoundsPolygon", "intersectPolygonBounds", "intersectPolylineLineSegment", "intersectPolylineRectangle", "intersectPolygonLineSegment", "intersectPolygonRectangle", "intersectRayPolygon", "pointsToLineSegments", "i", "closed", "segments"]
}
