{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["export interface TLBezierCurveSegment {\n  start: number[]\n  tangentStart: number[]\n  normalStart: number[]\n  pressureStart: number\n  end: number[]\n  tangentEnd: number[]\n  normalEnd: number[]\n  pressureEnd: number\n}\n\n/**\n * Get bezier curve segments that pass through an array of points.\n * @param points\n * @param tension\n */\nexport function getTLBezierCurveSegments(\n  points: number[][],\n  tension = 0.4\n): TLBezierCurveSegment[] {\n  const len = points.length\n  const cpoints: number[][] = [...points]\n\n  if (len < 2) {\n    throw Error('Curve must have at least two points.')\n  }\n\n  for (let i = 1; i < len - 1; i++) {\n    const p0 = points[i - 1]\n    const p1 = points[i]\n    const p2 = points[i + 1]\n\n    const pdx = p2[0] - p0[0]\n    const pdy = p2[1] - p0[1]\n    const pd = Math.hypot(pdx, pdy)\n    const nx = pdx / pd // normalized x\n    const ny = pdy / pd // normalized y\n    const dp = Math.hypot(p1[0] - p0[0], p1[1] - p0[1]) // Distance to previous\n    const dn = Math.hypot(p1[0] - p2[0], p1[1] - p2[1]) // Distance to next\n\n    cpoints[i] = [\n      // tangent start\n      p1[0] - nx * dp * tension,\n      p1[1] - ny * dp * tension,\n      // tangent end\n      p1[0] + nx * dn * tension,\n      p1[1] + ny * dn * tension,\n      // normal\n      nx,\n      ny,\n    ]\n  }\n\n  // TODO: Reflect the nearest control points, not average them\n  const d0 = Math.hypot(points[0][0] + cpoints[1][0])\n  cpoints[0][2] = (points[0][0] + cpoints[1][0]) / 2\n  cpoints[0][3] = (points[0][1] + cpoints[1][1]) / 2\n  cpoints[0][4] = (cpoints[1][0] - points[0][0]) / d0\n  cpoints[0][5] = (cpoints[1][1] - points[0][1]) / d0\n\n  const d1 = Math.hypot(points[len - 1][1] + cpoints[len - 1][1])\n  cpoints[len - 1][0] = (points[len - 1][0] + cpoints[len - 2][2]) / 2\n  cpoints[len - 1][1] = (points[len - 1][1] + cpoints[len - 2][3]) / 2\n  cpoints[len - 1][4] = (cpoints[len - 2][2] - points[len - 1][0]) / -d1\n  cpoints[len - 1][5] = (cpoints[len - 2][3] - points[len - 1][1]) / -d1\n\n  const results: TLBezierCurveSegment[] = []\n\n  for (let i = 1; i < cpoints.length; i++) {\n    results.push({\n      start: points[i - 1].slice(0, 2),\n      tangentStart: cpoints[i - 1].slice(2, 4),\n      normalStart: cpoints[i - 1].slice(4, 6),\n      pressureStart: 2 + ((i - 1) % 2 === 0 ? 1.5 : 0),\n      end: points[i].slice(0, 2),\n      tangentEnd: cpoints[i].slice(0, 2),\n      normalEnd: cpoints[i].slice(4, 6),\n      pressureEnd: 2 + (i % 2 === 0 ? 1.5 : 0),\n    })\n  }\n\n  return results\n}\n\n/**\n * Evaluate a 2d cubic bezier at a point t on the x axis.\n * @param tx\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n */\nexport function cubicBezier(tx: number, x1: number, y1: number, x2: number, y2: number): number {\n  // Inspired by Don Lancaster's two articles\n  // http://www.tinaja.com/glib/cubemath.pdf\n  // http://www.tinaja.com/text/bezmath.html\n\n  // Set start and end point\n  const x0 = 0\n  const y0 = 0\n  const x3 = 1\n  const y3 = 1\n  // Convert the coordinates to equation space\n  const A = x3 - 3 * x2 + 3 * x1 - x0\n  const B = 3 * x2 - 6 * x1 + 3 * x0\n  const C = 3 * x1 - 3 * x0\n  const D = x0\n  const E = y3 - 3 * y2 + 3 * y1 - y0\n  const F = 3 * y2 - 6 * y1 + 3 * y0\n  const G = 3 * y1 - 3 * y0\n  const H = y0\n  // Variables for the loop below\n  const iterations = 5\n\n  let i: number\n  let slope: number\n  let x: number\n  let t = tx\n\n  // Loop through a few times to get a more accurate time value, according to the Newton-Raphson method\n  // http://en.wikipedia.org/wiki/Newton's_method\n  for (i = 0; i < iterations; i++) {\n    // The curve's x equation for the current time value\n    x = A * t * t * t + B * t * t + C * t + D\n\n    // The slope we want is the inverse of the derivate of x\n    slope = 1 / (3 * A * t * t + 2 * B * t + C)\n\n    // Get the next estimated time value, which will be more accurate than the one before\n    t -= (x - tx) * slope\n    t = t > 1 ? 1 : t < 0 ? 0 : t\n  }\n\n  // Find the y value through the curve's y equation, with the now more accurate time value\n  return Math.abs(E * t * t * t + F * t * t + G * t * H)\n}\n\n/**\n * Get a bezier curve data for a spline that fits an array of points.\n * @param points An array of points formatted as [x, y]\n * @param k Tension\n */\nexport function getSpline(pts: number[][], k = 0.5): number[][] {\n  let p0: number[]\n  let [p1, p2, p3] = pts\n\n  const results: number[][] = []\n\n  for (let i = 1, len = pts.length; i < len; i++) {\n    p0 = p1\n    p1 = p2\n    p2 = p3\n    p3 = pts[i + 2] ? pts[i + 2] : p2\n\n    results.push([\n      p1[0] + ((p2[0] - p0[0]) / 6) * k,\n      p1[1] + ((p2[1] - p0[1]) / 6) * k,\n      p2[0] - ((p3[0] - p1[0]) / 6) * k,\n      p2[1] - ((p3[1] - p1[1]) / 6) * k,\n      pts[i][0],\n      pts[i][1],\n    ])\n  }\n\n  return results\n}\n\n/**\n * Find a point along a curve segment, via pomax.\n * @param t\n * @param points [cpx1, cpy1, cpx2, cpy2, px, py][]\n */\nexport function computePointOnSpline(t: number, points: number[][]): number[] {\n  // shortcuts\n  if (t === 0) {\n    return points[0]\n  }\n\n  const order = points.length - 1\n\n  if (t === 1) {\n    return points[order]\n  }\n\n  const mt = 1 - t\n  let p = points // constant?\n\n  if (order === 0) {\n    return points[0]\n  } // linear?\n\n  if (order === 1) {\n    return [mt * p[0][0] + t * p[1][0], mt * p[0][1] + t * p[1][1]]\n  } // quadratic/cubic curve?\n\n  // if (order < 4) {\n  const mt2 = mt * mt\n  const t2 = t * t\n\n  let a: number\n  let b: number\n  let c: number\n  let d = 0\n\n  if (order === 2) {\n    p = [p[0], p[1], p[2], [0, 0]]\n    a = mt2\n    b = mt * t * 2\n    c = t2\n    // } else if (order === 3) {\n  } else {\n    a = mt2 * mt\n    b = mt2 * t * 3\n    c = mt * t2 * 3\n    d = t * t2\n  }\n\n  return [\n    a * p[0][0] + b * p[1][0] + c * p[2][0] + d * p[3][0],\n    a * p[0][1] + b * p[1][1] + c * p[2][1] + d * p[3][1],\n  ]\n  // } // higher order curves: use de Casteljau's computation\n}\n\n/**\n * Get a bezier curve data for a spline that fits an array of points.\n * @param pts\n * @param tension\n * @param isClosed\n * @param numOfSegments\n */\nexport function getCurvePoints(\n  pts: number[][],\n  tension = 0.5,\n  isClosed = false,\n  numOfSegments = 3\n): number[][] {\n  const _pts = [...pts]\n  const len = pts.length\n  const res: number[][] = [] // results\n\n  let t1x: number, // tension Vectors\n    t2x: number,\n    t1y: number,\n    t2y: number,\n    c1: number, // cardinal points\n    c2: number,\n    c3: number,\n    c4: number,\n    st: number,\n    st2: number,\n    st3: number\n\n  // The algorithm require a previous and next point to the actual point array.\n  // Check if we will draw closed or open curve.\n  // If closed, copy end points to beginning and first points to end\n  // If open, duplicate first points to beginning, end points to end\n  if (isClosed) {\n    _pts.unshift(_pts[len - 1])\n    _pts.push(_pts[0])\n  } else {\n    // copy 1. point and insert at beginning\n    _pts.unshift(_pts[0])\n    _pts.push(_pts[len - 1])\n    // _pts.push(_pts[len - 1])\n  }\n\n  // For each point, calculate a segment\n  for (let i = 1; i < _pts.length - 2; i++) {\n    // Calculate points along segment and add to results\n    for (let t = 0; t <= numOfSegments; t++) {\n      // Step\n      st = t / numOfSegments\n      st2 = Math.pow(st, 2)\n      st3 = Math.pow(st, 3)\n\n      // Cardinals\n      c1 = 2 * st3 - 3 * st2 + 1\n      c2 = -(2 * st3) + 3 * st2\n      c3 = st3 - 2 * st2 + st\n      c4 = st3 - st2\n\n      // Tension\n      t1x = (_pts[i + 1][0] - _pts[i - 1][0]) * tension\n      t2x = (_pts[i + 2][0] - _pts[i][0]) * tension\n      t1y = (_pts[i + 1][1] - _pts[i - 1][1]) * tension\n      t2y = (_pts[i + 2][1] - _pts[i][1]) * tension\n\n      // Control points\n      res.push([\n        c1 * _pts[i][0] + c2 * _pts[i + 1][0] + c3 * t1x + c4 * t2x,\n        c1 * _pts[i][1] + c2 * _pts[i + 1][1] + c3 * t1y + c4 * t2y,\n      ])\n    }\n  }\n\n  res.push(pts[pts.length - 1])\n\n  return res\n}\n\n/**\n * Simplify a line (using Ramer-Douglas-Peucker algorithm).\n * @param points An array of points as [x, y, ...][]\n * @param tolerance The minimum line distance (also called epsilon).\n * @returns Simplified array as [x, y, ...][]\n */\n\nexport function simplify(points: number[][], tolerance = 1): number[][] {\n  const len = points.length\n  const a = points[0]\n  const b = points[len - 1]\n  const [x1, y1] = a\n  const [x2, y2] = b\n\n  if (len > 2) {\n    let distance = 0\n    let index = 0\n    const max = Math.hypot(y2 - y1, x2 - x1)\n\n    for (let i = 1; i < len - 1; i++) {\n      const [x0, y0] = points[i]\n      const d = Math.abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) / max\n\n      if (distance > d) continue\n\n      distance = d\n      index = i\n    }\n\n    if (distance > tolerance) {\n      const l0 = simplify(points.slice(0, index + 1), tolerance)\n      const l1 = simplify(points.slice(index + 1), tolerance)\n      return l0.concat(l1.slice(1))\n    }\n  }\n\n  return [a, b]\n}\n"],
  "mappings": "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",
  "names": []
}
