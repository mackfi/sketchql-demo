{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["export interface TLBezierCurveSegment {\n  start: number[]\n  tangentStart: number[]\n  normalStart: number[]\n  pressureStart: number\n  end: number[]\n  tangentEnd: number[]\n  normalEnd: number[]\n  pressureEnd: number\n}\n\n/**\n * Get bezier curve segments that pass through an array of points.\n * @param points\n * @param tension\n */\nexport function getTLBezierCurveSegments(\n  points: number[][],\n  tension = 0.4\n): TLBezierCurveSegment[] {\n  const len = points.length\n  const cpoints: number[][] = [...points]\n\n  if (len < 2) {\n    throw Error('Curve must have at least two points.')\n  }\n\n  for (let i = 1; i < len - 1; i++) {\n    const p0 = points[i - 1]\n    const p1 = points[i]\n    const p2 = points[i + 1]\n\n    const pdx = p2[0] - p0[0]\n    const pdy = p2[1] - p0[1]\n    const pd = Math.hypot(pdx, pdy)\n    const nx = pdx / pd // normalized x\n    const ny = pdy / pd // normalized y\n    const dp = Math.hypot(p1[0] - p0[0], p1[1] - p0[1]) // Distance to previous\n    const dn = Math.hypot(p1[0] - p2[0], p1[1] - p2[1]) // Distance to next\n\n    cpoints[i] = [\n      // tangent start\n      p1[0] - nx * dp * tension,\n      p1[1] - ny * dp * tension,\n      // tangent end\n      p1[0] + nx * dn * tension,\n      p1[1] + ny * dn * tension,\n      // normal\n      nx,\n      ny,\n    ]\n  }\n\n  // TODO: Reflect the nearest control points, not average them\n  const d0 = Math.hypot(points[0][0] + cpoints[1][0])\n  cpoints[0][2] = (points[0][0] + cpoints[1][0]) / 2\n  cpoints[0][3] = (points[0][1] + cpoints[1][1]) / 2\n  cpoints[0][4] = (cpoints[1][0] - points[0][0]) / d0\n  cpoints[0][5] = (cpoints[1][1] - points[0][1]) / d0\n\n  const d1 = Math.hypot(points[len - 1][1] + cpoints[len - 1][1])\n  cpoints[len - 1][0] = (points[len - 1][0] + cpoints[len - 2][2]) / 2\n  cpoints[len - 1][1] = (points[len - 1][1] + cpoints[len - 2][3]) / 2\n  cpoints[len - 1][4] = (cpoints[len - 2][2] - points[len - 1][0]) / -d1\n  cpoints[len - 1][5] = (cpoints[len - 2][3] - points[len - 1][1]) / -d1\n\n  const results: TLBezierCurveSegment[] = []\n\n  for (let i = 1; i < cpoints.length; i++) {\n    results.push({\n      start: points[i - 1].slice(0, 2),\n      tangentStart: cpoints[i - 1].slice(2, 4),\n      normalStart: cpoints[i - 1].slice(4, 6),\n      pressureStart: 2 + ((i - 1) % 2 === 0 ? 1.5 : 0),\n      end: points[i].slice(0, 2),\n      tangentEnd: cpoints[i].slice(0, 2),\n      normalEnd: cpoints[i].slice(4, 6),\n      pressureEnd: 2 + (i % 2 === 0 ? 1.5 : 0),\n    })\n  }\n\n  return results\n}\n\n/**\n * Evaluate a 2d cubic bezier at a point t on the x axis.\n * @param tx\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n */\nexport function cubicBezier(tx: number, x1: number, y1: number, x2: number, y2: number): number {\n  // Inspired by Don Lancaster's two articles\n  // http://www.tinaja.com/glib/cubemath.pdf\n  // http://www.tinaja.com/text/bezmath.html\n\n  // Set start and end point\n  const x0 = 0\n  const y0 = 0\n  const x3 = 1\n  const y3 = 1\n  // Convert the coordinates to equation space\n  const A = x3 - 3 * x2 + 3 * x1 - x0\n  const B = 3 * x2 - 6 * x1 + 3 * x0\n  const C = 3 * x1 - 3 * x0\n  const D = x0\n  const E = y3 - 3 * y2 + 3 * y1 - y0\n  const F = 3 * y2 - 6 * y1 + 3 * y0\n  const G = 3 * y1 - 3 * y0\n  const H = y0\n  // Variables for the loop below\n  const iterations = 5\n\n  let i: number\n  let slope: number\n  let x: number\n  let t = tx\n\n  // Loop through a few times to get a more accurate time value, according to the Newton-Raphson method\n  // http://en.wikipedia.org/wiki/Newton's_method\n  for (i = 0; i < iterations; i++) {\n    // The curve's x equation for the current time value\n    x = A * t * t * t + B * t * t + C * t + D\n\n    // The slope we want is the inverse of the derivate of x\n    slope = 1 / (3 * A * t * t + 2 * B * t + C)\n\n    // Get the next estimated time value, which will be more accurate than the one before\n    t -= (x - tx) * slope\n    t = t > 1 ? 1 : t < 0 ? 0 : t\n  }\n\n  // Find the y value through the curve's y equation, with the now more accurate time value\n  return Math.abs(E * t * t * t + F * t * t + G * t * H)\n}\n\n/**\n * Get a bezier curve data for a spline that fits an array of points.\n * @param points An array of points formatted as [x, y]\n * @param k Tension\n */\nexport function getSpline(pts: number[][], k = 0.5): number[][] {\n  let p0: number[]\n  let [p1, p2, p3] = pts\n\n  const results: number[][] = []\n\n  for (let i = 1, len = pts.length; i < len; i++) {\n    p0 = p1\n    p1 = p2\n    p2 = p3\n    p3 = pts[i + 2] ? pts[i + 2] : p2\n\n    results.push([\n      p1[0] + ((p2[0] - p0[0]) / 6) * k,\n      p1[1] + ((p2[1] - p0[1]) / 6) * k,\n      p2[0] - ((p3[0] - p1[0]) / 6) * k,\n      p2[1] - ((p3[1] - p1[1]) / 6) * k,\n      pts[i][0],\n      pts[i][1],\n    ])\n  }\n\n  return results\n}\n\n/**\n * Find a point along a curve segment, via pomax.\n * @param t\n * @param points [cpx1, cpy1, cpx2, cpy2, px, py][]\n */\nexport function computePointOnSpline(t: number, points: number[][]): number[] {\n  // shortcuts\n  if (t === 0) {\n    return points[0]\n  }\n\n  const order = points.length - 1\n\n  if (t === 1) {\n    return points[order]\n  }\n\n  const mt = 1 - t\n  let p = points // constant?\n\n  if (order === 0) {\n    return points[0]\n  } // linear?\n\n  if (order === 1) {\n    return [mt * p[0][0] + t * p[1][0], mt * p[0][1] + t * p[1][1]]\n  } // quadratic/cubic curve?\n\n  // if (order < 4) {\n  const mt2 = mt * mt\n  const t2 = t * t\n\n  let a: number\n  let b: number\n  let c: number\n  let d = 0\n\n  if (order === 2) {\n    p = [p[0], p[1], p[2], [0, 0]]\n    a = mt2\n    b = mt * t * 2\n    c = t2\n    // } else if (order === 3) {\n  } else {\n    a = mt2 * mt\n    b = mt2 * t * 3\n    c = mt * t2 * 3\n    d = t * t2\n  }\n\n  return [\n    a * p[0][0] + b * p[1][0] + c * p[2][0] + d * p[3][0],\n    a * p[0][1] + b * p[1][1] + c * p[2][1] + d * p[3][1],\n  ]\n  // } // higher order curves: use de Casteljau's computation\n}\n\n/**\n * Get a bezier curve data for a spline that fits an array of points.\n * @param pts\n * @param tension\n * @param isClosed\n * @param numOfSegments\n */\nexport function getCurvePoints(\n  pts: number[][],\n  tension = 0.5,\n  isClosed = false,\n  numOfSegments = 3\n): number[][] {\n  const _pts = [...pts]\n  const len = pts.length\n  const res: number[][] = [] // results\n\n  let t1x: number, // tension Vectors\n    t2x: number,\n    t1y: number,\n    t2y: number,\n    c1: number, // cardinal points\n    c2: number,\n    c3: number,\n    c4: number,\n    st: number,\n    st2: number,\n    st3: number\n\n  // The algorithm require a previous and next point to the actual point array.\n  // Check if we will draw closed or open curve.\n  // If closed, copy end points to beginning and first points to end\n  // If open, duplicate first points to beginning, end points to end\n  if (isClosed) {\n    _pts.unshift(_pts[len - 1])\n    _pts.push(_pts[0])\n  } else {\n    // copy 1. point and insert at beginning\n    _pts.unshift(_pts[0])\n    _pts.push(_pts[len - 1])\n    // _pts.push(_pts[len - 1])\n  }\n\n  // For each point, calculate a segment\n  for (let i = 1; i < _pts.length - 2; i++) {\n    // Calculate points along segment and add to results\n    for (let t = 0; t <= numOfSegments; t++) {\n      // Step\n      st = t / numOfSegments\n      st2 = Math.pow(st, 2)\n      st3 = Math.pow(st, 3)\n\n      // Cardinals\n      c1 = 2 * st3 - 3 * st2 + 1\n      c2 = -(2 * st3) + 3 * st2\n      c3 = st3 - 2 * st2 + st\n      c4 = st3 - st2\n\n      // Tension\n      t1x = (_pts[i + 1][0] - _pts[i - 1][0]) * tension\n      t2x = (_pts[i + 2][0] - _pts[i][0]) * tension\n      t1y = (_pts[i + 1][1] - _pts[i - 1][1]) * tension\n      t2y = (_pts[i + 2][1] - _pts[i][1]) * tension\n\n      // Control points\n      res.push([\n        c1 * _pts[i][0] + c2 * _pts[i + 1][0] + c3 * t1x + c4 * t2x,\n        c1 * _pts[i][1] + c2 * _pts[i + 1][1] + c3 * t1y + c4 * t2y,\n      ])\n    }\n  }\n\n  res.push(pts[pts.length - 1])\n\n  return res\n}\n\n/**\n * Simplify a line (using Ramer-Douglas-Peucker algorithm).\n * @param points An array of points as [x, y, ...][]\n * @param tolerance The minimum line distance (also called epsilon).\n * @returns Simplified array as [x, y, ...][]\n */\n\nexport function simplify(points: number[][], tolerance = 1): number[][] {\n  const len = points.length\n  const a = points[0]\n  const b = points[len - 1]\n  const [x1, y1] = a\n  const [x2, y2] = b\n\n  if (len > 2) {\n    let distance = 0\n    let index = 0\n    const max = Math.hypot(y2 - y1, x2 - x1)\n\n    for (let i = 1; i < len - 1; i++) {\n      const [x0, y0] = points[i]\n      const d = Math.abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) / max\n\n      if (distance > d) continue\n\n      distance = d\n      index = i\n    }\n\n    if (distance > tolerance) {\n      const l0 = simplify(points.slice(0, index + 1), tolerance)\n      const l1 = simplify(points.slice(index + 1), tolerance)\n      return l0.concat(l1.slice(1))\n    }\n  }\n\n  return [a, b]\n}\n"],
  "mappings": "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",
  "names": ["getTLBezierCurveSegments", "points", "tension", "len", "cpoints", "i", "p0", "p1", "p2", "pdx", "pdy", "pd", "nx", "ny", "dp", "dn", "d0", "d1", "results", "cubicBezier", "tx", "x1", "y1", "x2", "y2", "A", "B", "C", "D", "E", "F", "G", "H", "iterations", "slope", "x", "t", "getSpline", "pts", "k", "p3", "computePointOnSpline", "order", "mt", "p", "mt2", "t2", "a", "b", "c", "d", "getCurvePoints", "isClosed", "numOfSegments", "_pts", "res", "t1x", "t2x", "t1y", "t2y", "c1", "c2", "c3", "c4", "st", "st2", "st3", "simplify", "tolerance", "distance", "index", "max", "x0", "y0", "l0", "l1"]
}
