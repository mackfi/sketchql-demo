#!/usr/bin/env node
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/cli.ts
import path4 from "path";
import fs3 from "fs";
import program from "commander";

// src/lfg.ts
import fs2 from "fs";
import path3 from "path";

// src/buildLibrary.ts
import fs from "fs";
import path from "path";
import { build } from "esbuild";
import { gzip } from "zlib";
import { spawn } from "child_process";
import dotenv from "dotenv";
dotenv.config();
var { log } = console;
function buildLibrary({
  name,
  isNode,
  outdir,
  tsconfig,
  external,
  format,
  target,
  define,
  entryPoints,
  calculateSize,
  customEsbuildConfig,
  buildCss
}) {
  return new Promise((resolve) => {
    log(`\u2023 ${name}: Building packages.`);
    try {
      let finish = function(types = false, build3 = false) {
        if (build3)
          didBuild = true;
        if (types)
          didTypes = true;
        if (didBuild && didTypes) {
          log(`\u2714 ${name}: Build complete.`);
          resolve();
        }
      };
      let didBuild = false;
      let didTypes = false;
      const ts = spawn(`tsc`, [`--project`, tsconfig, `--outDir`, outdir], { shell: true });
      ts.stdout.on("data", function(data) {
        const str = data.toString();
        log(`\u2022 ${name}: ${str}`);
      });
      ts.on("exit", () => {
        var _a2, _b2;
        log(`\u2022 ${name}: Built types.`);
        const base_cfg = __require(path.join(process.cwd(), "tsconfig.json"));
        let cfgWithPaths = "";
        if ((_a2 = base_cfg == null ? void 0 : base_cfg.compilerOptions) == null ? void 0 : _a2.paths) {
          cfgWithPaths = "tsconfig.json";
        } else {
          const cfg = __require(tsconfig);
          if ((_b2 = cfg == null ? void 0 : cfg.compilerOptions) == null ? void 0 : _b2.paths) {
            cfgWithPaths = tsconfig;
          }
        }
        if (cfgWithPaths) {
          const trp = spawn(`tsconfig-replace-paths`, [`-p`, cfgWithPaths], { shell: true });
          trp.on("exit", () => {
            log(`\u2022 ${name}: Resolved paths.`);
            finish(true);
          });
        } else {
          finish(true);
        }
      });
      Promise.all((Array.isArray(format) ? format : [format]).map((fmt) => __async(this, null, function* () {
        const extension = fmt === "esm" ? ".mjs" : ".js";
        const buildResult = yield build(__spreadValues({
          entryPoints,
          outdir,
          tsconfig,
          external,
          define,
          format: fmt,
          platform: isNode ? "node" : "neutral",
          outExtension: { ".js": extension },
          bundle: true,
          metafile: true,
          minify: true,
          sourcemap: true,
          treeShaking: true,
          target
        }, customEsbuildConfig));
        if (calculateSize) {
          fs.readFile(path.join(outdir, `index${extension}`), (_err, data) => {
            gzip(data, (_err2, result) => {
              const size = Object.values(buildResult.metafile.outputs).reduce((acc, { bytes }) => acc + bytes, 0);
              log(`\u2022 ${name}: Built ${fmt} package. (${(size / 1e3).toFixed(1)}kb / ${(result.length / 1e3).toFixed(1)}kb gzipped)`);
            });
          });
        }
      }))).then(() => {
        if (buildCss) {
          build({
            entryPoints: buildCss.entryPoints,
            outfile: path.join(outdir, "index.css"),
            bundle: true,
            minify: true
          }).then(() => {
            finish(false, true);
          });
        } else {
          finish(false, true);
        }
      });
    } catch (e) {
      log(`x ${name}: Build failed due to an error. ${e.message}`);
    }
  });
}

// src/devLibrary.ts
import { build as build2 } from "esbuild";
import { spawn as spawn2 } from "child_process";
import path2 from "path";
var { log: log2 } = console;
var ERROR_REGEX = /merror/gm;
var CLEAN_REGEX = /Found 0 errors/gm;
var CHANGE_REGEX = /Starting incremental compilation/gm;
function devLibrary(_0) {
  return __async(this, arguments, function* ({
    name,
    isNode,
    outdir,
    tsconfig,
    external,
    target,
    define,
    format,
    entryPoints,
    customEsbuildConfig,
    buildCss
  }) {
    log2(`\u2023 ${name}: Starting watch mode.`);
    const ts = spawn2(`tsc`, [`-w`, `--project`, tsconfig, `--pretty`, `--preserveWatchOutput`], {
      shell: true
    });
    let state = "clean";
    ts.stdout.on("data", function(data) {
      const str = data.toString();
      if (CHANGE_REGEX.test(str))
        return;
      const isErrorMessage = ERROR_REGEX.test(str);
      const isCleanMessage = CLEAN_REGEX.test(str);
      if (isErrorMessage) {
        state = "error";
        log2(`\u2023 ${name}: Rebuilt types. Encountered errors:`);
      }
      switch (state) {
        case "error": {
          if (isCleanMessage) {
            state = "clean";
            log2(`\u2023 ${name}: Rebuilt types. TypeScript errors fixed.`);
          } else {
            str.split("\n").filter(Boolean).forEach((s) => log2(`\u2023 ${name}: ${s}`));
          }
          break;
        }
        case "clean": {
          if (isCleanMessage) {
            log2(`\u2023 ${name}: Rebuilt types.`);
          } else {
          }
          break;
        }
      }
    });
    try {
      log2(`\u2023 ${name}: Starting incremental build.`);
      const formats = Array.isArray(format) ? format : [format];
      formats.forEach((fmt) => {
        const extension = fmt === "esm" ? ".mjs" : ".js";
        build2(__spreadProps(__spreadValues({
          entryPoints,
          outdir,
          tsconfig,
          external,
          define,
          format: fmt,
          target,
          platform: isNode ? "node" : "neutral",
          outExtension: { ".js": extension },
          minify: false,
          bundle: true,
          treeShaking: true,
          metafile: true,
          sourcemap: true,
          incremental: true
        }, customEsbuildConfig), {
          watch: {
            onRebuild(err) {
              if (err) {
                throw Error(`\u2023 ${name}: Rebuild failed.`);
              }
              log2(`\u2714 ${name}: Rebuilt package (${fmt}).`);
            }
          }
        }));
      });
      if (buildCss) {
        build2({
          entryPoints: buildCss.entryPoints,
          outfile: path2.join(outdir, "index.css"),
          bundle: true,
          minify: false,
          incremental: true,
          watch: {
            onRebuild(err) {
              if (err) {
                throw Error(`\u2023 ${name}: Failed to rebuild CSS.`);
              }
              log2(`\u2714 ${name}: Rebuilt CSS.`);
            }
          }
        });
      }
    } catch (err) {
      ts == null ? void 0 : ts.kill();
      process.exit(1);
    }
  });
}

// src/lfg.ts
function lfg() {
  return __async(this, arguments, function* (opts = {}) {
    var _a2, _b2, _c2;
    const {
      isDev = false,
      isNode = false,
      entryPoints = ["src/index.ts"],
      clean = true,
      devConfig = "tsconfig.dev.json",
      buildConfig = "tsconfig.build.json",
      devFormat = "esm",
      format = ["cjs", "esm"],
      target = "es6",
      outDir = "dist",
      external = {
        dependencies: true,
        devDependencies: true,
        peerDependencies: true
      },
      define = {
        "process.env.NODE_ENV": isDev ? '"development"' : '"production"'
      },
      calculateSize = true,
      customEsbuildConfig = {},
      buildCss
    } = opts;
    const cwd = process.cwd();
    const pkg = __require(path3.join(cwd, "package.json"));
    const externals = [
      ...external.dependencies ? Object.keys((_a2 = pkg.dependencies) != null ? _a2 : {}) : [],
      ...external.devDependencies ? Object.keys((_b2 = pkg.devDependencies) != null ? _b2 : {}) : [],
      ...external.peerDependencies ? Object.keys((_c2 = pkg.peerDependencies) != null ? _c2 : {}) : []
    ];
    const outDirAbs = path3.join(cwd, outDir);
    let configAbs = path3.join(cwd, isDev ? devConfig : buildConfig);
    if (!fs2.existsSync(configAbs)) {
      const { log: log3 } = console;
      log3(`\u2023 ${pkg.name}: Could not find ${isDev ? "dev" : "build"} config file (${isDev ? devConfig : buildConfig}), using tsconfig.json.`);
      configAbs = path3.join(cwd, "tsconfig.json");
    }
    const entryPointsAbs = entryPoints.map((entryPoint) => path3.join(cwd, entryPoint));
    if (isDev) {
      yield buildLibrary({
        name: pkg.name,
        outdir: outDirAbs,
        tsconfig: configAbs,
        external: externals,
        entryPoints: entryPointsAbs,
        format,
        target,
        isNode,
        define,
        calculateSize,
        customEsbuildConfig,
        buildCss
      });
      return devLibrary({
        name: pkg.name,
        outdir: outDirAbs,
        tsconfig: configAbs,
        external: externals,
        format: devFormat,
        target,
        entryPoints: entryPointsAbs,
        isNode,
        define,
        calculateSize,
        customEsbuildConfig,
        buildCss
      });
    } else {
      if (clean) {
        if (fs2.existsSync(outDirAbs)) {
          fs2.rmSync(outDirAbs, { recursive: true });
        }
      }
      return buildLibrary({
        name: pkg.name,
        outdir: outDirAbs,
        tsconfig: configAbs,
        external: externals,
        entryPoints: entryPointsAbs,
        format,
        target,
        isNode,
        define,
        calculateSize,
        customEsbuildConfig,
        buildCss
      });
    }
  });
}

// src/cli.ts
program.version("0.0.0").option("-d, --dev", "Develop").option("-n, --node", "Node").parse(process.argv);
var cli = program;
var { dev, node } = cli;
var options = {};
var _a, _b, _c, _d;
try {
  const cwd = path4.join(process.cwd());
  const configPath = path4.join(cwd, "lfg.config.json");
  if (fs3.existsSync(configPath)) {
    const config = __require(configPath);
    Object.assign(options, config);
  }
  Object.assign(options, {
    isNode: (_b = (_a = options.isNode) != null ? _a : node) != null ? _b : false,
    isDev: (_d = (_c = options.isDev) != null ? _c : dev) != null ? _d : false
  });
} catch (e) {
}
lfg(options);
//# sourceMappingURL=cli.mjs.map
