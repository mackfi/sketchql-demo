{
  "version": 3,
  "sources": ["../../../../../node_modules/@radix-ui/react-collection/dist/packages/react/collection/src/index.ts", "../../../../../node_modules/@radix-ui/react-collection/dist/packages/react/collection/src/Collection.tsx", "../../../../../node_modules/@radix-ui/react-direction/dist/packages/react/direction/src/index.ts", "../../../../../node_modules/@radix-ui/react-direction/dist/packages/react/direction/src/Direction.tsx", "../../../../../node_modules/@radix-ui/react-roving-focus/dist/packages/react/roving-focus/src/index.ts", "../../../../../node_modules/@radix-ui/react-roving-focus/dist/packages/react/roving-focus/src/RovingFocusGroup.tsx", "../../../../../node_modules/@radix-ui/react-menu/dist/packages/react/menu/src/index.ts", "../../../../../node_modules/@radix-ui/react-menu/dist/packages/react/menu/src/Menu.tsx"],
  "sourcesContent": ["export { createCollection } from './Collection';\nexport type { CollectionProps } from './Collection';\n", "import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Slot } from '@radix-ui/react-slot';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\ntype SlotProps = Radix.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>\u2026</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement>;\n    itemMap: Map<React.RefObject<ItemElement>, { ref: React.RefObject<ItemElement> } & ItemData>;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <Slot ref={composedRefs}>{children}</Slot>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <Slot {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </Slot>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n", "export {\n  useDirection,\n  //\n  Provider,\n  //\n  DirectionProvider,\n} from './Direction';\n", "import * as React from 'react';\n\ntype Direction = 'ltr' | 'rtl';\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\n/* -------------------------------------------------------------------------------------------------\n * Direction\n * -----------------------------------------------------------------------------------------------*/\n\ninterface DirectionProviderProps {\n  children?: React.ReactNode;\n  dir: Direction;\n}\nconst DirectionProvider: React.FC<DirectionProviderProps> = (props) => {\n  const { dir, children } = props;\n  return <DirectionContext.Provider value={dir}>{children}</DirectionContext.Provider>;\n};\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction useDirection(localDir?: Direction) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || 'ltr';\n}\n\nconst Provider = DirectionProvider;\n\nexport {\n  useDirection,\n  //\n  Provider,\n  //\n  DirectionProvider,\n};\n", "export {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n} from './RovingFocusGroup';\nexport type { RovingFocusGroupProps, RovingFocusItemProps } from './RovingFocusGroup';\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends PrimitiveSpanProps {\n  focusable?: boolean;\n  active?: boolean;\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const { __scopeRovingFocusGroup, focusable = true, active = false, ...itemProps } = props;\n    const id = useId();\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        />\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n", "export {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n} from './Menu';\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n} from './Menu';\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs, composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Slot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { hideOthers } from 'aria-hidden';\nimport { RemoveScroll } from 'react-remove-scroll';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst SELECTION_KEYS = ['Enter', ' '];\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nconst SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n};\nconst SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype ItemData = { disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenuItemElement,\n  ItemData\n>(MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenu?: Scope };\nconst [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [\n  createCollectionScope,\n  createPopperScope,\n  createRovingFocusGroupScope,\n]);\nconst usePopperScope = createPopperScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenuContextValue = {\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  content: MenuContentElement | null;\n  onContentChange(content: MenuContentElement | null): void;\n};\n\nconst [MenuProvider, useMenuContext] = createMenuContext<MenuContextValue>(MENU_NAME);\n\ntype MenuRootContextValue = {\n  onClose(): void;\n  isUsingKeyboardRef: React.RefObject<boolean>;\n  dir: Direction;\n  modal: boolean;\n};\n\nconst [MenuRootProvider, useMenuRootContext] = createMenuContext<MenuRootContextValue>(MENU_NAME);\n\ninterface MenuProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  modal?: boolean;\n}\n\nconst Menu: React.FC<MenuProps> = (props: ScopedProps<MenuProps>) => {\n  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const direction = useDirection(dir);\n\n  React.useEffect(() => {\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener('pointerdown', handlePointer, { capture: true, once: true });\n      document.addEventListener('pointermove', handlePointer, { capture: true, once: true });\n    };\n    const handlePointer = () => (isUsingKeyboardRef.current = false);\n    document.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, { capture: true });\n      document.removeEventListener('pointerdown', handlePointer, { capture: true });\n      document.removeEventListener('pointermove', handlePointer, { capture: true });\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuRootProvider\n          scope={__scopeMenu}\n          onClose={React.useCallback(() => handleOpenChange(false), [handleOpenChange])}\n          isUsingKeyboardRef={isUsingKeyboardRef}\n          dir={direction}\n          modal={modal}\n        >\n          {children}\n        </MenuRootProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'MenuAnchor';\n\ntype MenuAnchorElement = React.ElementRef<typeof PopperPrimitive.Anchor>;\ntype PopperAnchorProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst MenuAnchor = React.forwardRef<MenuAnchorElement, MenuAnchorProps>(\n  (props: ScopedProps<MenuAnchorProps>, forwardedRef) => {\n    const { __scopeMenu, ...anchorProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Anchor {...popperScope} {...anchorProps} ref={forwardedRef} />;\n  }\n);\n\nMenuAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'MenuPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createMenuContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface MenuPortalProps extends Omit<PortalProps, 'asChild'> {\n  children?: React.ReactNode;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuPortal: React.FC<MenuPortalProps> = (props: ScopedProps<MenuPortalProps>) => {\n  const { __scopeMenu, forceMount, children, container } = props;\n  const context = useMenuContext(PORTAL_NAME, __scopeMenu);\n  return (\n    <PortalProvider scope={__scopeMenu} forceMount={forceMount}>\n      <Presence present={forceMount || context.open}>\n        <PortalPrimitive asChild container={container}>\n          {children}\n        </PortalPrimitive>\n      </Presence>\n    </PortalProvider>\n  );\n};\n\nMenuPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype MenuContentContextValue = {\n  onItemEnter(event: React.PointerEvent): void;\n  onItemLeave(event: React.PointerEvent): void;\n  onTriggerLeave(event: React.PointerEvent): void;\n  searchRef: React.RefObject<string>;\n  pointerGraceTimerRef: React.MutableRefObject<number>;\n  onPointerGraceIntentChange(intent: GraceIntent | null): void;\n};\nconst [MenuContentProvider, useMenuContentContext] =\n  createMenuContext<MenuContentContextValue>(CONTENT_NAME);\n\ntype MenuContentElement = MenuRootContentTypeElement;\n/**\n * We purposefully don't union MenuRootContent and MenuSubContent props here because\n * they have conflicting prop types. We agreed that we would allow MenuSubContent to\n * accept props that it would just ignore.\n */\ninterface MenuContentProps extends MenuRootContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuContent = React.forwardRef<MenuContentElement, MenuContentProps>(\n  (props: ScopedProps<MenuContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...contentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            {rootContext.modal ? (\n              <MenuRootContentModal {...contentProps} ref={forwardedRef} />\n            ) : (\n              <MenuRootContentNonModal {...contentProps} ref={forwardedRef} />\n            )}\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuRootContentTypeElement = MenuContentImplElement;\ninterface MenuRootContentTypeProps\n  extends Omit<MenuContentImplProps, keyof MenuContentImplPrivateProps> {}\n\nconst MenuRootContentModal = React.forwardRef<MenuRootContentTypeElement, MenuRootContentTypeProps>(\n  (props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuRootContentTypeElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // Hide everything from ARIA except the `MenuContent`\n    React.useEffect(() => {\n      const content = ref.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <MenuContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure we're not trapping once it's been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        // make sure to only disable pointer events when open\n        // this avoids blocking interactions while animating out\n        disableOutsidePointerEvents={context.open}\n        disableOutsideScroll\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault(),\n          { checkForDefaultPrevented: false }\n        )}\n        onDismiss={() => context.onOpenChange(false)}\n      />\n    );\n  }\n);\n\nconst MenuRootContentNonModal = React.forwardRef<\n  MenuRootContentTypeElement,\n  MenuRootContentTypeProps\n>((props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return (\n    <MenuContentImpl\n      {...props}\n      ref={forwardedRef}\n      trapFocus={false}\n      disableOutsidePointerEvents={false}\n      disableOutsideScroll={false}\n      onDismiss={() => context.onOpenChange(false)}\n    />\n  );\n});\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype FocusScopeProps = Radix.ComponentPropsWithoutRef<typeof FocusScope>;\ntype DismissableLayerProps = Radix.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype RovingFocusGroupProps = Radix.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PopperContentProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ntype MenuContentImplPrivateProps = {\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n  onDismiss?: DismissableLayerProps['onDismiss'];\n  disableOutsidePointerEvents?: DismissableLayerProps['disableOutsidePointerEvents'];\n\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * (default: `false`)\n   */\n  disableOutsideScroll?: boolean;\n\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * (default: false)\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n};\ninterface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n    Omit<PopperContentProps, 'dir'> {\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: RovingFocusGroupProps['loop'];\n\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n  onFocusOutside?: DismissableLayerProps['onFocusOutside'];\n  onInteractOutside?: DismissableLayerProps['onInteractOutside'];\n}\n\nconst MenuContentImpl = React.forwardRef<MenuContentImplElement, MenuContentImplProps>(\n  (props: ScopedProps<MenuContentImplProps>, forwardedRef) => {\n    const {\n      __scopeMenu,\n      loop = false,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      disableOutsideScroll,\n      ...contentProps\n    } = props;\n    const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);\n    const popperScope = usePopperScope(__scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const getItems = useCollection(__scopeMenu);\n    const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n    const timerRef = React.useRef(0);\n    const searchRef = React.useRef('');\n    const pointerGraceTimerRef = React.useRef(0);\n    const pointerGraceIntentRef = React.useRef<GraceIntent | null>(null);\n    const pointerDirRef = React.useRef<Side>('right');\n    const lastPointerXRef = React.useRef(0);\n\n    const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n    const scrollLockWrapperProps = disableOutsideScroll\n      ? { as: Slot, allowPinchZoom: true }\n      : undefined;\n\n    const handleTypeaheadSearch = (key: string) => {\n      const search = searchRef.current + key;\n      const items = getItems().filter((item) => !item.disabled);\n      const currentItem = document.activeElement;\n      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;\n      const values = items.map((item) => item.textValue);\n      const nextMatch = getNextMatch(values, search, currentMatch);\n      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;\n\n      // Reset `searchRef` 1 second after it was last updated\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n\n      if (newItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (newItem as HTMLElement).focus());\n      }\n    };\n\n    React.useEffect(() => {\n      return () => window.clearTimeout(timerRef.current);\n    }, []);\n\n    // Make sure the whole tree has focus guards as our `MenuContent` may be\n    // the last element in the DOM (beacuse of the `Portal`)\n    useFocusGuards();\n\n    const isPointerMovingToSubmenu = React.useCallback((event: React.PointerEvent) => {\n      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n    }, []);\n\n    return (\n      <MenuContentProvider\n        scope={__scopeMenu}\n        searchRef={searchRef}\n        onItemEnter={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onItemLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) return;\n            contentRef.current?.focus();\n            setCurrentItemId(null);\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onTriggerLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        pointerGraceTimerRef={pointerGraceTimerRef}\n        onPointerGraceIntentChange={React.useCallback((intent) => {\n          pointerGraceIntentRef.current = intent;\n        }, [])}\n      >\n        <ScrollLockWrapper {...scrollLockWrapperProps}>\n          <FocusScope\n            asChild\n            trapped={trapFocus}\n            onMountAutoFocus={composeEventHandlers(onOpenAutoFocus, (event) => {\n              // when opening, explicitly focus the content area only and leave\n              // `onEntryFocus` in  control of focusing first item\n              event.preventDefault();\n              contentRef.current?.focus();\n            })}\n            onUnmountAutoFocus={onCloseAutoFocus}\n          >\n            <DismissableLayer\n              asChild\n              disableOutsidePointerEvents={disableOutsidePointerEvents}\n              onEscapeKeyDown={onEscapeKeyDown}\n              onPointerDownOutside={onPointerDownOutside}\n              onFocusOutside={onFocusOutside}\n              onInteractOutside={onInteractOutside}\n              onDismiss={onDismiss}\n            >\n              <RovingFocusGroup.Root\n                asChild\n                {...rovingFocusGroupScope}\n                dir={rootContext.dir}\n                orientation=\"vertical\"\n                loop={loop}\n                currentTabStopId={currentItemId}\n                onCurrentTabStopIdChange={setCurrentItemId}\n                onEntryFocus={(event) => {\n                  // only focus first item when using keyboard\n                  if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();\n                }}\n              >\n                <PopperPrimitive.Content\n                  role=\"menu\"\n                  aria-orientation=\"vertical\"\n                  data-state={getOpenState(context.open)}\n                  dir={rootContext.dir}\n                  {...popperScope}\n                  {...contentProps}\n                  ref={composedRefs}\n                  style={{ outline: 'none', ...contentProps.style }}\n                  onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                    // submenu key events bubble through portals. We only care about keys in this menu.\n                    const target = event.target as HTMLElement;\n                    const isKeyDownInside = target.closest('[role=\"menu\"]') === event.currentTarget;\n                    const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                    const isCharacterKey = event.key.length === 1;\n                    if (isKeyDownInside) {\n                      // menus should not be navigated using tab key so we prevent it\n                      if (event.key === 'Tab') event.preventDefault();\n                      if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                    }\n                    // focus first/last item based on key pressed\n                    const content = contentRef.current;\n                    if (event.target !== content) return;\n                    if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                    event.preventDefault();\n                    const items = getItems().filter((item) => !item.disabled);\n                    const candidateNodes = items.map((item) => item.ref.current!);\n                    if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                    focusFirst(candidateNodes);\n                  })}\n                  onBlur={composeEventHandlers(props.onBlur, (event) => {\n                    // clear search buffer when leaving the menu\n                    if (!event.currentTarget.contains(event.target)) {\n                      window.clearTimeout(timerRef.current);\n                      searchRef.current = '';\n                    }\n                  })}\n                  onPointerMove={composeEventHandlers(\n                    props.onPointerMove,\n                    whenMouse((event) => {\n                      const target = event.target as HTMLElement;\n                      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                      // We don't use `event.movementX` for this check because Safari will\n                      // always return `0` on a pointer event.\n                      if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                        const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';\n                        pointerDirRef.current = newDir;\n                        lastPointerXRef.current = event.clientX;\n                      }\n                    })\n                  )}\n                />\n              </RovingFocusGroup.Root>\n            </DismissableLayer>\n          </FocusScope>\n        </ScrollLockWrapper>\n      </MenuContentProvider>\n    );\n  }\n);\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenuGroup';\n\ntype MenuGroupElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenuGroupProps extends PrimitiveDivProps {}\n\nconst MenuGroup = React.forwardRef<MenuGroupElement, MenuGroupProps>(\n  (props: ScopedProps<MenuGroupProps>, forwardedRef) => {\n    const { __scopeMenu, ...groupProps } = props;\n    return <Primitive.div role=\"group\" {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenuLabel';\n\ntype MenuLabelElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuLabelProps extends PrimitiveDivProps {}\n\nconst MenuLabel = React.forwardRef<MenuLabelElement, MenuLabelProps>(\n  (props: ScopedProps<MenuLabelProps>, forwardedRef) => {\n    const { __scopeMenu, ...labelProps } = props;\n    return <Primitive.div {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemElement = MenuItemImplElement;\ninterface MenuItemProps extends Omit<MenuItemImplProps, 'onSelect'> {\n  onSelect?: (event: Event) => void;\n}\n\nconst MenuItem = React.forwardRef<MenuItemElement, MenuItemProps>(\n  (props: ScopedProps<MenuItemProps>, forwardedRef) => {\n    const { disabled = false, onSelect, ...itemProps } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const rootContext = useMenuRootContext(ITEM_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isPointerDownRef = React.useRef(false);\n\n    const handleSelect = () => {\n      const menuItem = ref.current;\n      if (!disabled && menuItem) {\n        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });\n        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });\n        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);\n        if (itemSelectEvent.defaultPrevented) {\n          isPointerDownRef.current = false;\n        } else {\n          rootContext.onClose();\n        }\n      }\n    };\n\n    return (\n      <MenuItemImpl\n        {...itemProps}\n        ref={composedRefs}\n        disabled={disabled}\n        onClick={composeEventHandlers(props.onClick, handleSelect)}\n        onPointerDown={(event) => {\n          props.onPointerDown?.(event);\n          isPointerDownRef.current = true;\n        }}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          // Pointer down can move to a different menu item which should activate it on pointer up.\n          // We dispatch a click for selection to allow composition with click based triggers and to\n          // prevent Firefox from getting stuck in text selection mode when the menu closes.\n          if (!isPointerDownRef.current) event.currentTarget?.click();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isTypingAhead = contentContext.searchRef.current !== '';\n          if (disabled || (isTypingAhead && event.key === ' ')) return;\n          if (SELECTION_KEYS.includes(event.key)) {\n            event.currentTarget.click();\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            event.preventDefault();\n          }\n        })}\n      />\n    );\n  }\n);\n\nMenuItem.displayName = ITEM_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuItemImplElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuItemImplProps extends PrimitiveDivProps {\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst MenuItemImpl = React.forwardRef<MenuItemImplElement, MenuItemImplProps>(\n  (props: ScopedProps<MenuItemImplProps>, forwardedRef) => {\n    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n    const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const ref = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const [isFocused, setIsFocused] = React.useState(false);\n\n    // get the item's `.textContent` as default strategy for typeahead `textValue`\n    const [textContent, setTextContent] = React.useState('');\n    React.useEffect(() => {\n      const menuItem = ref.current;\n      if (menuItem) {\n        setTextContent((menuItem.textContent ?? '').trim());\n      }\n    }, [itemProps.children]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeMenu}\n        disabled={disabled}\n        textValue={textValue ?? textContent}\n      >\n        <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!disabled}>\n          <Primitive.div\n            role=\"menuitem\"\n            data-highlighted={isFocused ? '' : undefined}\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            {...itemProps}\n            ref={composedRefs}\n            /**\n             * We focus items on `pointerMove` to achieve the following:\n             *\n             * - Mouse over an item (it focuses)\n             * - Leave mouse where it is and use keyboard to focus a different item\n             * - Wiggle mouse without it leaving previously focused item\n             * - Previously focused item should re-focus\n             *\n             * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n             * wiggles. This is to match native menu implementation.\n             */\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse((event) => {\n                if (disabled) {\n                  contentContext.onItemLeave(event);\n                } else {\n                  contentContext.onItemEnter(event);\n                  if (!event.defaultPrevented) {\n                    const item = event.currentTarget;\n                    item.focus();\n                  }\n                }\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse((event) => contentContext.onItemLeave(event))\n            )}\n            onFocus={composeEventHandlers(props.onFocus, () => setIsFocused(true))}\n            onBlur={composeEventHandlers(props.onBlur, () => setIsFocused(false))}\n          />\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemElement = MenuItemElement;\ninterface MenuCheckboxItemProps extends MenuItemProps {\n  checked?: boolean;\n  onCheckedChange?: (checked: boolean) => void;\n}\n\nconst MenuCheckboxItem = React.forwardRef<MenuCheckboxItemElement, MenuCheckboxItemProps>(\n  (props: ScopedProps<MenuCheckboxItemProps>, forwardedRef) => {\n    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemcheckbox\"\n          aria-checked={checked}\n          {...checkboxItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            checkboxItemProps.onSelect,\n            () => onCheckedChange?.(!checked),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst [RadioGroupProvider, useRadioGroupContext] = createMenuContext<MenuRadioGroupProps>(\n  RADIO_GROUP_NAME,\n  { value: undefined, onValueChange: () => {} }\n);\n\ntype MenuRadioGroupElement = React.ElementRef<typeof MenuGroup>;\ninterface MenuRadioGroupProps extends MenuGroupProps {\n  value?: string;\n  onValueChange?: (value: string) => void;\n}\n\nconst MenuRadioGroup = React.forwardRef<MenuRadioGroupElement, MenuRadioGroupProps>(\n  (props: ScopedProps<MenuRadioGroupProps>, forwardedRef) => {\n    const { value, onValueChange, ...groupProps } = props;\n    const handleValueChange = useCallbackRef(onValueChange);\n    return (\n      <RadioGroupProvider scope={props.__scopeMenu} value={value} onValueChange={handleValueChange}>\n        <MenuGroup {...groupProps} ref={forwardedRef} />\n      </RadioGroupProvider>\n    );\n  }\n);\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemElement = React.ElementRef<typeof MenuItem>;\ninterface MenuRadioItemProps extends MenuItemProps {\n  value: string;\n}\n\nconst MenuRadioItem = React.forwardRef<MenuRadioItemElement, MenuRadioItemProps>(\n  (props: ScopedProps<MenuRadioItemProps>, forwardedRef) => {\n    const { value, ...radioItemProps } = props;\n    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n    const checked = value === context.value;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemradio\"\n          aria-checked={checked}\n          {...radioItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            radioItemProps.onSelect,\n            () => context.onValueChange?.(value),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\n\nconst [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(ITEM_INDICATOR_NAME, {\n  checked: false,\n});\n\ntype MenuItemIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface MenuItemIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuItemIndicator = React.forwardRef<MenuItemIndicatorElement, MenuItemIndicatorProps>(\n  (props: ScopedProps<MenuItemIndicatorProps>, forwardedRef) => {\n    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n    return (\n      <Presence present={forceMount || indicatorContext.checked}>\n        <Primitive.span\n          {...itemIndicatorProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(indicatorContext.checked)}\n        />\n      </Presence>\n    );\n  }\n);\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenuSeparator';\n\ntype MenuSeparatorElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuSeparatorProps extends PrimitiveDivProps {}\n\nconst MenuSeparator = React.forwardRef<MenuSeparatorElement, MenuSeparatorProps>(\n  (props: ScopedProps<MenuSeparatorProps>, forwardedRef) => {\n    const { __scopeMenu, ...separatorProps } = props;\n    return (\n      <Primitive.div\n        role=\"separator\"\n        aria-orientation=\"horizontal\"\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenuArrow';\n\ntype MenuArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface MenuArrowProps extends PopperArrowProps {}\n\nconst MenuArrow = React.forwardRef<MenuArrowElement, MenuArrowProps>(\n  (props: ScopedProps<MenuArrowProps>, forwardedRef) => {\n    const { __scopeMenu, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenuArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'MenuSub';\n\ntype MenuSubContextValue = {\n  contentId: string;\n  triggerId: string;\n  trigger: MenuSubTriggerElement | null;\n  onTriggerChange(trigger: MenuSubTriggerElement | null): void;\n};\n\nconst [MenuSubProvider, useMenuSubContext] = createMenuContext<MenuSubContextValue>(SUB_NAME);\n\ninterface MenuSubProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst MenuSub: React.FC<MenuSubProps> = (props: ScopedProps<MenuSubProps>) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState<MenuSubTriggerElement | null>(null);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n\n  // Prevent the parent menu from reopening with open submenus.\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuSubProvider\n          scope={__scopeMenu}\n          contentId={useId()}\n          triggerId={useId()}\n          trigger={trigger}\n          onTriggerChange={setTrigger}\n        >\n          {children}\n        </MenuSubProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenuSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenuSubTrigger';\n\ntype MenuSubTriggerElement = MenuItemImplElement;\ninterface MenuSubTriggerProps extends MenuItemImplProps {}\n\nconst MenuSubTrigger = React.forwardRef<MenuSubTriggerElement, MenuSubTriggerProps>(\n  (props: ScopedProps<MenuSubTriggerProps>, forwardedRef) => {\n    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const openTimerRef = React.useRef<number | null>(null);\n    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n    const scope = { __scopeMenu: props.__scopeMenu };\n\n    const clearOpenTimer = React.useCallback(() => {\n      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n      openTimerRef.current = null;\n    }, []);\n\n    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n\n    React.useEffect(() => {\n      const pointerGraceTimer = pointerGraceTimerRef.current;\n      return () => {\n        window.clearTimeout(pointerGraceTimer);\n        onPointerGraceIntentChange(null);\n      };\n    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n\n    return (\n      <MenuAnchor asChild {...scope}>\n        <MenuItemImpl\n          id={subContext.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={subContext.contentId}\n          data-state={getOpenState(context.open)}\n          {...props}\n          ref={composeRefs(forwardedRef, subContext.onTriggerChange)}\n          // This is redundant for mouse users but we cannot determine pointer type from\n          // click event and we cannot use pointerup event (see git history for reasons why)\n          onClick={(event) => {\n            props.onClick?.(event);\n            if (props.disabled || event.defaultPrevented) return;\n            /**\n             * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n             * and we rely heavily on `onFocusOutside` for submenus to close when switching\n             * between separate submenus.\n             */\n            event.currentTarget.focus();\n            if (!context.open) context.onOpenChange(true);\n          }}\n          onPointerMove={composeEventHandlers(\n            props.onPointerMove,\n            whenMouse((event) => {\n              contentContext.onItemEnter(event);\n              if (event.defaultPrevented) return;\n              if (!props.disabled && !context.open && !openTimerRef.current) {\n                contentContext.onPointerGraceIntentChange(null);\n                openTimerRef.current = window.setTimeout(() => {\n                  context.onOpenChange(true);\n                  clearOpenTimer();\n                }, 100);\n              }\n            })\n          )}\n          onPointerLeave={composeEventHandlers(\n            props.onPointerLeave,\n            whenMouse((event) => {\n              clearOpenTimer();\n\n              const contentRect = context.content?.getBoundingClientRect();\n              if (contentRect) {\n                // TODO: make sure to update this when we change positioning logic\n                const side = context.content?.dataset.side as Side;\n                const rightSide = side === 'right';\n                const bleed = rightSide ? -5 : +5;\n                const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n\n                contentContext.onPointerGraceIntentChange({\n                  area: [\n                    // Apply a bleed on clientX to ensure that our exit point is\n                    // consistently within polygon bounds\n                    { x: event.clientX + bleed, y: event.clientY },\n                    { x: contentNearEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.bottom },\n                    { x: contentNearEdge, y: contentRect.bottom },\n                  ],\n                  side,\n                });\n\n                window.clearTimeout(pointerGraceTimerRef.current);\n                pointerGraceTimerRef.current = window.setTimeout(\n                  () => contentContext.onPointerGraceIntentChange(null),\n                  300\n                );\n              } else {\n                contentContext.onTriggerLeave(event);\n                if (event.defaultPrevented) return;\n\n                // There's 100ms where the user may leave an item before the submenu was opened.\n                contentContext.onPointerGraceIntentChange(null);\n              }\n            })\n          )}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isTypingAhead = contentContext.searchRef.current !== '';\n            if (props.disabled || (isTypingAhead && event.key === ' ')) return;\n            if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n              context.onOpenChange(true);\n              // The trigger may hold focus if opened via pointer interaction\n              // so we ensure content is given focus again when switching to keyboard.\n              context.content?.focus();\n              // prevent window from scrolling\n              event.preventDefault();\n            }\n          })}\n        />\n      </MenuAnchor>\n    );\n  }\n);\n\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_CONTENT_NAME = 'MenuSubContent';\n\ntype MenuSubContentElement = MenuContentImplElement;\ninterface MenuSubContentProps\n  extends Omit<\n    MenuContentImplProps,\n    keyof MenuContentImplPrivateProps | 'onCloseAutoFocus' | 'side' | 'align'\n  > {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuSubContent = React.forwardRef<MenuSubContentElement, MenuSubContentProps>(\n  (props: ScopedProps<MenuSubContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...subContentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuSubContentElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            <MenuContentImpl\n              id={subContext.contentId}\n              aria-labelledby={subContext.triggerId}\n              {...subContentProps}\n              ref={composedRefs}\n              align=\"start\"\n              side={rootContext.dir === 'rtl' ? 'left' : 'right'}\n              disableOutsidePointerEvents={false}\n              disableOutsideScroll={false}\n              trapFocus={false}\n              onOpenAutoFocus={(event) => {\n                // when opening a submenu, focus content for keyboard users only\n                if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();\n                event.preventDefault();\n              }}\n              // The menu might close because of focusing another menu item in the parent menu. We\n              // don't want it to refocus the trigger in that case so we handle trigger focus ourselves.\n              onCloseAutoFocus={(event) => event.preventDefault()}\n              onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n                // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n                // on pointer interaction.\n                if (event.target !== subContext.trigger) context.onOpenChange(false);\n              })}\n              onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, rootContext.onClose)}\n              onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                // Submenu key events bubble through portals. We only care about keys in this menu.\n                const isKeyDownInside = event.currentTarget.contains(event.target as HTMLElement);\n                const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n                if (isKeyDownInside && isCloseKey) {\n                  context.onOpenChange(false);\n                  // We focus manually because we prevented it in `onCloseAutoFocus`\n                  subContext.trigger?.focus();\n                  // prevent window from scrolling\n                  event.preventDefault();\n                }\n              })}\n            />\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\nMenuSubContent.displayName = SUB_CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction getCheckedState(checked: boolean) {\n  return checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\ntype Side = 'left' | 'right';\ntype GraceIntent = { area: Polygon; side: Side };\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event: React.PointerEvent, area?: Polygon) {\n  if (!area) return false;\n  const cursorPos = { x: event.clientX, y: event.clientY };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\nconst Root = Menu;\nconst Anchor = MenuAnchor;\nconst Portal = MenuPortal;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\nconst Sub = MenuSub;\nconst SubTrigger = MenuSubTrigger;\nconst SubContent = MenuSubContent;\n\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n};\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n};\n"],
  "mappings": "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",
  "names": ["createCollection", "name", "PROVIDER_NAME", "createCollectionContext", "createCollectionScope", "createContextScope", "CollectionProviderImpl", "useCollectionContext", "collectionRef", "current", "itemMap", "Map", "CollectionProvider", "props", "children", "ref", "React", "useRef", "$6vYhU$react", "COLLECTION_SLOT_NAME", "CollectionSlot", "forwardRef", "forwardedRef", "context", "scope", "composedRefs", "useComposedRefs", "ITEM_SLOT_NAME", "ITEM_DATA_ATTR", "CollectionItemSlot", "itemData", "useEffect", "set", "delete", "useCollection", "getItems", "useCallback", "collectionNode", "orderedNodes", "Array", "from", "querySelectorAll", "items", "values", "orderedItems", "sort", "a", "b", "indexOf", "Provider", "Slot", "ItemSlot", "DirectionContext", "React", "undefined", "useDirection", "localDir", "globalDir", "React", "DirectionContext", "ENTRY_FOCUS", "EVENT_OPTIONS", "bubbles", "cancelable", "GROUP_NAME", "Collection", "useCollection", "createCollectionScope", "createCollection", "createRovingFocusGroupContext", "createRovingFocusGroupScope", "createContextScope", "RovingFocusProvider", "useRovingFocusContext", "RovingFocusGroup", "React", "props", "forwardedRef", "$98Iye$createElement", "__scopeRovingFocusGroup", "RovingFocusGroupImpl", "currentTabStopId", "currentTabStopIdProp", "groupProps", "ref", "composedRefs", "useComposedRefs", "direction", "useDirection", "dir", "setCurrentTabStopId", "useControllableState", "prop", "defaultProp", "defaultCurrentTabStopId", "onChange", "onCurrentTabStopIdChange", "isTabbingBackOut", "setIsTabbingBackOut", "handleEntryFocus", "useCallbackRef", "onEntryFocus", "getItems", "isClickFocusRef", "node", "current", "addEventListener", "removeEventListener", "tabStopId", "orientation", "outline", "style", "composeEventHandlers", "onMouseDown", "onFocus", "event", "isKeyboardFocus", "target", "currentTarget", "entryFocusEvent", "CustomEvent", "dispatchEvent", "defaultPrevented", "items", "filter", "item", "focusable", "activeItem", "find", "active", "currentItem", "id", "candidateItems", "Boolean", "candidateNodes", "map", "focusFirst", "onBlur", "ITEM_NAME", "RovingFocusGroupItem", "itemProps", "useId", "context", "isCurrentTabStop", "preventDefault", "onItemFocus", "onKeyDown", "key", "shiftKey", "onItemShiftTab", "focusIntent", "getFocusIntent", "undefined", "reverse", "currentIndex", "indexOf", "loop", "wrapArray", "slice", "setTimeout", "MAP_KEY_TO_FOCUS_INTENT", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "PageUp", "Home", "PageDown", "End", "getDirectionAwareKey", "includes", "candidates", "PREVIOUSLY_FOCUSED_ELEMENT", "document", "activeElement", "candidate", "focus", "array", "startIndex", "_", "index", "length", "Root", "Item", "SELECTION_KEYS", "FIRST_KEYS", "LAST_KEYS", "FIRST_LAST_KEYS", "SUB_OPEN_KEYS", "ltr", "rtl", "SUB_CLOSE_KEYS", "MENU_NAME", "Collection", "useCollection", "createCollectionScope", "createCollection", "createMenuContext", "createMenuScope", "createContextScope", "createPopperScope", "createRovingFocusGroupScope", "usePopperScope", "useRovingFocusGroupScope", "MenuProvider", "useMenuContext", "MenuRootProvider", "useMenuRootContext", "Menu", "props", "modal", "popperScope", "__scopeMenu", "content", "setContent", "React", "isUsingKeyboardRef", "handleOpenChange", "useCallbackRef", "onOpenChange", "direction", "useDirection", "dir", "handleKeyDown", "current", "document", "addEventListener", "handlePointer", "capture", "once", "removeEventListener", "$epM9y$createElement", "children", "ANCHOR_NAME", "MenuAnchor", "forwardedRef", "anchorProps", "PORTAL_NAME", "PortalProvider", "usePortalContext", "forceMount", "undefined", "MenuPortal", "container", "context", "open", "CONTENT_NAME", "MenuContentProvider", "useMenuContentContext", "MenuContent", "portalContext", "contentProps", "rootContext", "MenuRootContentModal", "ref", "composedRefs", "useComposedRefs", "hideOthers", "composeEventHandlers", "onFocusOutside", "event", "preventDefault", "checkForDefaultPrevented", "MenuRootContentNonModal", "MenuContentImpl", "rovingFocusGroupScope", "getItems", "currentItemId", "setCurrentItemId", "contentRef", "onContentChange", "timerRef", "searchRef", "pointerGraceTimerRef", "pointerGraceIntentRef", "pointerDirRef", "lastPointerXRef", "ScrollLockWrapper", "disableOutsideScroll", "RemoveScroll", "scrollLockWrapperProps", "as", "Slot", "allowPinchZoom", "handleTypeaheadSearch", "key", "search", "items", "filter", "item", "disabled", "currentItem", "activeElement", "currentMatch", "find", "textValue", "values", "map", "nextMatch", "getNextMatch", "newItem", "updateSearch", "value", "window", "clearTimeout", "setTimeout", "focus", "useFocusGuards", "isPointerMovingToSubmenu", "isMovingTowards", "side", "isPointerInGraceArea", "area", "intent", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus", "getOpenState", "outline", "style", "onKeyDown", "target", "isKeyDownInside", "closest", "currentTarget", "isModifierKey", "ctrlKey", "altKey", "metaKey", "isCharacterKey", "length", "includes", "candidateNodes", "reverse", "focusFirst", "onBlur", "contains", "onPointerMove", "whenMouse", "pointerXHasChanged", "clientX", "newDir", "GROUP_NAME", "MenuGroup", "groupProps", "LABEL_NAME", "MenuLabel", "labelProps", "ITEM_NAME", "ITEM_SELECT", "MenuItem", "itemProps", "contentContext", "isPointerDownRef", "handleSelect", "menuItem", "itemSelectEvent", "CustomEvent", "bubbles", "cancelable", "onSelect", "dispatchDiscreteCustomEvent", "defaultPrevented", "onClose", "onClick", "onPointerDown", "onPointerUp", "click", "isTypingAhead", "MenuItemImpl", "isFocused", "setIsFocused", "textContent", "setTextContent", "trim", "onItemLeave", "onItemEnter", "onPointerLeave", "onFocus", "CHECKBOX_ITEM_NAME", "MenuCheckboxItem", "checkboxItemProps", "checked", "getCheckedState", "onCheckedChange", "RADIO_GROUP_NAME", "RadioGroupProvider", "useRadioGroupContext", "onValueChange", "MenuRadioGroup", "handleValueChange", "RADIO_ITEM_NAME", "MenuRadioItem", "radioItemProps", "ITEM_INDICATOR_NAME", "ItemIndicatorProvider", "useItemIndicatorContext", "MenuItemIndicator", "itemIndicatorProps", "indicatorContext", "SEPARATOR_NAME", "MenuSeparator", "separatorProps", "ARROW_NAME", "MenuArrow", "arrowProps", "SUB_NAME", "MenuSubProvider", "useMenuSubContext", "MenuSub", "parentMenuContext", "trigger", "setTrigger", "useId", "SUB_TRIGGER_NAME", "MenuSubTrigger", "subContext", "openTimerRef", "onPointerGraceIntentChange", "scope", "clearOpenTimer", "pointerGraceTimer", "triggerId", "contentId", "composeRefs", "onTriggerChange", "contentRect", "getBoundingClientRect", "dataset", "rightSide", "bleed", "contentNearEdge", "contentFarEdge", "x", "y", "clientY", "top", "bottom", "onTriggerLeave", "SUB_CONTENT_NAME", "MenuSubContent", "subContentProps", "onEscapeKeyDown", "isCloseKey", "candidates", "PREVIOUSLY_FOCUSED_ELEMENT", "candidate", "wrapArray", "array", "startIndex", "_", "index", "isRepeated", "Array", "from", "every", "char", "normalizedSearch", "currentMatchIndex", "indexOf", "wrappedValues", "Math", "max", "excludeCurrentMatch", "v", "toLowerCase", "startsWith", "isPointInPolygon", "point", "polygon", "inside", "i", "j", "xi", "yi", "xj", "yj", "intersect", "cursorPos", "handler", "pointerType", "Root", "Anchor", "Portal", "Content", "Group", "Label", "Item", "CheckboxItem", "RadioGroup", "RadioItem", "ItemIndicator", "Separator", "Arrow", "Sub", "SubTrigger", "SubContent"]
}
