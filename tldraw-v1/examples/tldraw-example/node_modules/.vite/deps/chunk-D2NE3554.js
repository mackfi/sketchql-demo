// ../../node_modules/@liveblocks/client/shared.mjs
var _emittedDeprecationWarnings = /* @__PURE__ */ new Set();
function deprecate(message, key = message) {
  _emittedDeprecationWarnings.has(key) || (_emittedDeprecationWarnings.add(key), console.error(`DEPRECATION WARNING: ${message}`));
}
function throwUsageError(message) {
  if (true) {
    const usageError = new Error(message);
    throw usageError.name = "Usage error", usageError;
  }
}
function errorIf(condition, message) {
  condition && throwUsageError(message);
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
  if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
  }
  return t;
}
function assertNever(_value, errmsg) {
  throw new Error(errmsg);
}
function nn(value, errmsg = "Expected value to be non-nullable") {
  return function(condition, errmsg2) {
    if (!condition) {
      const err = new Error(errmsg2);
      throw err.name = "Assertion failure", err;
    }
  }(null != value, errmsg), value;
}
var ClientMsgCode;
var OpCode;
var CrdtType;
var ServerMsgCode;
var WebsocketCloseCodes;
var OpSource;
function isRootCrdt(crdt) {
  return crdt.type === CrdtType.OBJECT && !isChildCrdt(crdt);
}
function isChildCrdt(crdt) {
  return void 0 !== crdt.parentId && void 0 !== crdt.parentKey;
}
function isRoomEventName(value) {
  return "my-presence" === value || "others" === value || "event" === value || "error" === value || "connection" === value;
}
function HasParent(node, key) {
  return Object.freeze({ type: "HasParent", node, key });
}
!function(ClientMsgCode2) {
  ClientMsgCode2[ClientMsgCode2.UPDATE_PRESENCE = 100] = "UPDATE_PRESENCE", ClientMsgCode2[ClientMsgCode2.BROADCAST_EVENT = 103] = "BROADCAST_EVENT", ClientMsgCode2[ClientMsgCode2.FETCH_STORAGE = 200] = "FETCH_STORAGE", ClientMsgCode2[ClientMsgCode2.UPDATE_STORAGE = 201] = "UPDATE_STORAGE";
}(ClientMsgCode || (ClientMsgCode = {})), function(OpCode2) {
  OpCode2[OpCode2.INIT = 0] = "INIT", OpCode2[OpCode2.SET_PARENT_KEY = 1] = "SET_PARENT_KEY", OpCode2[OpCode2.CREATE_LIST = 2] = "CREATE_LIST", OpCode2[OpCode2.UPDATE_OBJECT = 3] = "UPDATE_OBJECT", OpCode2[OpCode2.CREATE_OBJECT = 4] = "CREATE_OBJECT", OpCode2[OpCode2.DELETE_CRDT = 5] = "DELETE_CRDT", OpCode2[OpCode2.DELETE_OBJECT_KEY = 6] = "DELETE_OBJECT_KEY", OpCode2[OpCode2.CREATE_MAP = 7] = "CREATE_MAP", OpCode2[OpCode2.CREATE_REGISTER = 8] = "CREATE_REGISTER";
}(OpCode || (OpCode = {})), function(CrdtType2) {
  CrdtType2[CrdtType2.OBJECT = 0] = "OBJECT", CrdtType2[CrdtType2.LIST = 1] = "LIST", CrdtType2[CrdtType2.MAP = 2] = "MAP", CrdtType2[CrdtType2.REGISTER = 3] = "REGISTER";
}(CrdtType || (CrdtType = {})), function(ServerMsgCode2) {
  ServerMsgCode2[ServerMsgCode2.UPDATE_PRESENCE = 100] = "UPDATE_PRESENCE", ServerMsgCode2[ServerMsgCode2.USER_JOINED = 101] = "USER_JOINED", ServerMsgCode2[ServerMsgCode2.USER_LEFT = 102] = "USER_LEFT", ServerMsgCode2[ServerMsgCode2.BROADCASTED_EVENT = 103] = "BROADCASTED_EVENT", ServerMsgCode2[ServerMsgCode2.ROOM_STATE = 104] = "ROOM_STATE", ServerMsgCode2[ServerMsgCode2.INITIAL_STORAGE_STATE = 200] = "INITIAL_STORAGE_STATE", ServerMsgCode2[ServerMsgCode2.UPDATE_STORAGE = 201] = "UPDATE_STORAGE";
}(ServerMsgCode || (ServerMsgCode = {})), function(WebsocketCloseCodes2) {
  WebsocketCloseCodes2[WebsocketCloseCodes2.CLOSE_ABNORMAL = 1006] = "CLOSE_ABNORMAL", WebsocketCloseCodes2[WebsocketCloseCodes2.INVALID_MESSAGE_FORMAT = 4e3] = "INVALID_MESSAGE_FORMAT", WebsocketCloseCodes2[WebsocketCloseCodes2.NOT_ALLOWED = 4001] = "NOT_ALLOWED", WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002] = "MAX_NUMBER_OF_MESSAGES_PER_SECONDS", WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS", WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004] = "MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP", WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM", WebsocketCloseCodes2[WebsocketCloseCodes2.CLOSE_WITHOUT_RETRY = 4999] = "CLOSE_WITHOUT_RETRY";
}(WebsocketCloseCodes || (WebsocketCloseCodes = {})), function(OpSource2) {
  OpSource2[OpSource2.UNDOREDO_RECONNECT = 0] = "UNDOREDO_RECONNECT", OpSource2[OpSource2.REMOTE = 1] = "REMOTE", OpSource2[OpSource2.ACK = 2] = "ACK";
}(OpSource || (OpSource = {}));
var NoParent = Object.freeze({ type: "NoParent" });
function Orphaned(oldKey) {
  return Object.freeze({ type: "Orphaned", oldKey });
}
var AbstractCrdt = class {
  constructor() {
    this._parent = NoParent;
  }
  _getParentKeyOrThrow() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        throw new Error("Parent key is missing");
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  get _doc() {
    return this.__doc;
  }
  get roomId() {
    return this.__doc ? this.__doc.roomId : null;
  }
  get _id() {
    return this.__id;
  }
  get parent() {
    return this._parent;
  }
  get _parentNode() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.node;
      case "NoParent":
      case "Orphaned":
        return null;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  get _parentKey() {
    switch (this.parent.type) {
      case "HasParent":
        return this.parent.key;
      case "NoParent":
        return null;
      case "Orphaned":
        return this.parent.oldKey;
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  _apply(op, _isLocal) {
    return op.type === OpCode.DELETE_CRDT && "HasParent" === this.parent.type ? this.parent.node._detachChild(this) : { modified: false };
  }
  _setParentLink(newParentNode, newParentKey) {
    switch (this.parent.type) {
      case "HasParent":
        if (this.parent.node !== newParentNode)
          throw new Error("Cannot attach parent if it already exist");
        return void (this._parent = HasParent(newParentNode, newParentKey));
      case "Orphaned":
      case "NoParent":
        return void (this._parent = HasParent(newParentNode, newParentKey));
      default:
        return assertNever(this.parent, "Unknown state");
    }
  }
  _attach(id, doc) {
    if (this.__id || this.__doc)
      throw new Error("Cannot attach if CRDT is already attached");
    doc.addItem(id, this), this.__id = id, this.__doc = doc;
  }
  _detach() {
    switch (this.__doc && this.__id && this.__doc.deleteItem(this.__id), this.parent.type) {
      case "HasParent":
        this._parent = Orphaned(this.parent.key);
        break;
      case "NoParent":
        this._parent = NoParent;
        break;
      case "Orphaned":
        this._parent = Orphaned(this.parent.oldKey);
        break;
      default:
        assertNever(this.parent, "Unknown state");
    }
    this.__doc = void 0;
  }
};
var LiveRegister = class extends AbstractCrdt {
  constructor(data) {
    super(), this._data = data;
  }
  get data() {
    return this._data;
  }
  static _deserialize([id, item], _parentToChildren, doc) {
    const register = new LiveRegister(item.data);
    return register._attach(id, doc), register;
  }
  _serialize(parentId, parentKey, doc) {
    if (null == this._id || null == parentId || null == parentKey)
      throw new Error(
        "Cannot serialize register if parentId or parentKey is undefined"
      );
    return [
      {
        type: OpCode.CREATE_REGISTER,
        opId: null == doc ? void 0 : doc.generateOpId(),
        id: this._id,
        parentId,
        parentKey,
        data: this.data
      }
    ];
  }
  _toSerializedCrdt() {
    if ("HasParent" !== this.parent.type)
      throw new Error("Cannot serialize LiveRegister if parent is missing");
    return {
      type: CrdtType.REGISTER,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key,
      data: this.data
    };
  }
  _attachChild(_op) {
    throw new Error("Method not implemented.");
  }
  _detachChild(_crdt) {
    throw new Error("Method not implemented.");
  }
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
};
function makePosition(before, after) {
  return null != before && null != after ? pos(makePositionFromCodes(posCodes(before), posCodes(after))) : null != before ? function(before2) {
    const result = [], beforeCodes = posCodes(before2);
    for (let i = 0; i < beforeCodes.length; i++) {
      const code = beforeCodes[i];
      if (126 !== code) {
        result.push(code + 1);
        break;
      }
      if (result.push(code), beforeCodes.length - 1 === i) {
        result.push(33);
        break;
      }
    }
    return pos(result);
  }(before) : null != after ? function(after2) {
    const result = [], afterCodes = posCodes(after2);
    for (let i = 0; i < afterCodes.length; i++) {
      const code = afterCodes[i];
      if (!(code <= 33)) {
        result.push(code - 1);
        break;
      }
      if (result.push(32), afterCodes.length - 1 === i) {
        result.push(126);
        break;
      }
    }
    return pos(result);
  }(after) : pos([33]);
}
function makePositionFromCodes(before, after) {
  let index = 0;
  const result = [];
  for (; ; ) {
    const beforeDigit = before[index] || 32, afterDigit = after[index] || 126;
    if (beforeDigit > afterDigit)
      throw new Error(
        `Impossible to generate position between ${before} and ${after}`
      );
    if (beforeDigit === afterDigit) {
      result.push(beforeDigit), index++;
      continue;
    }
    if (afterDigit - beforeDigit == 1) {
      result.push(beforeDigit), result.push(...makePositionFromCodes(before.slice(index + 1), []));
      break;
    }
    const mid = afterDigit + beforeDigit >> 1;
    result.push(mid);
    break;
  }
  return result;
}
function posCodes(str) {
  const codes = [];
  for (let i = 0; i < str.length; i++)
    codes.push(str.charCodeAt(i));
  return codes;
}
function pos(codes) {
  return String.fromCharCode(...codes);
}
function comparePosition(posA, posB) {
  const aCodes = posCodes(posA), bCodes = posCodes(posB), maxLength = Math.max(aCodes.length, bCodes.length);
  for (let i = 0; i < maxLength; i++) {
    const a = null == aCodes[i] ? 32 : aCodes[i], b = null == bCodes[i] ? 32 : bCodes[i];
    if (a !== b)
      return a - b;
  }
  throw new Error(
    `Impossible to compare similar position "${posA}" and "${posB}"`
  );
}
function compareNodePosition(itemA, itemB) {
  return comparePosition(
    itemA._getParentKeyOrThrow(),
    itemB._getParentKeyOrThrow()
  );
}
var LiveList = class extends AbstractCrdt {
  constructor(items = []) {
    let position;
    super(), this._items = [], this._implicitlyDeletedItems = /* @__PURE__ */ new Set(), this._unacknowledgedSets = /* @__PURE__ */ new Map();
    for (let i = 0; i < items.length; i++) {
      const newPosition = makePosition(position), item = lsonToLiveNode(items[i]);
      item._setParentLink(this, newPosition), this._items.push(item), position = newPosition;
    }
  }
  static _deserialize([id], parentToChildren, doc) {
    const list = new LiveList();
    list._attach(id, doc);
    const children = parentToChildren.get(id);
    if (null == children)
      return list;
    for (const [id2, crdt] of children) {
      const child = deserialize([id2, crdt], parentToChildren, doc);
      child._setParentLink(list, crdt.parentKey), list._insertAndSort(child);
    }
    return list;
  }
  _serialize(parentId, parentKey, doc) {
    if (null == this._id)
      throw new Error("Cannot serialize item is not attached");
    const ops = [], op = {
      id: this._id,
      opId: null == doc ? void 0 : doc.generateOpId(),
      type: OpCode.CREATE_LIST,
      parentId,
      parentKey
    };
    ops.push(op);
    for (const item of this._items)
      ops.push(...item._serialize(this._id, item._getParentKeyOrThrow(), doc));
    return ops;
  }
  _insertAndSort(item) {
    this._items.push(item), this._sortItems();
  }
  _sortItems() {
    this._items.sort(compareNodePosition);
  }
  _indexOfPosition(position) {
    return this._items.findIndex(
      (item) => item._getParentKeyOrThrow() === position
    );
  }
  _attach(id, doc) {
    super._attach(id, doc);
    for (const item of this._items)
      item._attach(doc.generateId(), doc);
  }
  _detach() {
    super._detach();
    for (const item of this._items)
      item._detach();
  }
  _applySetRemote(op) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    const { id, parentKey: key } = op, child = creationOpToLiveNode(op);
    child._attach(id, this._doc), child._setParentLink(this, key);
    const deletedId = op.deletedId, indexOfItemWithSamePosition = this._indexOfPosition(key);
    if (-1 !== indexOfItemWithSamePosition) {
      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];
      if (itemWithSamePosition._id === deletedId)
        return itemWithSamePosition._detach(), this._items[indexOfItemWithSamePosition] = child, {
          modified: makeUpdate(this, [
            setDelta(indexOfItemWithSamePosition, child)
          ]),
          reverse: []
        };
      {
        this._implicitlyDeletedItems.add(itemWithSamePosition), this._items[indexOfItemWithSamePosition] = child;
        const delta = [setDelta(indexOfItemWithSamePosition, child)], deleteDelta2 = this._detachItemAssociatedToSetOperation(op.deletedId);
        return deleteDelta2 && delta.push(deleteDelta2), { modified: makeUpdate(this, delta), reverse: [] };
      }
    }
    {
      const updates = [], deleteDelta2 = this._detachItemAssociatedToSetOperation(op.deletedId);
      return deleteDelta2 && updates.push(deleteDelta2), this._insertAndSort(child), updates.push(insertDelta(this._indexOfPosition(key), child)), { reverse: [], modified: makeUpdate(this, updates) };
    }
  }
  _applySetAck(op) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    const delta = [], deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
    deletedDelta && delta.push(deletedDelta);
    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);
    if (null != unacknowledgedOpId) {
      if (unacknowledgedOpId !== op.opId)
        return 0 === delta.length ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };
      this._unacknowledgedSets.delete(op.parentKey);
    }
    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey), existingItem = this._items.find((item) => item._id === op.id);
    if (null != existingItem) {
      if (existingItem._parentKey === op.parentKey)
        return {
          modified: delta.length > 0 && makeUpdate(this, delta),
          reverse: []
        };
      -1 !== indexOfItemWithSamePosition && (this._implicitlyDeletedItems.add(
        this._items[indexOfItemWithSamePosition]
      ), this._items.splice(indexOfItemWithSamePosition, 1), delta.push(deleteDelta(indexOfItemWithSamePosition)));
      const previousIndex = this._items.indexOf(existingItem);
      existingItem._setParentLink(this, op.parentKey), this._sortItems();
      const newIndex = this._items.indexOf(existingItem);
      return newIndex !== previousIndex && delta.push(moveDelta(previousIndex, newIndex, existingItem)), { modified: delta.length > 0 && makeUpdate(this, delta), reverse: [] };
    }
    {
      const orphan = this._doc.getItem(op.id);
      if (orphan && this._implicitlyDeletedItems.has(orphan)) {
        orphan._setParentLink(this, op.parentKey), this._implicitlyDeletedItems.delete(orphan), this._insertAndSort(orphan);
        const recreatedItemIndex = this._items.indexOf(orphan);
        return {
          modified: makeUpdate(this, [
            -1 === indexOfItemWithSamePosition ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),
            ...delta
          ]),
          reverse: []
        };
      }
      {
        -1 !== indexOfItemWithSamePosition && this._items.splice(indexOfItemWithSamePosition, 1);
        const { newItem, newIndex } = this._createAttachItemAndSort(op, op.parentKey);
        return {
          modified: makeUpdate(this, [
            -1 === indexOfItemWithSamePosition ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),
            ...delta
          ]),
          reverse: []
        };
      }
    }
  }
  _detachItemAssociatedToSetOperation(deletedId) {
    if (null == deletedId || null == this._doc)
      return null;
    const deletedItem = this._doc.getItem(deletedId);
    if (null == deletedItem)
      return null;
    const result = this._detachChild(deletedItem);
    return false === result.modified ? null : result.modified.updates[0];
  }
  _applyRemoteInsert(op) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    const key = op.parentKey, existingItemIndex = this._indexOfPosition(key);
    -1 !== existingItemIndex && this._shiftItemPosition(existingItemIndex, key);
    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);
    return {
      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
      reverse: []
    };
  }
  _applyInsertAck(op) {
    const existingItem = this._items.find((item) => item._id === op.id), key = op.parentKey, itemIndexAtPosition = this._indexOfPosition(key);
    if (existingItem) {
      if (existingItem._parentKey === key)
        return { modified: false };
      {
        const oldPositionIndex = this._items.indexOf(existingItem);
        -1 !== itemIndexAtPosition && this._shiftItemPosition(itemIndexAtPosition, key), existingItem._setParentLink(this, key), this._sortItems();
        const newIndex = this._indexOfPosition(key);
        return newIndex === oldPositionIndex ? { modified: false } : {
          modified: makeUpdate(this, [
            moveDelta(oldPositionIndex, newIndex, existingItem)
          ]),
          reverse: []
        };
      }
    }
    {
      const orphan = nn(this._doc).getItem(op.id);
      if (orphan && this._implicitlyDeletedItems.has(orphan)) {
        orphan._setParentLink(this, key), this._implicitlyDeletedItems.delete(orphan), this._insertAndSort(orphan);
        return {
          modified: makeUpdate(this, [
            insertDelta(this._indexOfPosition(key), orphan)
          ]),
          reverse: []
        };
      }
      {
        -1 !== itemIndexAtPosition && this._shiftItemPosition(itemIndexAtPosition, key);
        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);
        return {
          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),
          reverse: []
        };
      }
    }
  }
  _applyInsertUndoRedo(op) {
    var _a;
    const { id, parentKey: key } = op, child = creationOpToLiveNode(op);
    if (void 0 !== (null === (_a = this._doc) || void 0 === _a ? void 0 : _a.getItem(id)))
      return { modified: false };
    child._attach(id, nn(this._doc)), child._setParentLink(this, key);
    const existingItemIndex = this._indexOfPosition(key);
    let newKey = key;
    if (-1 !== existingItemIndex) {
      newKey = makePosition(
        this._items[existingItemIndex] ? this._items[existingItemIndex]._getParentKeyOrThrow() : void 0,
        this._items[existingItemIndex + 1] ? this._items[existingItemIndex + 1]._getParentKeyOrThrow() : void 0
      ), child._setParentLink(this, newKey);
    }
    this._insertAndSort(child);
    return {
      modified: makeUpdate(this, [
        insertDelta(this._indexOfPosition(newKey), child)
      ]),
      reverse: [{ type: OpCode.DELETE_CRDT, id }]
    };
  }
  _applySetUndoRedo(op) {
    var _a;
    const { id, parentKey: key } = op, child = creationOpToLiveNode(op);
    if (void 0 !== (null === (_a = this._doc) || void 0 === _a ? void 0 : _a.getItem(id)))
      return { modified: false };
    this._unacknowledgedSets.set(key, nn(op.opId));
    const indexOfItemWithSameKey = this._indexOfPosition(key);
    child._attach(id, nn(this._doc)), child._setParentLink(this, key);
    const newKey = key;
    if (-1 !== indexOfItemWithSameKey) {
      const existingItem = this._items[indexOfItemWithSameKey];
      existingItem._detach(), this._items[indexOfItemWithSameKey] = child;
      const reverse = existingItem._serialize(nn(this._id), key, this._doc);
      addIntentAndDeletedIdToOperation(reverse, op.id);
      const delta = [setDelta(indexOfItemWithSameKey, child)], deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
      return deletedDelta && delta.push(deletedDelta), { modified: makeUpdate(this, delta), reverse };
    }
    {
      this._insertAndSort(child), this._detachItemAssociatedToSetOperation(op.deletedId);
      const newIndex = this._indexOfPosition(newKey);
      return {
        reverse: [{ type: OpCode.DELETE_CRDT, id }],
        modified: makeUpdate(this, [insertDelta(newIndex, child)])
      };
    }
  }
  _attachChild(op, source) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    if ("set" === op.intent) {
      if (source === OpSource.REMOTE)
        return this._applySetRemote(op);
      if (source === OpSource.UNDOREDO_RECONNECT)
        return this._applySetUndoRedo(op);
      if (source === OpSource.ACK)
        return this._applySetAck(op);
    }
    return source === OpSource.REMOTE ? this._applyRemoteInsert(op) : source === OpSource.ACK ? this._applyInsertAck(op) : this._applyInsertUndoRedo(op);
  }
  _detachChild(child) {
    if (child) {
      const parentKey = nn(child._parentKey), reverse = child._serialize(nn(this._id), parentKey, this._doc), indexToDelete = this._items.indexOf(child);
      return -1 === indexToDelete ? { modified: false } : (this._items.splice(indexToDelete, 1), child._detach(), {
        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),
        reverse
      });
    }
    return { modified: false };
  }
  _applySetChildKeyRemote(newKey, child) {
    var _a;
    if (this._implicitlyDeletedItems.has(child)) {
      this._implicitlyDeletedItems.delete(child), child._setParentLink(this, newKey), this._insertAndSort(child);
      return {
        modified: makeUpdate(this, [
          insertDelta(this._items.indexOf(child), child)
        ]),
        reverse: []
      };
    }
    if (newKey === child._parentKey)
      return { modified: false };
    const existingItemIndex = this._indexOfPosition(newKey);
    if (-1 === existingItemIndex) {
      const previousIndex = this._items.indexOf(child);
      child._setParentLink(this, newKey), this._sortItems();
      const newIndex = this._items.indexOf(child);
      return newIndex === previousIndex ? { modified: false } : {
        modified: makeUpdate(this, [
          moveDelta(previousIndex, newIndex, child)
        ]),
        reverse: []
      };
    }
    {
      this._items[existingItemIndex]._setParentLink(
        this,
        makePosition(
          newKey,
          null === (_a = this._items[existingItemIndex + 1]) || void 0 === _a ? void 0 : _a._getParentKeyOrThrow()
        )
      );
      const previousIndex = this._items.indexOf(child);
      child._setParentLink(this, newKey), this._sortItems();
      const newIndex = this._items.indexOf(child);
      return newIndex === previousIndex ? { modified: false } : {
        modified: makeUpdate(this, [
          moveDelta(previousIndex, newIndex, child)
        ]),
        reverse: []
      };
    }
  }
  _applySetChildKeyAck(newKey, child) {
    var _a, _b;
    const previousKey = nn(child._parentKey);
    if (this._implicitlyDeletedItems.has(child)) {
      const existingItemIndex = this._indexOfPosition(newKey);
      return this._implicitlyDeletedItems.delete(child), -1 !== existingItemIndex && this._items[existingItemIndex]._setParentLink(
        this,
        makePosition(
          newKey,
          null === (_a = this._items[existingItemIndex + 1]) || void 0 === _a ? void 0 : _a._getParentKeyOrThrow()
        )
      ), child._setParentLink(this, newKey), this._insertAndSort(child), { modified: false };
    }
    {
      if (newKey === previousKey)
        return { modified: false };
      const previousIndex = this._items.indexOf(child), existingItemIndex = this._indexOfPosition(newKey);
      -1 !== existingItemIndex && this._items[existingItemIndex]._setParentLink(
        this,
        makePosition(
          newKey,
          null === (_b = this._items[existingItemIndex + 1]) || void 0 === _b ? void 0 : _b._getParentKeyOrThrow()
        )
      ), child._setParentLink(this, newKey), this._sortItems();
      const newIndex = this._items.indexOf(child);
      return previousIndex === newIndex ? { modified: false } : {
        modified: makeUpdate(this, [
          moveDelta(previousIndex, newIndex, child)
        ]),
        reverse: []
      };
    }
  }
  _applySetChildKeyUndoRedo(newKey, child) {
    var _a;
    const previousKey = nn(child._parentKey), previousIndex = this._items.indexOf(child), existingItemIndex = this._indexOfPosition(newKey);
    -1 !== existingItemIndex && this._items[existingItemIndex]._setParentLink(
      this,
      makePosition(
        newKey,
        null === (_a = this._items[existingItemIndex + 1]) || void 0 === _a ? void 0 : _a._getParentKeyOrThrow()
      )
    ), child._setParentLink(this, newKey), this._sortItems();
    const newIndex = this._items.indexOf(child);
    return previousIndex === newIndex ? { modified: false } : {
      modified: makeUpdate(this, [
        moveDelta(previousIndex, newIndex, child)
      ]),
      reverse: [
        {
          type: OpCode.SET_PARENT_KEY,
          id: nn(child._id),
          parentKey: previousKey
        }
      ]
    };
  }
  _setChildKey(newKey, child, source) {
    return source === OpSource.REMOTE ? this._applySetChildKeyRemote(newKey, child) : source === OpSource.ACK ? this._applySetChildKeyAck(newKey, child) : this._applySetChildKeyUndoRedo(newKey, child);
  }
  _apply(op, isLocal) {
    return super._apply(op, isLocal);
  }
  _toSerializedCrdt() {
    if ("HasParent" !== this.parent.type)
      throw new Error("Cannot serialize LiveList if parent is missing");
    return {
      type: CrdtType.LIST,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  get length() {
    return this._items.length;
  }
  push(element) {
    return this.insert(element, this.length);
  }
  insert(element, index) {
    if (index < 0 || index > this._items.length)
      throw new Error(
        `Cannot insert list item at index "${index}". index should be between 0 and ${this._items.length}`
      );
    const position = makePosition(
      this._items[index - 1] ? this._items[index - 1]._getParentKeyOrThrow() : void 0,
      this._items[index] ? this._items[index]._getParentKeyOrThrow() : void 0
    ), value = lsonToLiveNode(element);
    if (value._setParentLink(this, position), this._insertAndSort(value), this._doc && this._id) {
      const id = this._doc.generateId();
      value._attach(id, this._doc), this._doc.dispatch(
        value._serialize(this._id, position, this._doc),
        [{ type: OpCode.DELETE_CRDT, id }],
        /* @__PURE__ */ new Map([[this._id, makeUpdate(this, [insertDelta(index, value)])]])
      );
    }
  }
  move(index, targetIndex) {
    if (targetIndex < 0)
      throw new Error("targetIndex cannot be less than 0");
    if (targetIndex >= this._items.length)
      throw new Error(
        "targetIndex cannot be greater or equal than the list length"
      );
    if (index < 0)
      throw new Error("index cannot be less than 0");
    if (index >= this._items.length)
      throw new Error("index cannot be greater or equal than the list length");
    let beforePosition = null, afterPosition = null;
    index < targetIndex ? (afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._getParentKeyOrThrow(), beforePosition = this._items[targetIndex]._getParentKeyOrThrow()) : (afterPosition = this._items[targetIndex]._getParentKeyOrThrow(), beforePosition = 0 === targetIndex ? void 0 : this._items[targetIndex - 1]._getParentKeyOrThrow());
    const position = makePosition(beforePosition, afterPosition), item = this._items[index], previousPosition = item._getParentKeyOrThrow();
    if (item._setParentLink(this, position), this._sortItems(), this._doc && this._id) {
      const storageUpdates = /* @__PURE__ */ new Map([
        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]
      ]);
      this._doc.dispatch(
        [
          {
            type: OpCode.SET_PARENT_KEY,
            id: nn(item._id),
            opId: this._doc.generateOpId(),
            parentKey: position
          }
        ],
        [
          {
            type: OpCode.SET_PARENT_KEY,
            id: nn(item._id),
            parentKey: previousPosition
          }
        ],
        storageUpdates
      );
    }
  }
  delete(index) {
    if (index < 0 || index >= this._items.length)
      throw new Error(
        `Cannot delete list item at index "${index}". index should be between 0 and ${this._items.length - 1}`
      );
    const item = this._items[index];
    if (item._detach(), this._items.splice(index, 1), this._doc) {
      const childRecordId = item._id;
      if (childRecordId) {
        const storageUpdates = /* @__PURE__ */ new Map();
        storageUpdates.set(
          nn(this._id),
          makeUpdate(this, [deleteDelta(index)])
        ), this._doc.dispatch(
          [
            {
              id: childRecordId,
              opId: this._doc.generateOpId(),
              type: OpCode.DELETE_CRDT
            }
          ],
          item._serialize(nn(this._id), item._getParentKeyOrThrow()),
          storageUpdates
        );
      }
    }
  }
  clear() {
    if (this._doc) {
      const ops = [], reverseOps = [], updateDelta = [];
      for (const item of this._items) {
        item._detach();
        const childId = item._id;
        childId && (ops.push({
          type: OpCode.DELETE_CRDT,
          id: childId,
          opId: this._doc.generateOpId()
        }), reverseOps.push(
          ...item._serialize(nn(this._id), item._getParentKeyOrThrow())
        ), updateDelta.push(deleteDelta(0)));
      }
      this._items = [];
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta)), this._doc.dispatch(ops, reverseOps, storageUpdates);
    } else {
      for (const item of this._items)
        item._detach();
      this._items = [];
    }
  }
  set(index, item) {
    if (index < 0 || index >= this._items.length)
      throw new Error(
        `Cannot set list item at index "${index}". index should be between 0 and ${this._items.length - 1}`
      );
    const existingItem = this._items[index], position = existingItem._getParentKeyOrThrow(), existingId = existingItem._id;
    existingItem._detach();
    const value = lsonToLiveNode(item);
    if (value._setParentLink(this, position), this._items[index] = value, this._doc && this._id) {
      const id = this._doc.generateId();
      value._attach(id, this._doc);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));
      const ops = value._serialize(this._id, position, this._doc);
      addIntentAndDeletedIdToOperation(ops, existingId), this._unacknowledgedSets.set(position, nn(ops[0].opId));
      const reverseOps = existingItem._serialize(this._id, position, void 0);
      addIntentAndDeletedIdToOperation(reverseOps, id), this._doc.dispatch(ops, reverseOps, storageUpdates);
    }
  }
  toArray() {
    return this._items.map((entry) => liveNodeToLson(entry));
  }
  every(predicate) {
    return this.toArray().every(predicate);
  }
  filter(predicate) {
    return this.toArray().filter(predicate);
  }
  find(predicate) {
    return this.toArray().find(predicate);
  }
  findIndex(predicate) {
    return this.toArray().findIndex(predicate);
  }
  forEach(callbackfn) {
    return this.toArray().forEach(callbackfn);
  }
  get(index) {
    if (!(index < 0 || index >= this._items.length))
      return liveNodeToLson(this._items[index]);
  }
  indexOf(searchElement, fromIndex) {
    return this.toArray().indexOf(searchElement, fromIndex);
  }
  lastIndexOf(searchElement, fromIndex) {
    return this.toArray().lastIndexOf(searchElement, fromIndex);
  }
  map(callback) {
    return this._items.map((entry, i) => callback(liveNodeToLson(entry), i));
  }
  some(predicate) {
    return this.toArray().some(predicate);
  }
  [Symbol.iterator]() {
    return new LiveListIterator(this._items);
  }
  _createAttachItemAndSort(op, key) {
    const newItem = creationOpToLiveNode(op);
    newItem._attach(op.id, nn(this._doc)), newItem._setParentLink(this, key), this._insertAndSort(newItem);
    return { newItem, newIndex: this._indexOfPosition(key) };
  }
  _shiftItemPosition(index, key) {
    var _a;
    const shiftedPosition = makePosition(
      key,
      this._items.length > index + 1 ? null === (_a = this._items[index + 1]) || void 0 === _a ? void 0 : _a._getParentKeyOrThrow() : void 0
    );
    this._items[index]._setParentLink(this, shiftedPosition);
  }
};
var LiveListIterator = class {
  constructor(items) {
    this._innerIterator = items[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const result = this._innerIterator.next();
    if (result.done)
      return { done: true, value: void 0 };
    return { value: liveNodeToLson(result.value) };
  }
};
function makeUpdate(liveList, deltaUpdates) {
  return { node: liveList, type: "LiveList", updates: deltaUpdates };
}
function setDelta(index, item) {
  return {
    index,
    type: "set",
    item: item instanceof LiveRegister ? item.data : item
  };
}
function deleteDelta(index) {
  return { index, type: "delete" };
}
function insertDelta(index, item) {
  return {
    index,
    type: "insert",
    item: item instanceof LiveRegister ? item.data : item
  };
}
function moveDelta(previousIndex, index, item) {
  return {
    index,
    type: "move",
    previousIndex,
    item: item instanceof LiveRegister ? item.data : item
  };
}
function addIntentAndDeletedIdToOperation(ops, deletedId) {
  if (0 === ops.length)
    throw new Error(
      "Internal error. Serialized LiveStructure should have at least 1 operation"
    );
  const firstOp = ops[0];
  firstOp.intent = "set", firstOp.deletedId = deletedId;
}
var LiveMap = class extends AbstractCrdt {
  constructor(entries2) {
    if (super(), errorIf(
      null === entries2,
      "Support for calling `new LiveMap(null)` will be removed in @liveblocks/client 0.18. Please call as `new LiveMap()`, or `new LiveMap([])`."
    ), this.unacknowledgedSet = /* @__PURE__ */ new Map(), entries2) {
      const mappedEntries = [];
      for (const entry of entries2) {
        const value = lsonToLiveNode(entry[1]);
        value._setParentLink(this, entry[0]), mappedEntries.push([entry[0], value]);
      }
      this._map = new Map(mappedEntries);
    } else
      this._map = /* @__PURE__ */ new Map();
  }
  _serialize(parentId, parentKey, doc) {
    if (null == this._id)
      throw new Error("Cannot serialize item is not attached");
    const ops = [], op = {
      id: this._id,
      opId: null == doc ? void 0 : doc.generateOpId(),
      type: OpCode.CREATE_MAP,
      parentId,
      parentKey
    };
    ops.push(op);
    for (const [key, value] of this._map)
      ops.push(...value._serialize(this._id, key, doc));
    return ops;
  }
  static _deserialize([id, _item], parentToChildren, doc) {
    const map = new LiveMap();
    map._attach(id, doc);
    const children = parentToChildren.get(id);
    if (null == children)
      return map;
    for (const [id2, crdt] of children) {
      const child = deserialize([id2, crdt], parentToChildren, doc);
      child._setParentLink(map, crdt.parentKey), map._map.set(crdt.parentKey, child);
    }
    return map;
  }
  _attach(id, doc) {
    super._attach(id, doc);
    for (const [_key, value] of this._map)
      isLiveNode(value) && value._attach(doc.generateId(), doc);
  }
  _attachChild(op, source) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    const { id, parentKey, opId } = op, key = parentKey, child = creationOpToLiveNode(op);
    if (void 0 !== this._doc.getItem(id))
      return { modified: false };
    if (source === OpSource.ACK) {
      const lastUpdateOpId = this.unacknowledgedSet.get(key);
      if (lastUpdateOpId === opId)
        return this.unacknowledgedSet.delete(key), { modified: false };
      if (null != lastUpdateOpId)
        return { modified: false };
    } else
      source === OpSource.REMOTE && this.unacknowledgedSet.delete(key);
    const previousValue = this._map.get(key);
    let reverse;
    if (previousValue) {
      const thisId = nn(this._id);
      reverse = previousValue._serialize(thisId, key), previousValue._detach();
    } else
      reverse = [{ type: OpCode.DELETE_CRDT, id }];
    return child._setParentLink(this, key), child._attach(id, this._doc), this._map.set(key, child), {
      modified: {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "update" } }
      },
      reverse
    };
  }
  _detach() {
    super._detach();
    for (const item of this._map.values())
      item._detach();
  }
  _detachChild(child) {
    const id = nn(this._id), parentKey = nn(child._parentKey), reverse = child._serialize(id, parentKey, this._doc);
    for (const [key, value] of this._map)
      value === child && this._map.delete(key);
    child._detach();
    return {
      modified: {
        node: this,
        type: "LiveMap",
        updates: { [parentKey]: { type: "delete" } }
      },
      reverse
    };
  }
  _toSerializedCrdt() {
    if ("HasParent" !== this.parent.type)
      throw new Error("Cannot serialize LiveMap if parent is missing");
    return {
      type: CrdtType.MAP,
      parentId: nn(this.parent.node._id, "Parent node expected to have ID"),
      parentKey: this.parent.key
    };
  }
  get(key) {
    const value = this._map.get(key);
    if (null != value)
      return liveNodeToLson(value);
  }
  set(key, value) {
    const oldValue = this._map.get(key);
    oldValue && oldValue._detach();
    const item = lsonToLiveNode(value);
    if (item._setParentLink(this, key), this._map.set(key, item), this._doc && this._id) {
      const id = this._doc.generateId();
      item._attach(id, this._doc);
      const storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(this._id, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "update" } }
      });
      const ops = item._serialize(this._id, key, this._doc);
      this.unacknowledgedSet.set(key, nn(ops[0].opId)), this._doc.dispatch(
        item._serialize(this._id, key, this._doc),
        oldValue ? oldValue._serialize(this._id, key) : [{ type: OpCode.DELETE_CRDT, id }],
        storageUpdates
      );
    }
  }
  get size() {
    return this._map.size;
  }
  has(key) {
    return this._map.has(key);
  }
  delete(key) {
    const item = this._map.get(key);
    if (null == item)
      return false;
    if (item._detach(), this._map.delete(key), this._doc && item._id) {
      const thisId = nn(this._id), storageUpdates = /* @__PURE__ */ new Map();
      storageUpdates.set(thisId, {
        node: this,
        type: "LiveMap",
        updates: { [key]: { type: "delete" } }
      }), this._doc.dispatch(
        [
          {
            type: OpCode.DELETE_CRDT,
            id: item._id,
            opId: this._doc.generateOpId()
          }
        ],
        item._serialize(thisId, key),
        storageUpdates
      );
    }
    return true;
  }
  entries() {
    const innerIterator = this._map.entries();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done)
          return { done: true, value: void 0 };
        return {
          value: [
            iteratorValue.value[0],
            liveNodeToLson(iteratorValue.value[1])
          ]
        };
      }
    };
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  keys() {
    return this._map.keys();
  }
  values() {
    const innerIterator = this._map.values();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const iteratorValue = innerIterator.next();
        if (iteratorValue.done)
          return { done: true, value: void 0 };
        return { value: liveNodeToLson(iteratorValue.value) };
      }
    };
  }
  forEach(callback) {
    for (const entry of this)
      callback(entry[1], entry[0], this);
  }
};
var LiveObject = class extends AbstractCrdt {
  constructor(obj = {}) {
    super(), this._propToLastUpdate = /* @__PURE__ */ new Map();
    for (const key in obj) {
      const value = obj[key];
      void 0 !== value && isLiveNode(value) && value._setParentLink(this, key);
    }
    this._map = new Map(Object.entries(obj));
  }
  _serialize(parentId, parentKey, doc) {
    if (null == this._id)
      throw new Error("Cannot serialize item is not attached");
    const opId = null == doc ? void 0 : doc.generateOpId(), ops = [], op = void 0 !== parentId && void 0 !== parentKey ? {
      type: OpCode.CREATE_OBJECT,
      id: this._id,
      opId,
      parentId,
      parentKey,
      data: {}
    } : { type: OpCode.CREATE_OBJECT, id: this._id, opId, data: {} };
    ops.push(op);
    for (const [key, value] of this._map)
      isLiveNode(value) ? ops.push(...value._serialize(this._id, key, doc)) : op.data[key] = value;
    return ops;
  }
  static _deserialize([id, item], parentToChildren, doc) {
    const liveObj = new LiveObject(item.data);
    return liveObj._attach(id, doc), this._deserializeChildren(liveObj, parentToChildren, doc);
  }
  static _deserializeChildren(liveObj, parentToChildren, doc) {
    const children = parentToChildren.get(nn(liveObj._id));
    if (null == children)
      return liveObj;
    for (const [id, crdt] of children) {
      const child = deserializeToLson([id, crdt], parentToChildren, doc);
      isLiveStructure(child) && child._setParentLink(liveObj, crdt.parentKey), liveObj._map.set(crdt.parentKey, child);
    }
    return liveObj;
  }
  _attach(id, doc) {
    super._attach(id, doc);
    for (const [_key, value] of this._map)
      isLiveNode(value) && value._attach(doc.generateId(), doc);
  }
  _attachChild(op, source) {
    if (null == this._doc)
      throw new Error("Can't attach child if doc is not present");
    const { id, opId, parentKey: key } = op, child = creationOpToLson(op);
    if (void 0 !== this._doc.getItem(id))
      return this._propToLastUpdate.get(key) === opId && this._propToLastUpdate.delete(key), { modified: false };
    if (source === OpSource.UNDOREDO_RECONNECT)
      this._propToLastUpdate.set(key, nn(opId));
    else if (void 0 !== this._propToLastUpdate.get(key))
      return this._propToLastUpdate.get(key) === opId ? (this._propToLastUpdate.delete(key), { modified: false }) : { modified: false };
    const thisId = nn(this._id), previousValue = this._map.get(key);
    let reverse;
    return isLiveNode(previousValue) ? (reverse = previousValue._serialize(thisId, key), previousValue._detach()) : reverse = void 0 === previousValue ? [{ type: OpCode.DELETE_OBJECT_KEY, id: thisId, key }] : [
      {
        type: OpCode.UPDATE_OBJECT,
        id: thisId,
        data: { [key]: previousValue }
      }
    ], this._map.set(key, child), isLiveStructure(child) && (child._setParentLink(this, key), child._attach(id, this._doc)), {
      reverse,
      modified: {
        node: this,
        type: "LiveObject",
        updates: { [key]: { type: "update" } }
      }
    };
  }
  _detachChild(child) {
    if (child) {
      const id = nn(this._id), parentKey = nn(child._parentKey), reverse = child._serialize(id, parentKey, this._doc);
      for (const [key, value] of this._map)
        value === child && this._map.delete(key);
      child._detach();
      return {
        modified: {
          node: this,
          type: "LiveObject",
          updates: { [parentKey]: { type: "delete" } }
        },
        reverse
      };
    }
    return { modified: false };
  }
  _detach() {
    super._detach();
    for (const value of this._map.values())
      isLiveNode(value) && value._detach();
  }
  _apply(op, isLocal) {
    return op.type === OpCode.UPDATE_OBJECT ? this._applyUpdate(op, isLocal) : op.type === OpCode.DELETE_OBJECT_KEY ? this._applyDeleteObjectKey(op) : super._apply(op, isLocal);
  }
  _toSerializedCrdt() {
    const data = {};
    for (const [key, value] of this._map)
      isLiveNode(value) || (data[key] = value);
    return "HasParent" === this.parent.type && this.parent.node._id ? {
      type: CrdtType.OBJECT,
      parentId: this.parent.node._id,
      parentKey: this.parent.key,
      data
    } : { type: CrdtType.OBJECT, data };
  }
  _applyUpdate(op, isLocal) {
    let isModified = false;
    const id = nn(this._id), reverse = [], reverseUpdate = { type: OpCode.UPDATE_OBJECT, id, data: {} };
    reverse.push(reverseUpdate);
    for (const key in op.data) {
      const oldValue = this._map.get(key);
      isLiveNode(oldValue) ? (reverse.push(...oldValue._serialize(id, key)), oldValue._detach()) : void 0 !== oldValue ? reverseUpdate.data[key] = oldValue : void 0 === oldValue && reverse.push({ type: OpCode.DELETE_OBJECT_KEY, id, key });
    }
    const updateDelta = {};
    for (const key in op.data) {
      const value = op.data[key];
      if (void 0 === value)
        continue;
      if (isLocal)
        this._propToLastUpdate.set(key, nn(op.opId));
      else {
        if (null != this._propToLastUpdate.get(key)) {
          if (this._propToLastUpdate.get(key) === op.opId) {
            this._propToLastUpdate.delete(key);
            continue;
          }
          continue;
        }
        isModified = true;
      }
      const oldValue = this._map.get(key);
      isLiveNode(oldValue) && oldValue._detach(), isModified = true, updateDelta[key] = { type: "update" }, this._map.set(key, value);
    }
    return 0 !== Object.keys(reverseUpdate.data).length && reverse.unshift(reverseUpdate), isModified ? {
      modified: { node: this, type: "LiveObject", updates: updateDelta },
      reverse
    } : { modified: false };
  }
  _applyDeleteObjectKey(op) {
    const key = op.key;
    if (false === this._map.has(key))
      return { modified: false };
    if (void 0 !== this._propToLastUpdate.get(key))
      return { modified: false };
    const oldValue = this._map.get(key), id = nn(this._id);
    let reverse = [];
    return isLiveNode(oldValue) ? (reverse = oldValue._serialize(id, op.key), oldValue._detach()) : void 0 !== oldValue && (reverse = [
      { type: OpCode.UPDATE_OBJECT, id, data: { [key]: oldValue } }
    ]), this._map.delete(key), {
      modified: {
        node: this,
        type: "LiveObject",
        updates: { [op.key]: { type: "delete" } }
      },
      reverse
    };
  }
  toObject() {
    return function(iterable) {
      const obj = {};
      for (const [key, val] of iterable)
        obj[key] = val;
      return obj;
    }(this._map);
  }
  set(key, value) {
    this.update({ [key]: value });
  }
  get(key) {
    return this._map.get(key);
  }
  delete(key) {
    const keyAsString = key, oldValue = this._map.get(keyAsString);
    if (void 0 === oldValue)
      return;
    if (null == this._doc || null == this._id)
      return isLiveNode(oldValue) && oldValue._detach(), void this._map.delete(keyAsString);
    let reverse;
    isLiveNode(oldValue) ? (oldValue._detach(), reverse = oldValue._serialize(this._id, keyAsString)) : reverse = [
      {
        type: OpCode.UPDATE_OBJECT,
        data: { [keyAsString]: oldValue },
        id: this._id
      }
    ], this._map.delete(keyAsString);
    const storageUpdates = /* @__PURE__ */ new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: { [key]: { type: "delete" } }
    }), this._doc.dispatch(
      [
        {
          type: OpCode.DELETE_OBJECT_KEY,
          key: keyAsString,
          id: this._id,
          opId: this._doc.generateOpId()
        }
      ],
      reverse,
      storageUpdates
    );
  }
  update(overrides) {
    if (null == this._doc || null == this._id) {
      for (const key in overrides) {
        const newValue = overrides[key];
        if (void 0 === newValue)
          continue;
        const oldValue = this._map.get(key);
        isLiveNode(oldValue) && oldValue._detach(), isLiveNode(newValue) && newValue._setParentLink(this, key), this._map.set(key, newValue);
      }
      return;
    }
    const ops = [], reverseOps = [], opId = this._doc.generateOpId(), updatedProps = {}, reverseUpdateOp = { id: this._id, type: OpCode.UPDATE_OBJECT, data: {} }, updateDelta = {};
    for (const key in overrides) {
      const newValue = overrides[key];
      if (void 0 === newValue)
        continue;
      const oldValue = this._map.get(key);
      if (isLiveNode(oldValue) ? (reverseOps.push(...oldValue._serialize(this._id, key)), oldValue._detach()) : void 0 === oldValue ? reverseOps.push({
        type: OpCode.DELETE_OBJECT_KEY,
        id: this._id,
        key
      }) : reverseUpdateOp.data[key] = oldValue, isLiveNode(newValue)) {
        newValue._setParentLink(this, key), newValue._attach(this._doc.generateId(), this._doc);
        const newAttachChildOps = newValue._serialize(this._id, key, this._doc), createCrdtOp = newAttachChildOps.find(
          (op) => op.parentId === this._id
        );
        createCrdtOp && this._propToLastUpdate.set(key, nn(createCrdtOp.opId)), ops.push(...newAttachChildOps);
      } else
        updatedProps[key] = newValue, this._propToLastUpdate.set(key, opId);
      this._map.set(key, newValue), updateDelta[key] = { type: "update" };
    }
    0 !== Object.keys(reverseUpdateOp.data).length && reverseOps.unshift(reverseUpdateOp), 0 !== Object.keys(updatedProps).length && ops.unshift({
      opId,
      id: this._id,
      type: OpCode.UPDATE_OBJECT,
      data: updatedProps
    });
    const storageUpdates = /* @__PURE__ */ new Map();
    storageUpdates.set(this._id, {
      node: this,
      type: "LiveObject",
      updates: updateDelta
    }), this._doc.dispatch(ops, reverseOps, storageUpdates);
  }
};
function remove(array, item) {
  for (let i = 0; i < array.length; i++)
    if (array[i] === item) {
      array.splice(i, 1);
      break;
    }
}
function compact(items) {
  return items.filter((item) => null != item);
}
function creationOpToLiveNode(op) {
  return lsonToLiveNode(creationOpToLson(op));
}
function creationOpToLson(op) {
  switch (op.type) {
    case OpCode.CREATE_REGISTER:
      return op.data;
    case OpCode.CREATE_OBJECT:
      return new LiveObject(op.data);
    case OpCode.CREATE_MAP:
      return new LiveMap();
    case OpCode.CREATE_LIST:
      return new LiveList();
    default:
      return assertNever(0, "Unknown creation Op");
  }
}
function isSameNodeOrChildOf(node, parent) {
  return node === parent || "HasParent" === node.parent.type && isSameNodeOrChildOf(node.parent.node, parent);
}
function deserialize([id, crdt], parentToChildren, doc) {
  switch (crdt.type) {
    case CrdtType.OBJECT:
      return LiveObject._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.LIST:
      return LiveList._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.MAP:
      return LiveMap._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.REGISTER:
      return LiveRegister._deserialize([id, crdt], parentToChildren, doc);
    default:
      throw new Error("Unexpected CRDT type");
  }
}
function deserializeToLson([id, crdt], parentToChildren, doc) {
  switch (crdt.type) {
    case CrdtType.OBJECT:
      return LiveObject._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.LIST:
      return LiveList._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.MAP:
      return LiveMap._deserialize([id, crdt], parentToChildren, doc);
    case CrdtType.REGISTER:
      return crdt.data;
    default:
      throw new Error("Unexpected CRDT type");
  }
}
function isLiveStructure(value) {
  return isLiveList(value) || function(value2) {
    return value2 instanceof LiveMap;
  }(value) || isLiveObject(value);
}
function isLiveNode(value) {
  return isLiveStructure(value) || function(value2) {
    return value2 instanceof LiveRegister;
  }(value);
}
function isLiveList(value) {
  return value instanceof LiveList;
}
function isLiveObject(value) {
  return value instanceof LiveObject;
}
function liveNodeToLson(obj) {
  return obj instanceof LiveRegister ? obj.data : obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject ? obj : assertNever(0, "Unknown AbstractCrdt");
}
function lsonToLiveNode(value) {
  return value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList ? value : new LiveRegister(value);
}
function getTreesDiffOperations(currentItems, newItems) {
  const ops = [];
  return currentItems.forEach((_, id) => {
    newItems.get(id) || ops.push({ type: OpCode.DELETE_CRDT, id });
  }), newItems.forEach((crdt, id) => {
    const currentCrdt = currentItems.get(id);
    if (currentCrdt)
      crdt.type === CrdtType.OBJECT && (currentCrdt.type === CrdtType.OBJECT && JSON.stringify(crdt.data) === JSON.stringify(currentCrdt.data) || ops.push({ type: OpCode.UPDATE_OBJECT, id, data: crdt.data })), crdt.parentKey !== currentCrdt.parentKey && ops.push({
        type: OpCode.SET_PARENT_KEY,
        id,
        parentKey: nn(crdt.parentKey, "Parent key must not be missing")
      });
    else
      switch (crdt.type) {
        case CrdtType.REGISTER:
          ops.push({
            type: OpCode.CREATE_REGISTER,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey,
            data: crdt.data
          });
          break;
        case CrdtType.LIST:
          ops.push({
            type: OpCode.CREATE_LIST,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey
          });
          break;
        case CrdtType.OBJECT:
          ops.push(
            crdt.parentId ? {
              type: OpCode.CREATE_OBJECT,
              id,
              parentId: crdt.parentId,
              parentKey: crdt.parentKey,
              data: crdt.data
            } : { type: OpCode.CREATE_OBJECT, id, data: crdt.data }
          );
          break;
        case CrdtType.MAP:
          ops.push({
            type: OpCode.CREATE_MAP,
            id,
            parentId: crdt.parentId,
            parentKey: crdt.parentKey
          });
      }
  }), ops;
}
function mergeStorageUpdates(first, second) {
  return first ? "LiveObject" === first.type && "LiveObject" === second.type ? function(first2, second2) {
    const updates = first2.updates;
    for (const [key, value] of entries(second2.updates))
      updates[key] = value;
    return Object.assign(Object.assign({}, second2), { updates });
  }(first, second) : "LiveMap" === first.type && "LiveMap" === second.type ? function(first2, second2) {
    const updates = first2.updates;
    for (const [key, value] of entries(second2.updates))
      updates[key] = value;
    return Object.assign(Object.assign({}, second2), { updates });
  }(first, second) : "LiveList" === first.type && "LiveList" === second.type ? function(first2, second2) {
    const updates = first2.updates;
    return Object.assign(Object.assign({}, second2), {
      updates: updates.concat(second2.updates)
    });
  }(first, second) : second : second;
}
function isPlainObject(blob) {
  return null !== blob && "object" == typeof blob && "[object Object]" === Object.prototype.toString.call(blob);
}
function entries(obj) {
  return Object.entries(obj);
}
function tryParseJson(rawMessage) {
  try {
    return JSON.parse(rawMessage);
  } catch (e) {
    return;
  }
}
function b64decode(b64value) {
  try {
    const formattedValue = b64value.replace(/-/g, "+").replace(/_/g, "/");
    return decodeURIComponent(
      atob(formattedValue).split("").map(function(c) {
        return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
      }).join("")
    );
  } catch (err) {
    return atob(b64value);
  }
}
function isTokenExpired(token) {
  const now = Date.now() / 1e3;
  return now > token.exp - 300 || now < token.iat + 300;
}
function isStringList(value) {
  return Array.isArray(value) && value.every((i) => "string" == typeof i);
}
function isRoomAuthToken(data) {
  return "string" == typeof data.appId && "string" == typeof data.roomId && "number" == typeof data.actor && (void 0 === data.id || "string" == typeof data.id) && isStringList(data.scopes) && (void 0 === data.maxConnectionsPerRoom || "number" == typeof data.maxConnectionsPerRoom);
}
function parseJwtToken(token) {
  const tokenParts = token.split(".");
  if (3 !== tokenParts.length)
    throw new Error("Authentication error: invalid JWT token");
  const data = tryParseJson(b64decode(tokenParts[1]));
  if (data && function(data2) {
    if (!isPlainObject(data2))
      return false;
    const { iat, exp } = data2;
    return "number" == typeof iat && "number" == typeof exp;
  }(data))
    return data;
  throw new Error("Authentication error: missing JWT metadata");
}
function parseRoomAuthToken(tokenString) {
  const data = parseJwtToken(tokenString);
  if (data && isRoomAuthToken(data)) {
    return __rest(data, ["maxConnections"]);
  }
  throw new Error(
    "Authentication error: we expected a room token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback"
  );
}
function isJsonScalar(data) {
  return null === data || "string" == typeof data || "number" == typeof data || "boolean" == typeof data;
}
function isJsonArray(data) {
  return Array.isArray(data);
}
function isJsonObject(data) {
  return !isJsonScalar(data) && !isJsonArray(data);
}

// ../../node_modules/@liveblocks/client/index.mjs
var BACKOFF_RETRY_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];
var BACKOFF_RETRY_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];
function makeOthers(userMap) {
  const users = Object.values(userMap).map(
    (user) => __rest(user, ["_hasReceivedInitialPresence"])
  );
  return {
    get count() {
      return users.length;
    },
    [Symbol.iterator]: () => users[Symbol.iterator](),
    map: (callback) => users.map(callback),
    toArray: () => users
  };
}
function makeStateMachine(state, context, mockedEffects) {
  const effects = mockedEffects || {
    authenticate(auth, createWebSocket) {
      const rawToken = state.token, parsedToken = null !== rawToken && parseRoomAuthToken(rawToken);
      if (!parsedToken || isTokenExpired(parsedToken))
        return auth(context.roomId).then(({ token }) => {
          if ("authenticating" !== state.connection.state)
            return;
          authenticationSuccess(
            parseRoomAuthToken(token),
            createWebSocket(token)
          ), state.token = token;
        }).catch(
          (er) => function(error) {
            console.error("Call to authentication endpoint failed", error);
            state.token = null, updateConnection({ state: "unavailable" }), state.numberOfRetry++, state.timeoutHandles.reconnect = effects.scheduleReconnect(
              getRetryDelay()
            );
          }(er instanceof Error ? er : new Error(String(er)))
        );
      authenticationSuccess(parsedToken, createWebSocket(rawToken));
    },
    send(messageOrMessages) {
      if (null == state.socket)
        throw new Error("Can't send message if socket is null");
      state.socket.send(JSON.stringify(messageOrMessages));
    },
    delayFlush: (delay) => setTimeout(tryFlushing, delay),
    startHeartbeatInterval: () => setInterval(heartbeat, 3e4),
    schedulePongTimeout: () => setTimeout(pongTimeout, 2e3),
    scheduleReconnect: (delay) => setTimeout(connect, delay)
  };
  function genericSubscribe(callback) {
    return state.listeners.storage.push(callback), () => remove(state.listeners.storage, callback);
  }
  function createOrUpdateRootFromMessage(message) {
    if (0 === message.items.length)
      throw new Error("Internal error: cannot load storage without items");
    state.root ? function(items) {
      if (!state.root)
        return;
      const currentItems = /* @__PURE__ */ new Map();
      state.items.forEach((liveCrdt, id) => {
        currentItems.set(id, liveCrdt._toSerializedCrdt());
      });
      const ops = getTreesDiffOperations(currentItems, new Map(items));
      notify(apply(ops, false).updates);
    }(message.items) : state.root = function(items) {
      const [root, parentToChildren] = function(items2) {
        const parentToChildren2 = /* @__PURE__ */ new Map();
        let root2 = null;
        for (const [id, crdt] of items2)
          if (isRootCrdt(crdt))
            root2 = [id, crdt];
          else {
            const tuple = [id, crdt], children = parentToChildren2.get(crdt.parentId);
            null != children ? children.push(tuple) : parentToChildren2.set(crdt.parentId, [tuple]);
          }
        if (null == root2)
          throw new Error("Root can't be null");
        return [root2, parentToChildren2];
      }(items);
      return LiveObject._deserialize(root, parentToChildren, {
        getItem,
        addItem,
        deleteItem,
        generateId,
        generateOpId,
        dispatch: storageDispatch,
        roomId: context.roomId
      });
    }(message.items);
    for (const key in state.defaultStorageRoot)
      null == state.root.get(key) && state.root.set(key, state.defaultStorageRoot[key]);
  }
  function addItem(id, liveItem) {
    state.items.set(id, liveItem);
  }
  function deleteItem(id) {
    state.items.delete(id);
  }
  function getItem(id) {
    return state.items.get(id);
  }
  function addToUndoStack(historyItem) {
    state.undoStack.length >= 50 && state.undoStack.shift(), state.isHistoryPaused ? state.pausedHistory.unshift(...historyItem) : state.undoStack.push(historyItem);
  }
  function storageDispatch(ops, reverse, storageUpdates) {
    state.isBatching ? (state.batch.ops.push(...ops), storageUpdates.forEach((value, key) => {
      state.batch.updates.storageUpdates.set(
        key,
        mergeStorageUpdates(
          state.batch.updates.storageUpdates.get(key),
          value
        )
      );
    }), state.batch.reverseOps.push(...reverse)) : (addToUndoStack(reverse), state.redoStack = [], dispatch(ops), notify({ storageUpdates }));
  }
  function notify({
    storageUpdates = /* @__PURE__ */ new Map(),
    presence = false,
    others: otherEvents = []
  }) {
    if (otherEvents.length > 0) {
      state.others = makeOthers(state.users);
      for (const event of otherEvents)
        for (const listener of state.listeners.others)
          listener(state.others, event);
    }
    if (presence)
      for (const listener of state.listeners["my-presence"])
        listener(state.me);
    if (storageUpdates.size > 0)
      for (const subscriber of state.listeners.storage)
        subscriber(Array.from(storageUpdates.values()));
  }
  function getConnectionId() {
    if ("open" === state.connection.state || "connecting" === state.connection.state)
      return state.connection.id;
    if (null !== state.lastConnectionId)
      return state.lastConnectionId;
    throw new Error(
      "Internal. Tried to get connection id but connection was never open"
    );
  }
  function generateId() {
    return `${getConnectionId()}:${state.clock++}`;
  }
  function generateOpId() {
    return `${getConnectionId()}:${state.opClock++}`;
  }
  function apply(item, isLocal) {
    const result = {
      reverse: [],
      updates: { storageUpdates: /* @__PURE__ */ new Map(), presence: false }
    }, createdNodeIds = /* @__PURE__ */ new Set();
    for (const op of item)
      if ("presence" === op.type) {
        const reverse = { type: "presence", data: {} };
        for (const key in op.data)
          reverse.data[key] = state.me[key];
        if (state.me = Object.assign(Object.assign({}, state.me), op.data), null == state.buffer.presence)
          state.buffer.presence = op.data;
        else
          for (const key in op.data)
            state.buffer.presence[key] = op.data[key];
        result.reverse.unshift(reverse), result.updates.presence = true;
      } else {
        let source;
        if (op.opId || (op.opId = generateOpId()), isLocal)
          source = OpSource.UNDOREDO_RECONNECT;
        else {
          source = state.offlineOperations.delete(nn(op.opId)) ? OpSource.ACK : OpSource.REMOTE;
        }
        const applyOpResult = applyOp(op, source);
        if (applyOpResult.modified) {
          const parentId = "HasParent" === applyOpResult.modified.node.parent.type ? nn(
            applyOpResult.modified.node.parent.node._id,
            "Expected parent node to have an ID"
          ) : void 0;
          parentId && createdNodeIds.has(parentId) || (result.updates.storageUpdates.set(
            nn(applyOpResult.modified.node._id),
            mergeStorageUpdates(
              result.updates.storageUpdates.get(
                nn(applyOpResult.modified.node._id)
              ),
              applyOpResult.modified
            )
          ), result.reverse.unshift(...applyOpResult.reverse)), op.type !== OpCode.CREATE_LIST && op.type !== OpCode.CREATE_MAP && op.type !== OpCode.CREATE_OBJECT || createdNodeIds.add(nn(applyOpResult.modified.node._id));
        }
      }
    return result;
  }
  function applyOp(op, source) {
    switch (op.type) {
      case OpCode.DELETE_OBJECT_KEY:
      case OpCode.UPDATE_OBJECT:
      case OpCode.DELETE_CRDT: {
        const item = state.items.get(op.id);
        return null == item ? { modified: false } : item._apply(op, source === OpSource.UNDOREDO_RECONNECT);
      }
      case OpCode.SET_PARENT_KEY: {
        const item = state.items.get(op.id);
        return null == item ? { modified: false } : "HasParent" === item.parent.type && isLiveList(item.parent.node) ? item.parent.node._setChildKey(op.parentKey, item, source) : { modified: false };
      }
      case OpCode.CREATE_OBJECT:
      case OpCode.CREATE_LIST:
      case OpCode.CREATE_MAP:
      case OpCode.CREATE_REGISTER: {
        if (void 0 === op.parentId)
          return { modified: false };
        const parent = state.items.get(op.parentId);
        return null == parent ? { modified: false } : parent._attachChild(op, source);
      }
    }
  }
  function connect() {
    var _a, _b, _c, _d;
    if ("closed" !== state.connection.state && "unavailable" !== state.connection.state)
      return null;
    const auth = function(authentication, fetchPolyfill) {
      if ("public" === authentication.type) {
        if ("undefined" == typeof window && null == fetchPolyfill)
          throw new Error(
            "To use Liveblocks client in a non-dom environment with a publicApiKey, you need to provide a fetch polyfill."
          );
        return (room) => fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {
          room,
          publicApiKey: authentication.publicApiKey
        });
      }
      if ("private" === authentication.type) {
        if ("undefined" == typeof window && null == fetchPolyfill)
          throw new Error(
            "To use Liveblocks client in a non-dom environment with a url as auth endpoint, you need to provide a fetch polyfill."
          );
        return (room) => fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {
          room
        });
      }
      if ("custom" === authentication.type) {
        return (room) => authentication.callback(room).then((response) => {
          if (!response || !response.token)
            throw new Error(
              'Authentication error. We expect the authentication callback to return a token, but it does not. Hint: the return value should look like: { token: "..." }'
            );
          return response;
        });
      }
      throw new Error("Internal error. Unexpected authentication type");
    }(
      context.authentication,
      null !== (_b = null === (_a = context.polyfills) || void 0 === _a ? void 0 : _a.fetch) && void 0 !== _b ? _b : context.fetchPolyfill
    ), createWebSocket = function(liveblocksServer, WebSocketPolyfill) {
      if ("undefined" == typeof window && null == WebSocketPolyfill)
        throw new Error(
          "To use Liveblocks client in a non-dom environment, you need to provide a WebSocket polyfill."
        );
      const ws = WebSocketPolyfill || WebSocket;
      return (token) => new ws(`${liveblocksServer}/?token=${token}&version=0.17.7`);
    }(
      context.liveblocksServer,
      null !== (_d = null === (_c = context.polyfills) || void 0 === _c ? void 0 : _c.WebSocket) && void 0 !== _d ? _d : context.WebSocketPolyfill
    );
    updateConnection({ state: "authenticating" }), effects.authenticate(auth, createWebSocket);
  }
  function authenticationSuccess(token, socket) {
    socket.addEventListener("message", onMessage), socket.addEventListener("open", onOpen), socket.addEventListener("close", onClose), socket.addEventListener("error", onError), updateConnection({
      state: "connecting",
      id: token.actor,
      userInfo: token.info,
      userId: token.id
    }), state.idFactory = function(connectionId) {
      let count = 0;
      return () => `${connectionId}:${count++}`;
    }(token.actor), state.socket = socket;
  }
  function onUpdatePresenceMessage(message) {
    const user = state.users[message.actor];
    if (void 0 !== message.targetActor || null == user || user._hasReceivedInitialPresence)
      return state.users[message.actor] = null == user ? {
        connectionId: message.actor,
        presence: message.data,
        id: void 0,
        info: void 0,
        _hasReceivedInitialPresence: true
      } : {
        id: user.id,
        info: user.info,
        connectionId: message.actor,
        presence: Object.assign(
          Object.assign({}, user.presence),
          message.data
        ),
        _hasReceivedInitialPresence: true
      }, {
        type: "update",
        updates: message.data,
        user: state.users[message.actor]
      };
  }
  function onUserLeftMessage(message) {
    const userLeftMessage = message, user = state.users[userLeftMessage.actor];
    return user ? (delete state.users[userLeftMessage.actor], { type: "leave", user }) : null;
  }
  function onRoomStateMessage(message) {
    const newUsers = {};
    for (const key in message.users) {
      const connectionId = Number.parseInt(key), user = message.users[key];
      newUsers[connectionId] = {
        connectionId,
        info: user.info,
        id: user.id
      };
    }
    return state.users = newUsers, { type: "reset" };
  }
  function onEvent(message) {
    for (const listener of state.listeners.event)
      listener({ connectionId: message.actor, event: message.event });
  }
  function onUserJoinedMessage(message) {
    return state.users[message.actor] = {
      connectionId: message.actor,
      info: message.info,
      id: message.id,
      _hasReceivedInitialPresence: true
    }, state.me && (state.buffer.messages.push({
      type: ClientMsgCode.UPDATE_PRESENCE,
      data: state.me,
      targetActor: message.actor
    }), tryFlushing()), { type: "enter", user: state.users[message.actor] };
  }
  function parseServerMessage(data) {
    return isJsonObject(data) ? data : null;
  }
  function onMessage(event) {
    if ("pong" === event.data)
      return void clearTimeout(state.timeoutHandles.pongTimeout);
    const messages = function(text) {
      const data = tryParseJson(text);
      return void 0 === data ? null : isJsonArray(data) ? compact(data.map((item) => parseServerMessage(item))) : compact([parseServerMessage(data)]);
    }(event.data);
    if (null === messages || 0 === messages.length)
      return;
    const updates = { storageUpdates: /* @__PURE__ */ new Map(), others: [] };
    for (const message of messages)
      switch (message.type) {
        case ServerMsgCode.USER_JOINED:
          updates.others.push(onUserJoinedMessage(message));
          break;
        case ServerMsgCode.UPDATE_PRESENCE: {
          const othersPresenceUpdate = onUpdatePresenceMessage(message);
          othersPresenceUpdate && updates.others.push(othersPresenceUpdate);
          break;
        }
        case ServerMsgCode.BROADCASTED_EVENT:
          onEvent(message);
          break;
        case ServerMsgCode.USER_LEFT: {
          const event2 = onUserLeftMessage(message);
          event2 && updates.others.push(event2);
          break;
        }
        case ServerMsgCode.ROOM_STATE:
          updates.others.push(onRoomStateMessage(message));
          break;
        case ServerMsgCode.INITIAL_STORAGE_STATE: {
          const offlineOps = new Map(state.offlineOperations);
          createOrUpdateRootFromMessage(message), applyAndSendOfflineOps(offlineOps), null == _getInitialStateResolver || _getInitialStateResolver();
          break;
        }
        case ServerMsgCode.UPDATE_STORAGE:
          apply(message.ops, false).updates.storageUpdates.forEach(
            (value, key) => {
              updates.storageUpdates.set(
                key,
                mergeStorageUpdates(updates.storageUpdates.get(key), value)
              );
            }
          );
          break;
      }
    notify(updates);
  }
  function onClose(event) {
    if (state.socket = null, clearTimeout(state.timeoutHandles.pongTimeout), clearInterval(state.intervalHandles.heartbeat), state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), clearTimeout(state.timeoutHandles.reconnect), state.users = {}, notify({ others: [{ type: "reset" }] }), event.code >= 4e3 && event.code <= 4100) {
      updateConnection({ state: "failed" });
      const error = new LiveblocksError(event.reason, event.code);
      for (const listener of state.listeners.error)
        listener(error);
      const delay = getRetryDelay(true);
      state.numberOfRetry++, console.error(
        `Connection to Liveblocks websocket server closed. Reason: ${error.message} (code: ${error.code}). Retrying in ${delay}ms.`
      ), updateConnection({ state: "unavailable" }), state.timeoutHandles.reconnect = effects.scheduleReconnect(delay);
    } else if (event.code === WebsocketCloseCodes.CLOSE_WITHOUT_RETRY)
      updateConnection({ state: "closed" });
    else {
      const delay = getRetryDelay();
      state.numberOfRetry++, console.warn(
        `Connection to Liveblocks websocket server closed (code: ${event.code}). Retrying in ${delay}ms.`
      ), updateConnection({ state: "unavailable" }), state.timeoutHandles.reconnect = effects.scheduleReconnect(delay);
    }
  }
  function updateConnection(connection) {
    state.connection = connection;
    for (const listener of state.listeners.connection)
      listener(connection.state);
  }
  function getRetryDelay(slow = false) {
    return slow ? BACKOFF_RETRY_DELAYS_SLOW[state.numberOfRetry < BACKOFF_RETRY_DELAYS_SLOW.length ? state.numberOfRetry : BACKOFF_RETRY_DELAYS_SLOW.length - 1] : BACKOFF_RETRY_DELAYS[state.numberOfRetry < BACKOFF_RETRY_DELAYS.length ? state.numberOfRetry : BACKOFF_RETRY_DELAYS.length - 1];
  }
  function onError() {
  }
  function onOpen() {
    clearInterval(state.intervalHandles.heartbeat), state.intervalHandles.heartbeat = effects.startHeartbeatInterval(), "connecting" === state.connection.state && (updateConnection(
      Object.assign(Object.assign({}, state.connection), { state: "open" })
    ), state.numberOfRetry = 0, void 0 !== state.lastConnectionId && (state.buffer.presence = state.me, tryFlushing()), state.lastConnectionId = state.connection.id, state.root && state.buffer.messages.push({ type: ClientMsgCode.FETCH_STORAGE }), tryFlushing());
  }
  function heartbeat() {
    null != state.socket && (clearTimeout(state.timeoutHandles.pongTimeout), state.timeoutHandles.pongTimeout = effects.schedulePongTimeout(), state.socket.readyState === state.socket.OPEN && state.socket.send("ping"));
  }
  function pongTimeout() {
    reconnect();
  }
  function reconnect() {
    state.socket && (state.socket.removeEventListener("open", onOpen), state.socket.removeEventListener("message", onMessage), state.socket.removeEventListener("close", onClose), state.socket.removeEventListener("error", onError), state.socket.close(), state.socket = null), updateConnection({ state: "unavailable" }), clearTimeout(state.timeoutHandles.pongTimeout), state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), clearTimeout(state.timeoutHandles.reconnect), clearInterval(state.intervalHandles.heartbeat), connect();
  }
  function applyAndSendOfflineOps(offlineOps) {
    if (0 === offlineOps.size)
      return;
    const messages = [], ops = Array.from(offlineOps.values()), result = apply(ops, true);
    messages.push({ type: ClientMsgCode.UPDATE_STORAGE, ops }), notify(result.updates), effects.send(messages);
  }
  function tryFlushing() {
    const storageOps = state.buffer.storageOperations;
    if (storageOps.length > 0 && storageOps.forEach((op) => {
      state.offlineOperations.set(nn(op.opId), op);
    }), null == state.socket || state.socket.readyState !== state.socket.OPEN)
      return void (state.buffer.storageOperations = []);
    const now = Date.now();
    if (now - state.lastFlushTime > context.throttleDelay) {
      const messages = function(state2) {
        const messages2 = [];
        state2.buffer.presence && messages2.push({
          type: ClientMsgCode.UPDATE_PRESENCE,
          data: state2.buffer.presence
        });
        for (const event of state2.buffer.messages)
          messages2.push(event);
        state2.buffer.storageOperations.length > 0 && messages2.push({
          type: ClientMsgCode.UPDATE_STORAGE,
          ops: state2.buffer.storageOperations
        });
        return messages2;
      }(state);
      if (0 === messages.length)
        return;
      effects.send(messages), state.buffer = {
        messages: [],
        storageOperations: [],
        presence: null
      }, state.lastFlushTime = now;
    } else
      null != state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), state.timeoutHandles.flush = effects.delayFlush(
        context.throttleDelay - (now - state.lastFlushTime)
      );
  }
  function getPresence() {
    return state.me;
  }
  function dispatch(ops) {
    state.buffer.storageOperations.push(...ops), tryFlushing();
  }
  let _getInitialStatePromise = null, _getInitialStateResolver = null;
  return {
    onClose,
    onMessage,
    authenticationSuccess,
    heartbeat,
    onNavigatorOnline: function() {
      "unavailable" === state.connection.state && reconnect();
    },
    simulateSocketClose: function() {
      state.socket && (state.socket = null);
    },
    simulateSendCloseEvent: function(event) {
      onClose(event);
    },
    onVisibilityChange: function(visibilityState) {
      "visible" === visibilityState && "open" === state.connection.state && heartbeat();
    },
    getUndoStack: () => state.undoStack,
    getItemsCount: () => state.items.size,
    connect,
    disconnect: function() {
      state.socket && (state.socket.removeEventListener("open", onOpen), state.socket.removeEventListener("message", onMessage), state.socket.removeEventListener("close", onClose), state.socket.removeEventListener("error", onError), state.socket.close(), state.socket = null), updateConnection({ state: "closed" }), state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush), clearTimeout(state.timeoutHandles.reconnect), clearTimeout(state.timeoutHandles.pongTimeout), clearInterval(state.intervalHandles.heartbeat), state.users = {}, notify({ others: [{ type: "reset" }] }), function() {
        for (const key in state.listeners)
          state.listeners[key] = [];
      }();
    },
    subscribe: function(first, second, options) {
      if (void 0 === second || "function" == typeof first) {
        if ("function" == typeof first) {
          return genericSubscribe(first);
        }
        throw new Error("Please specify a listener callback");
      }
      if (isLiveNode(first)) {
        const node = first;
        if (null == options ? void 0 : options.isDeep) {
          return function(node2, callback) {
            return genericSubscribe((updates) => {
              const relatedUpdates = updates.filter(
                (update) => isSameNodeOrChildOf(update.node, node2)
              );
              relatedUpdates.length > 0 && callback(relatedUpdates);
            });
          }(node, second);
        }
        return function(node2, callback) {
          return genericSubscribe((updates) => {
            for (const update of updates)
              update.node._id === node2._id && callback(update.node);
          });
        }(node, second);
      }
      if (!isRoomEventName(first))
        throw new Error(`"${first}" is not a valid event name`);
      const eventName = first, eventListener = second;
      return state.listeners[eventName].push(eventListener), () => {
        const callbacks = state.listeners[eventName];
        remove(callbacks, eventListener);
      };
    },
    updatePresence: function(overrides, options) {
      const oldValues = {};
      null == state.buffer.presence && (state.buffer.presence = {});
      for (const key in overrides) {
        const overrideValue = overrides[key];
        void 0 !== overrideValue && (state.buffer.presence[key] = overrideValue, oldValues[key] = state.me[key]);
      }
      state.me = Object.assign(Object.assign({}, state.me), overrides), state.isBatching ? ((null == options ? void 0 : options.addToHistory) && state.batch.reverseOps.push({
        type: "presence",
        data: oldValues
      }), state.batch.updates.presence = true) : (tryFlushing(), (null == options ? void 0 : options.addToHistory) && addToUndoStack([{ type: "presence", data: oldValues }]), notify({ presence: true }));
    },
    broadcastEvent: function(event, options = { shouldQueueEventIfNotReady: false }) {
      null == state.socket && 0 == options.shouldQueueEventIfNotReady || (state.buffer.messages.push({
        type: ClientMsgCode.BROADCAST_EVENT,
        event
      }), tryFlushing());
    },
    batch: function(callback) {
      if (state.isBatching)
        throw new Error("batch should not be called during a batch");
      state.isBatching = true;
      try {
        callback();
      } finally {
        state.isBatching = false, state.batch.reverseOps.length > 0 && addToUndoStack(state.batch.reverseOps), state.batch.ops.length > 0 && (state.redoStack = []), state.batch.ops.length > 0 && dispatch(state.batch.ops), notify(state.batch.updates), state.batch = {
          ops: [],
          reverseOps: [],
          updates: { others: [], storageUpdates: /* @__PURE__ */ new Map(), presence: false }
        }, tryFlushing();
      }
    },
    undo: function() {
      if (state.isBatching)
        throw new Error("undo is not allowed during a batch");
      const historyItem = state.undoStack.pop();
      if (null == historyItem)
        return;
      state.isHistoryPaused = false;
      const result = apply(historyItem, true);
      notify(result.updates), state.redoStack.push(result.reverse);
      for (const op of historyItem)
        "presence" !== op.type && state.buffer.storageOperations.push(op);
      tryFlushing();
    },
    redo: function() {
      if (state.isBatching)
        throw new Error("redo is not allowed during a batch");
      const historyItem = state.redoStack.pop();
      if (null == historyItem)
        return;
      state.isHistoryPaused = false;
      const result = apply(historyItem, true);
      notify(result.updates), state.undoStack.push(result.reverse);
      for (const op of historyItem)
        "presence" !== op.type && state.buffer.storageOperations.push(op);
      tryFlushing();
    },
    pauseHistory: function() {
      state.pausedHistory = [], state.isHistoryPaused = true;
    },
    resumeHistory: function() {
      state.isHistoryPaused = false, state.pausedHistory.length > 0 && addToUndoStack(state.pausedHistory), state.pausedHistory = [];
    },
    getStorage: function() {
      return state.root ? new Promise((resolve) => resolve({ root: state.root })) : (null == _getInitialStatePromise && (state.buffer.messages.push({ type: ClientMsgCode.FETCH_STORAGE }), tryFlushing(), _getInitialStatePromise = new Promise(
        (resolve) => _getInitialStateResolver = resolve
      )), _getInitialStatePromise.then(() => ({ root: nn(state.root) })));
    },
    selectors: {
      getConnectionState: function() {
        return state.connection.state;
      },
      getSelf: function() {
        return "open" === state.connection.state || "connecting" === state.connection.state ? {
          connectionId: state.connection.id,
          id: state.connection.userId,
          info: state.connection.userInfo,
          presence: getPresence()
        } : null;
      },
      getPresence,
      getOthers: function() {
        return state.others;
      }
    }
  };
}
function createRoom(options, context) {
  var _a, _b;
  const initialPresence = null !== (_a = options.initialPresence) && void 0 !== _a ? _a : options.defaultPresence, initialStorage = null !== (_b = options.initialStorage) && void 0 !== _b ? _b : options.defaultStorageRoot, machine = makeStateMachine(
    function(initialPresence2, initialStorage2) {
      return {
        connection: { state: "closed" },
        token: null,
        lastConnectionId: null,
        socket: null,
        listeners: {
          event: [],
          others: [],
          "my-presence": [],
          error: [],
          connection: [],
          storage: []
        },
        numberOfRetry: 0,
        lastFlushTime: 0,
        timeoutHandles: { flush: null, reconnect: 0, pongTimeout: 0 },
        buffer: {
          presence: null == initialPresence2 ? {} : initialPresence2,
          messages: [],
          storageOperations: []
        },
        intervalHandles: { heartbeat: 0 },
        me: null == initialPresence2 ? {} : initialPresence2,
        users: {},
        others: makeOthers({}),
        defaultStorageRoot: initialStorage2,
        idFactory: null,
        clock: 0,
        opClock: 0,
        items: /* @__PURE__ */ new Map(),
        root: void 0,
        undoStack: [],
        redoStack: [],
        isHistoryPaused: false,
        pausedHistory: [],
        isBatching: false,
        batch: {
          ops: [],
          updates: { storageUpdates: /* @__PURE__ */ new Map(), presence: false, others: [] },
          reverseOps: []
        },
        offlineOperations: /* @__PURE__ */ new Map()
      };
    }(
      "function" == typeof initialPresence ? initialPresence(context.roomId) : initialPresence,
      "function" == typeof initialStorage ? initialStorage(context.roomId) : initialStorage
    ),
    context
  ), room = {
    id: context.roomId,
    getConnectionState: machine.selectors.getConnectionState,
    getSelf: machine.selectors.getSelf,
    subscribe: machine.subscribe,
    getPresence: machine.selectors.getPresence,
    updatePresence: machine.updatePresence,
    getOthers: machine.selectors.getOthers,
    broadcastEvent: machine.broadcastEvent,
    getStorage: machine.getStorage,
    batch: machine.batch,
    history: {
      undo: machine.undo,
      redo: machine.redo,
      pause: machine.pauseHistory,
      resume: machine.resumeHistory
    },
    __INTERNAL_DO_NOT_USE: {
      simulateCloseWebsocket: machine.simulateSocketClose,
      simulateSendCloseEvent: machine.simulateSendCloseEvent
    }
  };
  return {
    connect: machine.connect,
    disconnect: machine.disconnect,
    onNavigatorOnline: machine.onNavigatorOnline,
    onVisibilityChange: machine.onVisibilityChange,
    room
  };
}
var LiveblocksError = class extends Error {
  constructor(message, code) {
    super(message), this.code = code;
  }
};
function fetchAuthEndpoint(fetch2, endpoint, body) {
  return fetch2(endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  }).then((res) => {
    if (!res.ok)
      throw new AuthenticationError(
        `Expected a status 200 but got ${res.status} when doing a POST request on "${endpoint}"`
      );
    return res.json().catch((er) => {
      throw new AuthenticationError(
        `Expected a JSON response when doing a POST request on "${endpoint}". ${er}`
      );
    });
  }).then((data) => {
    if (!isPlainObject(data) || "string" != typeof data.token)
      throw new AuthenticationError(
        `Expected a JSON response of the form \`{ token: "..." }\` when doing a POST request on "${endpoint}", but got ${JSON.stringify(
          data
        )}`
      );
    const { token } = data;
    return { token };
  });
}
var AuthenticationError = class extends Error {
  constructor(message) {
    super(message);
  }
};
function createClient(options) {
  const clientOptions = options, throttleDelay = function(options2) {
    if (void 0 === options2.throttle)
      return 100;
    if ("number" != typeof options2.throttle || options2.throttle < 80 || options2.throttle > 1e3)
      throw new Error("throttle should be a number between 80 and 1000.");
    return options2.throttle;
  }(options), rooms = /* @__PURE__ */ new Map();
  return "undefined" != typeof window && void 0 !== window.addEventListener && window.addEventListener("online", () => {
    for (const [, room] of rooms)
      room.onNavigatorOnline();
  }), "undefined" != typeof document && document.addEventListener("visibilitychange", () => {
    for (const [, room] of rooms)
      room.onVisibilityChange(document.visibilityState);
  }), {
    getRoom: function(roomId) {
      const internalRoom = rooms.get(roomId);
      return internalRoom ? internalRoom.room : null;
    },
    enter: function(roomId, options2 = {}) {
      var _a;
      let internalRoom = rooms.get(roomId);
      if (internalRoom)
        return internalRoom.room;
      if (errorIf(
        options2.defaultPresence,
        "Argument `defaultPresence` will be removed in @liveblocks/client 0.18. Please use `initialPresence` instead. For more info, see https://bit.ly/3Niy5aP"
      ), errorIf(
        options2.defaultStorageRoot,
        "Argument `defaultStorageRoot` will be removed in @liveblocks/client 0.18. Please use `initialStorage` instead. For more info, see https://bit.ly/3Niy5aP"
      ), internalRoom = createRoom(
        {
          initialPresence: options2.initialPresence,
          initialStorage: options2.initialStorage,
          defaultPresence: options2.defaultPresence,
          defaultStorageRoot: options2.defaultStorageRoot
        },
        {
          roomId,
          throttleDelay,
          polyfills: clientOptions.polyfills,
          WebSocketPolyfill: clientOptions.WebSocketPolyfill,
          fetchPolyfill: clientOptions.fetchPolyfill,
          liveblocksServer: (null == clientOptions ? void 0 : clientOptions.liveblocksServer) || "wss://liveblocks.net/v6",
          authentication: prepareAuthentication(clientOptions)
        }
      ), rooms.set(roomId, internalRoom), !options2.DO_NOT_USE_withoutConnecting) {
        if ("undefined" == typeof atob) {
          if (null == (null === (_a = clientOptions.polyfills) || void 0 === _a ? void 0 : _a.atob))
            throw new Error(
              "You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill"
            );
          global.atob = clientOptions.polyfills.atob;
        }
        internalRoom.connect();
      }
      return internalRoom.room;
    },
    leave: function(roomId) {
      const room = rooms.get(roomId);
      room && (room.disconnect(), rooms.delete(roomId));
    }
  };
}
function prepareAuthentication(clientOptions) {
  const { publicApiKey, authEndpoint } = clientOptions;
  if (void 0 !== authEndpoint && void 0 !== publicApiKey)
    throw new Error(
      "You cannot use both publicApiKey and authEndpoint. Please use either publicApiKey or authEndpoint, but not both. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
    );
  if ("string" == typeof publicApiKey) {
    if (publicApiKey.startsWith("sk_"))
      throw new Error(
        "Invalid publicApiKey. You are using the secret key which is not supported. Please use the public key instead. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    if (!publicApiKey.startsWith("pk_"))
      throw new Error(
        "Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    return {
      type: "public",
      publicApiKey,
      url: clientOptions.publicAuthorizeEndpoint || "https://liveblocks.io/api/public/authorize"
    };
  }
  if ("string" == typeof authEndpoint)
    return { type: "private", url: authEndpoint };
  if ("function" == typeof authEndpoint)
    return { type: "custom", callback: authEndpoint };
  if (void 0 !== authEndpoint)
    throw new Error(
      "authEndpoint must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint"
    );
  throw new Error(
    "Invalid Liveblocks client options. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
  );
}

export {
  deprecate,
  errorIf,
  LiveList,
  LiveMap,
  LiveObject,
  createClient
};
//# sourceMappingURL=chunk-D2NE3554.js.map
